;; #!/usr/bin/env gosh
;; (use gauche.sequence)
;; (use util.match)

;; Generate test.scm for C++ from test-data.scm

;; (define (print-header)
;;   (print ";; Do not edit this file generated by gen-test.scm")
;;   (print "(define *test-error* '())")
;;   (print "(define *test-ret* '())")
;; )

;; (define (print-footer)
;;   (print "(if (null? *test-error*)")
;;   (print "(display \"passed.\n\")")
;;   (print "(display *test-error*))"))

;; (define (print-test p)
;;   (define (rec expect test)
;;     (print (format "~s"
;;                    `(display "test ")))
;;     (print (format "~s"
;;                    `(display ',test)))
;;     (print (format "~s"
;;                    `(display ", expects ")))
;;     (print (format "~s"
;;                    `(display ',expect)))
;;     (let loop ([t test])
;;       (if (null? (cdr t))
;;           (write `(set! *test-ret* ,(car t)))
;;           (begin
;;             (write (car t))
;;             (loop (cdr t)))))
;;     (write `(if (equal? *test-ret* ',expect)
;;                 (display " ===> ok\n")
;;                 (begin
;;                   (set! *test-error* (cons (quote ,@test) *test-error*))
;;                   (display " ===> NG got ")
;;                   (write *test-ret*)
;;                   (display "\n")
;;                   (error "test" "test failed" '(,@test))))))
;;   (match p
;;     [('lib expect . test)
;;      (print '(init-library-table))
;;      (rec expect test)]
;;     [('mosh-only expect . test)
;;      (rec expect test)]
;;     [('error . test)
;;      (rec #t (list `(equal? 'error (guard (con [#t 'error])
;;                                     ,@test))))]
;;     [(expect . test)
;;      (rec expect test)]))

(define (file->sexp file)
  (with-input-from-file file
    (lambda ()
      (let loop ([obj (read)]
                 [ret '()])
        (cond
         [(eof-object? obj)
          (reverse ret)]
         [else
          (loop (read) (cons obj ret))])))))

  (define (for-each-with-index proc lst)
    (do ((i 1 (+ i 1)) ; start with 1
         (lst lst (cdr lst)))
        ((null? lst))
      (proc i (car lst))))


(define (main args)
  (let* ([test* (file->sexp (second args))]
         [test-num (length test*)])
    (for-each-with-index
     (lambda (index test)
       (match test
         [('error . test)
          (write `(if (equal? 'error (guard (con [#t 'error])
                                    ,@test))
                      (format #t "~d   \r" ,index)
                      (error 'test "failed")))]
         [('mosh-only expected . test)
          (write `(let1 val (begin ,@test)
                    (if (equal? (quote ,expected) val)
                      (format #t "~d   \r" ,index)
                      (error 'test "failed" (quote ,expected) val))))
          (newline)]


         [(expected . test)
          (write `(if (equal? (quote ,expected) (begin ,@test))
                      (format #t "~d   \r" ,index)
                      (begin
                        (newline)
                        (error 'test "\nfailed" (quote ,expected)))))
          (newline)
          ]
         [else
          #t
          ]))
     test*))
  (exit 0))

(main (command-line))
