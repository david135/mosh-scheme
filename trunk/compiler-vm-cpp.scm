;; Do not edit this file generated by ./scripts/gen-compiler.scm.
(define dd display)(define pp print)(define *free-vars-decl* '(number? cons car cdr null? set-car! set-cdr! sys-display rxmatch regexp? regexp->string rxmatch-start rxmatch-end rxmatch-after rxmatch-before rxmatch-substring make-string string-set! string-length string->symbol string->number string-append string-split number->string reverse eof-object? read-char char=? string? sys-getenv equal? open-string-input-port sys-open-output-string sys-port-seek open-output-file close-output-port digit->integer get-remaining-input-string sys-readdir file-exists? sys-get-output-string string->regexp char->integer integer->char format current-input-port current-output-port set-current-input-port! set-current-output-port! char? write gensym string=? vector? list? memq eq? member boolean? symbol->string string-ref error get-timeofday make-eq-hashtable hashtable-set! hashtable-ref hashtable-keys current-error-port values vm/apply pair? init-library-table map10 find10 make-custom-binary-input-port get-u8 bytevector-u8-set! transcoded-port utf-8-codec make-transcoder eof-object sys-open-bytevector-output-port sys-get-bytevector bytevector-length bytevector-u8-ref standard-input-port get-bytevector-n utf8->string open-file-output-port open-file-input-port close-input-port vector regexp-replace regexp-replace-all source-info errorf eval raise raise-continuable with-exception-handler make-vector-type vector-type? vector-type-data vector-type-instance-of? make-typed-vector typed-vector-get-nth typed-vector-set-nth typed-vector? typed-vector-type apply mod div assq exit macroexpand-1 memv procedure? load symbol? dynamic-wind char<=? char<? char>=? char>? read vector->list set-source-info! call-process %get-closure-name append append2 appendA append! pass3/find-free pass3/find-sets %set-union %set-intersect make-code-builder code-builder-put1! code-builder-put2! code-builder-put3! code-builder-put4! code-builder-put5! code-builder-append! code-builder-emit))(define-macro (make-list-with-src-slot lst) lst)(define (command-line) *command-line-args*)(define
  ($for-each1-with-rindex proc lst)
  (let loop
       ((i (- (length lst) 1)) (lst lst))
       (cond ((null? lst) (quote ()))
             (else (proc i (car lst))
                   (loop (- i 1) (cdr lst))))))

(define-macro
  (begin0 form . forms)
  (let ((var (gensym)))
       (quasiquote
         (let (((unquote var) (unquote form)))
              (unquote-splicing forms)
              (unquote var)))))

(define-macro
  (first o)
  (quasiquote (car (unquote o))))

(define-macro
  (second o)
  (quasiquote (cadr (unquote o))))

(define-macro
  (third o)
  (quasiquote (caddr (unquote o))))

(define-macro
  (dolist a . body)
  (quasiquote
    (begin (for-each
             (lambda
               ((unquote (first a)))
               (unquote-splicing body))
             (unquote (second a)))
           (quote ()))))

(define-macro
  (do . sexp)
  (match sexp
         ((((var init step ...) ...)
           (test expr ...)
           command
           ...)
          (quasiquote
            (letrec
              ((loop (lambda
                       ((unquote-splicing var))
                       (if (unquote test)
                           (begin #f (unquote-splicing expr))
                           (begin (unquote-splicing command)
                                  (loop (unquote-splicing
                                          (map (lambda
                                                 (v s)
                                                 (quasiquote
                                                   (do "step"
                                                       (unquote v)
                                                       (unquote-splicing s))))
                                               var
                                               step))))))))
              (loop (unquote-splicing init)))))
         (("step" x) x)
         (("step" x y) y)
         (else (syntax-error "malformed do"))))

(define-macro
  (acond . clauses)
  (if (null? clauses)
      (quote ())
      (let ((cl1 (car clauses)) (sym (gensym)))
           (quasiquote
             (let (((unquote sym) (unquote (car cl1))))
                  (if (unquote sym)
                      (let ((it (unquote sym)))
                           (unquote-splicing (cdr cl1)))
                      (acond (unquote-splicing (cdr clauses)))))))))

(define-macro
  (aif test-form then-form . else-form)
  (quasiquote
    (let ((it (unquote test-form)))
         (if it
             (unquote then-form)
             (unquote-splicing else-form)))))

(define
  (syntax-error msg)
  (raise (format "syntax error: ~a" msg)))

(define
  (acons obj1 obj2 obj3)
  (cons (cons obj1 obj2) obj3))

(define
  (libname->symbol name)
  (let loop
       ((name name) (ret ""))
       (if (null? name)
           (string->symbol ret)
           (loop (cdr name)
                 (string-append
                   ret
                   (symbol->string (car name))
                   " ")))))

(define
  (%set-union l1 l2)
  (define
    (set-cons x lst)
    (if (memq x lst) lst (cons x lst)))
  (define
    (rec lst1 lst2)
    (cond ((null? lst1) lst2)
          ((null? lst2) lst1)
          (else (rec (cdr lst1) (set-cons (car lst1) lst2)))))
  (rec l1 l2))

(define
  (%set-intersect lst1 lst2)
  (if (null? lst1)
      (quote ())
      (if (memq2 (car lst1) lst2)
          (cons (car lst1)
                (%set-intersect (cdr lst1) lst2))
          (%set-intersect (cdr lst1) lst2))))

(define
  ($map1 f l)
  (if (null? l)
      l
      (cons (f (car l)) ($map1 f (cdr l)))))

(define
  ($filter-map1 f l)
  (if (null? l)
      l
      (aif (f (car l))
           (cons it ($filter-map1 f (cdr l)))
           ($filter-map1 f (cdr l)))))

(define
  ($map1-with-tail f l)
  (if (null? l)
      l
      (cons (f (car l) (null? (cdr l)))
            ($map1-with-tail f (cdr l)))))

(define-macro
  ($append-map1 f l)
  (quasiquote
    (apply append ($map1 (unquote f) (unquote l)))))

(define
  (uniq lst)
  (let loop
       ((lst lst) (ret (quote ())))
       (cond ((null? lst) ret)
             (else (if (memq (car lst) ret)
                       (loop (cdr lst) ret)
                       (loop (cdr lst) (cons (car lst) ret)))))))

(define
  (apply-each-pair proc lst)
  (if (null? (cdr lst))
      (quote ())
      (cons (list proc (car lst) (cadr lst))
            (apply-each-pair proc (cdr lst)))))

(define
  (remove-tail lst pred)
  (let loop
       ((lst lst) (ret (quote ())))
       (cond ((null? (cdr lst))
              (reverse
                (if (pred (car lst)) ret (cons (car lst) ret))))
             (else (loop (cdr lst) (cons (car lst) ret))))))

(define $CONST 0)

(define
  ($const val)
  (let1 v
        (make-vector 2)
        (vector-set! v 0 $CONST)
        (vector-set! v 1 val)
        v))

(define-macro
  ($const.val iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($const.set-val! iform val)
  (quasiquote
    (vector-set! (unquote iform) 1 (unquote val))))

(define $LVAR 1)

(define
  ($lvar sym init-val ref-count set-count)
  (let1 v
        (make-vector 5)
        (vector-set! v 0 $LVAR)
        (vector-set! v 1 sym)
        (vector-set! v 2 init-val)
        (vector-set! v 3 ref-count)
        (vector-set! v 4 set-count)
        v))

(define-macro
  ($lvar.sym iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($lvar.init-val iform)
  (quasiquote (vector-ref (unquote iform) 2)))

(define-macro
  ($lvar.ref-count iform)
  (quasiquote (vector-ref (unquote iform) 3)))

(define-macro
  ($lvar.set-count iform)
  (quasiquote (vector-ref (unquote iform) 4)))

(define-macro
  ($lvar.set-sym! iform sym)
  (quasiquote
    (vector-set! (unquote iform) 1 (unquote sym))))

(define-macro
  ($lvar.set-init-val! iform init-val)
  (quasiquote
    (vector-set!
      (unquote iform)
      2
      (unquote init-val))))

(define-macro
  ($lvar.set-ref-count! iform ref-count)
  (quasiquote
    (vector-set!
      (unquote iform)
      3
      (unquote ref-count))))

(define-macro
  ($lvar.set-set-count! iform set-count)
  (quasiquote
    (vector-set!
      (unquote iform)
      4
      (unquote set-count))))

(define
  (pp-lvars lvars)
  (print (map (lambda (x) ($lvar.sym x)) lvars)))

(define $LET 2)

(define
  ($let type lvars inits body tail? src)
  (let1 v
        (make-vector 7)
        (vector-set! v 0 $LET)
        (vector-set! v 1 type)
        (vector-set! v 2 lvars)
        (vector-set! v 3 inits)
        (vector-set! v 4 body)
        (vector-set! v 5 tail?)
        (vector-set! v 6 src)
        v))

(define-macro
  ($let.type iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($let.lvars iform)
  (quasiquote (vector-ref (unquote iform) 2)))

(define-macro
  ($let.inits iform)
  (quasiquote (vector-ref (unquote iform) 3)))

(define-macro
  ($let.body iform)
  (quasiquote (vector-ref (unquote iform) 4)))

(define-macro
  ($let.tail? iform)
  (quasiquote (vector-ref (unquote iform) 5)))

(define-macro
  ($let.src iform)
  (quasiquote (vector-ref (unquote iform) 6)))

(define-macro
  ($let.set-type! iform type)
  (quasiquote
    (vector-set! (unquote iform) 1 (unquote type))))

(define-macro
  ($let.set-lvars! iform lvars)
  (quasiquote
    (vector-set! (unquote iform) 2 (unquote lvars))))

(define-macro
  ($let.set-inits! iform inits)
  (quasiquote
    (vector-set! (unquote iform) 3 (unquote inits))))

(define-macro
  ($let.set-body! iform body)
  (quasiquote
    (vector-set! (unquote iform) 4 (unquote body))))

(define-macro
  ($let.set-tail?! iform tail?)
  (quasiquote
    (vector-set! (unquote iform) 5 (unquote tail?))))

(define-macro
  ($let.set-src! iform src)
  (quasiquote
    (vector-set! (unquote iform) 6 (unquote src))))

(define $SEQ 3)

(define
  ($seq body tail?)
  (let1 v
        (make-vector 3)
        (vector-set! v 0 $SEQ)
        (vector-set! v 1 body)
        (vector-set! v 2 tail?)
        v))

(define-macro
  ($seq.body iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($seq.tail? iform)
  (quasiquote (vector-ref (unquote iform) 2)))

(define-macro
  ($seq.set-body! iform body)
  (quasiquote
    (vector-set! (unquote iform) 1 (unquote body))))

(define-macro
  ($seq.set-tail?! iform tail?)
  (quasiquote
    (vector-set! (unquote iform) 2 (unquote tail?))))

(define $LAMBDA 4)

(define
  ($lambda
    src
    name
    reqargs
    optarg
    lvars
    body
    flag
    calls)
  (let1 v
        (make-vector 9)
        (vector-set! v 0 $LAMBDA)
        (vector-set! v 1 src)
        (vector-set! v 2 name)
        (vector-set! v 3 reqargs)
        (vector-set! v 4 optarg)
        (vector-set! v 5 lvars)
        (vector-set! v 6 body)
        (vector-set! v 7 flag)
        (vector-set! v 8 calls)
        v))

(define-macro
  ($lambda.src iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($lambda.name iform)
  (quasiquote (vector-ref (unquote iform) 2)))

(define-macro
  ($lambda.reqargs iform)
  (quasiquote (vector-ref (unquote iform) 3)))

(define-macro
  ($lambda.optarg iform)
  (quasiquote (vector-ref (unquote iform) 4)))

(define-macro
  ($lambda.lvars iform)
  (quasiquote (vector-ref (unquote iform) 5)))

(define-macro
  ($lambda.body iform)
  (quasiquote (vector-ref (unquote iform) 6)))

(define-macro
  ($lambda.flag iform)
  (quasiquote (vector-ref (unquote iform) 7)))

(define-macro
  ($lambda.calls iform)
  (quasiquote (vector-ref (unquote iform) 8)))

(define-macro
  ($lambda.set-src! iform src)
  (quasiquote
    (vector-set! (unquote iform) 1 (unquote src))))

(define-macro
  ($lambda.set-name! iform name)
  (quasiquote
    (vector-set! (unquote iform) 2 (unquote name))))

(define-macro
  ($lambda.set-reqargs! iform reqargs)
  (quasiquote
    (vector-set! (unquote iform) 3 (unquote reqargs))))

(define-macro
  ($lambda.set-optarg! iform optarg)
  (quasiquote
    (vector-set! (unquote iform) 4 (unquote optarg))))

(define-macro
  ($lambda.set-lvars! iform lvars)
  (quasiquote
    (vector-set! (unquote iform) 5 (unquote lvars))))

(define-macro
  ($lambda.set-body! iform body)
  (quasiquote
    (vector-set! (unquote iform) 6 (unquote body))))

(define-macro
  ($lambda.set-flag! iform flag)
  (quasiquote
    (vector-set! (unquote iform) 7 (unquote flag))))

(define-macro
  ($lambda.set-calls! iform calls)
  (quasiquote
    (vector-set! (unquote iform) 8 (unquote calls))))

(define $LOCAL-REF 5)

(define
  ($local-ref lvar)
  (let1 v
        (make-vector 2)
        (vector-set! v 0 $LOCAL-REF)
        (vector-set! v 1 lvar)
        v))

(define-macro
  ($local-ref.lvar iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($local-ref.set-lvar! iform lvar)
  (quasiquote
    (vector-set! (unquote iform) 1 (unquote lvar))))

(define $LOCAL-ASSIGN 6)

(define
  ($local-assign lvar val)
  (let1 v
        (make-vector 3)
        (vector-set! v 0 $LOCAL-ASSIGN)
        (vector-set! v 1 lvar)
        (vector-set! v 2 val)
        v))

(define-macro
  ($local-assign.lvar iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($local-assign.val iform)
  (quasiquote (vector-ref (unquote iform) 2)))

(define-macro
  ($local-assign.set-lvar! iform lvar)
  (quasiquote
    (vector-set! (unquote iform) 1 (unquote lvar))))

(define-macro
  ($local-assign.set-val! iform val)
  (quasiquote
    (vector-set! (unquote iform) 2 (unquote val))))

(define $GLOBAL-REF 7)

(define
  ($global-ref libname sym)
  (let1 v
        (make-vector 3)
        (vector-set! v 0 $GLOBAL-REF)
        (vector-set! v 1 libname)
        (vector-set! v 2 sym)
        v))

(define-macro
  ($global-ref.libname iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($global-ref.sym iform)
  (quasiquote (vector-ref (unquote iform) 2)))

(define-macro
  ($global-ref.set-libname! iform libname)
  (quasiquote
    (vector-set! (unquote iform) 1 (unquote libname))))

(define-macro
  ($global-ref.set-sym! iform sym)
  (quasiquote
    (vector-set! (unquote iform) 2 (unquote sym))))

(define $GLOBAL-ASSIGN 8)

(define
  ($global-assign libname sym val)
  (let1 v
        (make-vector 4)
        (vector-set! v 0 $GLOBAL-ASSIGN)
        (vector-set! v 1 libname)
        (vector-set! v 2 sym)
        (vector-set! v 3 val)
        v))

(define-macro
  ($global-assign.libname iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($global-assign.sym iform)
  (quasiquote (vector-ref (unquote iform) 2)))

(define-macro
  ($global-assign.val iform)
  (quasiquote (vector-ref (unquote iform) 3)))

(define-macro
  ($global-assign.set-libname! iform libname)
  (quasiquote
    (vector-set! (unquote iform) 1 (unquote libname))))

(define-macro
  ($global-assign.set-sym! iform sym)
  (quasiquote
    (vector-set! (unquote iform) 2 (unquote sym))))

(define-macro
  ($global-assign.set-val! iform val)
  (quasiquote
    (vector-set! (unquote iform) 3 (unquote val))))

(define $UNDEF 9)

(define ($undef) (make-vector 1 $UNDEF))

(define $IF 10)

(define
  ($if test then else)
  (let1 v
        (make-vector 4)
        (vector-set! v 0 $IF)
        (vector-set! v 1 test)
        (vector-set! v 2 then)
        (vector-set! v 3 else)
        v))

(define-macro
  ($if.test iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($if.then iform)
  (quasiquote (vector-ref (unquote iform) 2)))

(define-macro
  ($if.else iform)
  (quasiquote (vector-ref (unquote iform) 3)))

(define-macro
  ($if.set-test! iform test)
  (quasiquote
    (vector-set! (unquote iform) 1 (unquote test))))

(define-macro
  ($if.set-then! iform then)
  (quasiquote
    (vector-set! (unquote iform) 2 (unquote then))))

(define-macro
  ($if.set-else! iform else)
  (quasiquote
    (vector-set! (unquote iform) 3 (unquote else))))

(define $ASM 11)

(define
  ($asm insn args)
  (let1 v
        (make-vector 3)
        (vector-set! v 0 $ASM)
        (vector-set! v 1 insn)
        (vector-set! v 2 args)
        v))

(define-macro
  ($asm.insn iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($asm.args iform)
  (quasiquote (vector-ref (unquote iform) 2)))

(define-macro
  ($asm.set-insn! iform insn)
  (quasiquote
    (vector-set! (unquote iform) 1 (unquote insn))))

(define-macro
  ($asm.set-args! iform args)
  (quasiquote
    (vector-set! (unquote iform) 2 (unquote args))))

(define $DEFINE 12)

(define
  ($define libname sym val)
  (let1 v
        (make-vector 4)
        (vector-set! v 0 $DEFINE)
        (vector-set! v 1 libname)
        (vector-set! v 2 sym)
        (vector-set! v 3 val)
        v))

(define-macro
  ($define.libname iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($define.sym iform)
  (quasiquote (vector-ref (unquote iform) 2)))

(define-macro
  ($define.val iform)
  (quasiquote (vector-ref (unquote iform) 3)))

(define-macro
  ($define.set-libname! iform libname)
  (quasiquote
    (vector-set! (unquote iform) 1 (unquote libname))))

(define-macro
  ($define.set-sym! iform sym)
  (quasiquote
    (vector-set! (unquote iform) 2 (unquote sym))))

(define-macro
  ($define.set-val! iform val)
  (quasiquote
    (vector-set! (unquote iform) 3 (unquote val))))

(define $CALL-CC 13)

(define
  ($call-cc proc tail?)
  (let1 v
        (make-vector 3)
        (vector-set! v 0 $CALL-CC)
        (vector-set! v 1 proc)
        (vector-set! v 2 tail?)
        v))

(define-macro
  ($call-cc.proc iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($call-cc.tail? iform)
  (quasiquote (vector-ref (unquote iform) 2)))

(define-macro
  ($call-cc.set-proc! iform proc)
  (quasiquote
    (vector-set! (unquote iform) 1 (unquote proc))))

(define-macro
  ($call-cc.set-tail?! iform tail?)
  (quasiquote
    (vector-set! (unquote iform) 2 (unquote tail?))))

(define $CALL 14)

(define
  ($call proc args tail? type)
  (let1 v
        (make-vector 5)
        (vector-set! v 0 $CALL)
        (vector-set! v 1 proc)
        (vector-set! v 2 args)
        (vector-set! v 3 tail?)
        (vector-set! v 4 type)
        v))

(define-macro
  ($call.proc iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($call.args iform)
  (quasiquote (vector-ref (unquote iform) 2)))

(define-macro
  ($call.tail? iform)
  (quasiquote (vector-ref (unquote iform) 3)))

(define-macro
  ($call.type iform)
  (quasiquote (vector-ref (unquote iform) 4)))

(define-macro
  ($call.set-proc! iform proc)
  (quasiquote
    (vector-set! (unquote iform) 1 (unquote proc))))

(define-macro
  ($call.set-args! iform args)
  (quasiquote
    (vector-set! (unquote iform) 2 (unquote args))))

(define-macro
  ($call.set-tail?! iform tail?)
  (quasiquote
    (vector-set! (unquote iform) 3 (unquote tail?))))

(define-macro
  ($call.set-type! iform type)
  (quasiquote
    (vector-set! (unquote iform) 4 (unquote type))))

(define $LABEL 15)

(define
  ($label label body)
  (let1 v
        (make-vector 3)
        (vector-set! v 0 $LABEL)
        (vector-set! v 1 label)
        (vector-set! v 2 body)
        v))

(define-macro
  ($label.label iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($label.body iform)
  (quasiquote (vector-ref (unquote iform) 2)))

(define-macro
  ($label.set-label! iform label)
  (quasiquote
    (vector-set! (unquote iform) 1 (unquote label))))

(define-macro
  ($label.set-body! iform body)
  (quasiquote
    (vector-set! (unquote iform) 2 (unquote body))))

(define-macro
  (make-label)
  (quasiquote ($label #f #f)))

(define-macro (ref-label l) l)

(define $LIST 16)

(define
  ($list args)
  (let1 v
        (make-vector 2)
        (vector-set! v 0 $LIST)
        (vector-set! v 1 args)
        v))

(define-macro
  ($list.args iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($list.set-args! iform args)
  (quasiquote
    (vector-set! (unquote iform) 1 (unquote args))))

(define $LIBRARY 17)

(define
  ($library
    name
    export-syms
    import-syms
    import
    macro
    body
    compiled-body)
  (let1 v
        (make-vector 8)
        (vector-set! v 0 $LIBRARY)
        (vector-set! v 1 (libname->symbol name))
        (vector-set! v 2 export-syms)
        (vector-set! v 3 import-syms)
        (vector-set! v 4 import)
        (vector-set! v 5 macro)
        (vector-set! v 6 body)
        (vector-set! v 7 compiled-body)
        v))

(define-macro
  ($library.name iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($library.export-syms iform)
  (quasiquote (vector-ref (unquote iform) 2)))

(define-macro
  ($library.import-syms iform)
  (quasiquote (vector-ref (unquote iform) 3)))

(define-macro
  ($library.import iform)
  (quasiquote (vector-ref (unquote iform) 4)))

(define-macro
  ($library.macro iform)
  (quasiquote (vector-ref (unquote iform) 5)))

(define-macro
  ($library.body iform)
  (quasiquote (vector-ref (unquote iform) 6)))

(define-macro
  ($library.compiled-body iform)
  (quasiquote (vector-ref (unquote iform) 7)))

(define-macro
  ($library.set-name! iform name)
  (quasiquote
    (vector-set! (unquote iform) 1 (unquote name))))

(define-macro
  ($library.set-export-syms! iform export-syms)
  (quasiquote
    (vector-set!
      (unquote iform)
      2
      (unquote export-syms))))

(define-macro
  ($library.set-import-syms! iform import-syms)
  (quasiquote
    (vector-set!
      (unquote iform)
      3
      (unquote import-syms))))

(define-macro
  ($library.set-import! iform import)
  (quasiquote
    (vector-set! (unquote iform) 4 (unquote import))))

(define-macro
  ($library.set-macro! iform macro)
  (quasiquote
    (vector-set! (unquote iform) 5 (unquote macro))))

(define-macro
  ($library.set-body! iform body)
  (quasiquote
    (vector-set! (unquote iform) 6 (unquote body))))

(define-macro
  ($library.set-compiled-body! iform compiled-body)
  (quasiquote
    (vector-set!
      (unquote iform)
      7
      (unquote compiled-body))))

(define $IMPORT 18)

(define
  ($import import-specs)
  (let1 v
        (make-vector 2)
        (vector-set! v 0 $IMPORT)
        (vector-set! v 1 import-specs)
        v))

(define-macro
  ($import.import-specs iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($import.set-import-specs! iform import-specs)
  (quasiquote
    (vector-set!
      (unquote iform)
      1
      (unquote import-specs))))

(define $IMPORT-SPEC 19)

(define
  ($import-spec libname level)
  (let1 v
        (make-vector 3)
        (vector-set! v 0 $IMPORT-SPEC)
        (vector-set! v 1 libname)
        (vector-set! v 2 level)
        v))

(define-macro
  ($import-spec.libname iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($import-spec.level iform)
  (quasiquote (vector-ref (unquote iform) 2)))

(define-macro
  ($import-spec.set-libname! iform libname)
  (quasiquote
    (vector-set! (unquote iform) 1 (unquote libname))))

(define-macro
  ($import-spec.set-level! iform level)
  (quasiquote
    (vector-set! (unquote iform) 2 (unquote level))))

(define $IT 20)

(define ($it) (make-vector 1 $IT))

(define $RECEIVE 21)

(define
  ($receive lvars reqargs optarg vals body tail?)
  (let1 v
        (make-vector 7)
        (vector-set! v 0 $RECEIVE)
        (vector-set! v 1 lvars)
        (vector-set! v 2 reqargs)
        (vector-set! v 3 optarg)
        (vector-set! v 4 vals)
        (vector-set! v 5 body)
        (vector-set! v 6 tail?)
        v))

(define-macro
  ($receive.lvars iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($receive.reqargs iform)
  (quasiquote (vector-ref (unquote iform) 2)))

(define-macro
  ($receive.optarg iform)
  (quasiquote (vector-ref (unquote iform) 3)))

(define-macro
  ($receive.vals iform)
  (quasiquote (vector-ref (unquote iform) 4)))

(define-macro
  ($receive.body iform)
  (quasiquote (vector-ref (unquote iform) 5)))

(define-macro
  ($receive.tail? iform)
  (quasiquote (vector-ref (unquote iform) 6)))

(define-macro
  ($receive.set-lvars! iform lvars)
  (quasiquote
    (vector-set! (unquote iform) 1 (unquote lvars))))

(define-macro
  ($receive.set-vals! iform body)
  (quasiquote
    (vector-set! (unquote iform) 4 (unquote body))))

(define-macro
  ($receive.set-body! iform body)
  (quasiquote
    (vector-set! (unquote iform) 5 (unquote body))))

(define-macro
  ($receive.set-tail?! iform tail?)
  (quasiquote
    (vector-set! (unquote iform) 6 (unquote tail?))))

(define $INSN-NUM 22)

(define-macro
  (tag iform)
  (quasiquote (vector-ref (unquote iform) 0)))

(define-macro
  (tag? iform t)
  (quasiquote
    (= (unquote t) (tag (unquote iform)))))

(define-macro
  (set-tag! iform t)
  (quasiquote
    (vector-set! (unquote iform) 0 (unquote t))))

(define-macro
  (make-lvar sym)
  (quasiquote ($lvar (unquote sym) (quote ()) 0 0)))

(define-macro
  ($lvar.ref-count++! lvar)
  (quasiquote
    ($lvar.set-ref-count!
      (unquote lvar)
      (+ ($lvar.ref-count (unquote lvar)) 1))))

(define-macro
  ($lvar.ref-count--! lvar)
  (quasiquote
    ($lvar.set-ref-count!
      (unquote lvar)
      (- ($lvar.ref-count (unquote lvar)) 1))))

(define-macro
  ($lvar.set-count++! lvar)
  (quasiquote
    ($lvar.set-set-count!
      (unquote lvar)
      (+ 1 ($lvar.set-count (unquote lvar))))))

(define-macro
  ($local-ref.copy dst src)
  (quasiquote
    ($local-ref.set-lvar!
      (unquote dst)
      ($local-ref.lvar (unquote src)))))

(define-macro
  ($library.add-import-syms! library import-syms)
  (quasiquote
    ($library.set-import-syms!
      (unquote library)
      (append2
        ($library.import-syms (unquote library))
        (unquote import-syms)))))

(define-macro
  ($library.add-import! library import)
  (quasiquote
    ($library.set-import!
      (unquote library)
      (append2
        ($library.import (unquote library))
        (list (unquote import))))))

(define
  (make-empty-library name)
  ($library
    name
    (quote ())
    (quote ())
    (quote ())
    (quote ())
    (quote ())
    #f))

(define
  top-level-library
  (make-empty-library (quote (top level))))

(define
  (parse-lambda-vars vars)
  (cond ((pair? vars)
         (let loop
              ((p vars) (ret (quote ())))
              (cond ((null? p) (list #f vars))
                    ((pair? p) (loop (cdr p) (cons (car p) ret)))
                    (else (list #t (reverse (cons p ret)))))))
        ((null? vars) (list #f (quote ())))
        (else (list #t (list vars)))))

(define
  (parse-lambda-args formals)
  (let loop
       ((formals formals) (args (quote ())))
       (cond ((null? formals)
              (values (reverse args) (length args) 0))
             ((pair? formals)
              (loop (cdr formals) (cons (car formals) args)))
             (else (values
                     (reverse (cons formals args))
                     (length args)
                     1)))))

(define-macro
  ($src x sexp)
  (quasiquote
    (set-source-info!
      (make-list-with-src-slot (unquote x))
      (source-info (unquote sexp)))))

(define
  (pass1/expand sexp)
  (define
    (lambda-has-define? sexp)
    (and (not (null? (cddr sexp)))
         (pair? (third sexp))
         (eq? (car (third sexp)) (quote define))))
  (define
    (let1->let sexp)
    (quasiquote
      (let (((unquote (second sexp)) (unquote (third sexp))))
           (unquote-splicing (cdddr sexp)))))
  (define
    (expand-let vars body)
    (let1 expanded-vars
          (fold-right
            (lambda
              (x y)
              (cons (list (first x) (pass1/expand (second x)))
                    y))
            (quote ())
            vars)
          (quasiquote
            (let (unquote expanded-vars)
                 (unquote-splicing (pass1/expand body))))))
  (cond ((pair? sexp)
         (case (first sexp)
               ((quote) sexp)
               ((define-macro) sexp)
               ((define)
                (if (define-is-lambda? sexp)
                    (pass1/expand (define->lambda sexp))
                    ($src ($map1 (lambda (s) (pass1/expand s)) sexp)
                          sexp)))
               ((let1)
                ($src (pass1/expand (let1->let sexp)) sexp))
               ((let)
                (if (let-is-named? sexp)
                    ($src (pass1/expand (named-let->letrec sexp))
                          sexp)
                    ($src (expand-let (second sexp) (cddr sexp))
                          sexp)))
               ((let*)
                ($src (pass1/expand (let*->let sexp)) sexp))
               ((cond)
                ($src (pass1/expand (cond->if sexp)) sexp))
               ((lambda)
                (cond ((lambda-has-define? sexp)
                       ($src (pass1/expand
                               ($src (internal-define->letrec sexp) sexp))
                             sexp))
                      (else ($src (append!
                                    (list (quote lambda) (cadr sexp))
                                    (pass1/expand (cddr sexp)))
                                  sexp))))
               ((when)
                (match sexp
                       (((quote when) pred body . more)
                        ($src (pass1/expand
                                (quasiquote
                                  (cond ((unquote pred)
                                         (unquote body)
                                         (unquote-splicing more)))))
                              sexp))
                       (else (syntax-error "malformed when"))))
               ((unless)
                (match sexp
                       (((quote unless) pred body . more)
                        ($src (pass1/expand
                                (quasiquote
                                  (cond ((not (unquote pred))
                                         (unquote body)
                                         (unquote-splicing more)))))
                              sexp))
                       (else (syntax-error "malformed unless"))))
               ((aif)
                ($src (pass1/expand (aif->let sexp)) sexp))
               ((case)
                ($src (pass1/expand (case->cond sexp)) sexp))
               ((quasiquote) (expand-quasiquote (cadr sexp) 0))
               (else sexp)))
        (else sexp)))

(define
  (define-is-lambda? sexp)
  (pair? (cadr sexp)))

(define
  (conditions->if conditions)
  (if (null? (cdr conditions))
      (car conditions)
      (list (quote if)
            (car conditions)
            (conditions->if (cdr conditions))
            #f)))

(define
  (find-serial-from-head pred lst)
  (let loop
       ((found (quote ())) (lst lst))
       (cond ((null? lst)
              (if (null? found)
                  (list (quote ()) lst)
                  (values found (quote ()))))
             ((pred (car lst))
              (loop (append2 found (list (car lst))) (cdr lst)))
             (else (if (null? found)
                       (list (quote ()) lst)
                       (list found lst))))))

(define
  (internal-define->letrec sexp)
  (let* ((body (cddr sexp))
         (args (second sexp))
         (ret (find-serial-from-head
                (lambda
                  (s)
                  (and (pair? s) (eq? (quote define) (car s))))
                body))
         (defines (first ret))
         (rest (second ret))
         (letrec-body
           ($src (quasiquote
                   (letrec
                     (unquote
                       (map (lambda (d) (list (second d) (third d)))
                            (map pass1/expand defines)))
                     (unquote-splicing rest)))
                 sexp)))
        ($src (quasiquote
                (lambda (unquote args) (unquote letrec-body)))
              sexp)))

(define
  (define->lambda sexp)
  (let ((args (cadr sexp)) (body (cddr sexp)))
       (quasiquote
         (define
           (unquote (car args))
           (unquote
             ($src (append! (list (quote lambda) (cdr args)) body)
                   sexp))))))

(define
  (unless->cond sexp)
  (quasiquote
    (cond ((not (unquote (cadr sexp)))
           (unquote-splicing (cddr sexp))))))

(define
  (let*->let sexp)
  (let ((args (cadr sexp)) (body (cddr sexp)))
       (car (let loop
                 ((args args))
                 (if (null? args)
                     body
                     ($src (quasiquote
                             ((let ((unquote (car args)))
                                   (unquote-splicing (loop (cdr args))))))
                           sexp))))))

(define
  (cond->if sexp)
  (define
    (make-if test then else)
    (let ((then (if (> (length then) 1)
                    (cons (quote begin) then)
                    (car then))))
         (quasiquote
           (if (unquote test) (unquote then) (unquote else)))))
  (let loop
       ((clauses (cdr sexp)))
       (if (null? clauses)
           (quote #f)
           (cond ((and (null? (cdr clauses))
                       (eq? (quote else) (caar clauses)))
                  (if (> (length (cdar clauses)) 1)
                      (cons (quote begin) (cdar clauses))
                      (cadar clauses)))
                 ((and (= 3 (length (car clauses)))
                       (eq? (quote =>) (cadar clauses)))
                  (let ((tmp (gensym)))
                       (quasiquote
                         (let (((unquote tmp) (unquote (caar clauses))))
                              (if (unquote tmp)
                                  ((unquote (caddar clauses)) (unquote tmp))
                                  (unquote (loop (cdr clauses))))))))
                 ((= 1 (length (car clauses)))
                  (let ((tmp (gensym)))
                       (quasiquote
                         (let (((unquote tmp) (unquote (caar clauses))))
                              (if (unquote tmp)
                                  (unquote tmp)
                                  (unquote (loop (cdr clauses))))))))
                 (else (make-if
                         (caar clauses)
                         (cdar clauses)
                         (loop (cdr clauses))))))))

(define
  (case->cond sexp)
  (define
    (expand-clauses clauses tmpname)
    (let loop
         ((clauses clauses))
         (if (null? clauses)
             (quote ())
             (if (eq? (quote else) (caar clauses))
                 clauses
                 (if (= 1 (length (caar clauses)))
                     (cons (quasiquote
                             ((eqv? (quote (unquote (caaar clauses)))
                                    (unquote tmpname))
                              (unquote-splicing (cdar clauses))))
                           (loop (cdr clauses)))
                     (cons (quasiquote
                             ((memv (unquote tmpname)
                                    (quote (unquote (caar clauses))))
                              (unquote-splicing (cdar clauses))))
                           (loop (cdr clauses))))))))
  (let* ((pred (cadr sexp))
         (clauses (cddr sexp))
         (tmpname (gensym))
         (expanded-clauses
           (expand-clauses clauses tmpname)))
        (quasiquote
          (let (((unquote tmpname) (unquote pred)))
               (cond (unquote-splicing expanded-clauses))))))

(define
  (named-let->letrec sexp)
  (let* ((name (cadr sexp))
         (args (caddr sexp))
         (vars ($map1 car args))
         (vals ($map1 cadr args))
         (body (cdddr sexp))
         (lambda-body
           ($src (quasiquote
                   (lambda (unquote vars) (unquote-splicing body)))
                 sexp)))
        ($src (quasiquote
                (letrec
                  (((unquote name) (unquote lambda-body)))
                  ((unquote name) (unquote-splicing vals))))
              sexp)))

(define
  (aif->let sexp)
  (quasiquote
    (let ((it (unquote (cadr sexp))))
         (if it
             (unquote (caddr sexp))
             (unquote (cadddr sexp))))))

(define
  (let-is-named? sexp)
  (symbol? (cadr sexp)))

(define
  (expand-quasiquote x level)
  (define
    (finalize-quasiquote mode arg)
    (cond ((eq? mode (quote quote))
           (list (quote quote) arg))
          ((eq? mode (quote unquote)) arg)
          ((eq? mode (quote unquote-splicing))
           (error ",@ in invalid context" arg))
          (else (cons mode arg))))
  (define
    (descend-quasiquote x level return)
    (cond ((vector? x)
           (descend-quasiquote-vector x level return))
          ((not (pair? x)) (return (quote quote) x))
          ((interesting-to-quasiquote? x (quote quasiquote))
           (descend-quasiquote-pair x (+ level 1) return))
          ((interesting-to-quasiquote? x (quote unquote))
           (cond ((= level 0) (return (quote unquote) (cadr x)))
                 (else (descend-quasiquote-pair x (- level 1) return))))
          ((interesting-to-quasiquote?
             x
             (quote unquote-splicing))
           (cond ((= level 0)
                  (return (quote unquote-splicing) (cadr x)))
                 (else (descend-quasiquote-pair x (- level 1) return))))
          (else (descend-quasiquote-pair x level return))))
  (define
    (descend-quasiquote-pair x level return)
    (descend-quasiquote
      (car x)
      level
      (lambda
        (car-mode car-arg)
        (descend-quasiquote
          (cdr x)
          level
          (lambda
            (cdr-mode cdr-arg)
            (cond ((and (eq? car-mode (quote quote))
                        (eq? cdr-mode (quote quote)))
                   (return (quote quote) x))
                  ((eq? car-mode (quote unquote-splicing))
                   (cond ((and (eq? cdr-mode (quote quote))
                               (null? cdr-arg))
                          (return (quote unquote) car-arg))
                         (else (return
                                 (quote append2)
                                 (list car-arg
                                       (finalize-quasiquote
                                         cdr-mode
                                         cdr-arg))))))
                  (else (return
                          (quote cons)
                          (list (finalize-quasiquote car-mode car-arg)
                                (finalize-quasiquote cdr-mode cdr-arg))))))))))
  (define
    (descend-quasiquote-vector x level return)
    (descend-quasiquote
      (vector->list x)
      level
      (lambda
        (mode arg)
        (if (equal? mode (quote quote))
            (return (quote quote) x)
            (return
              (quote list->vector)
              (list (finalize-quasiquote mode arg)))))))
  (define
    (interesting-to-quasiquote? x marker)
    (and (pair? x) (eq? (car x) marker)))
  (descend-quasiquote x level finalize-quasiquote))

(define
  (pass1/lib-refer->iform symbol library)
  (let1 import-syms
        ($library.import-syms library)
        (aif (find10
               (lambda (import) (eq? symbol (first import)))
               import-syms)
             ($global-ref (second it) (third it))
             ($global-ref ($library.name library) symbol))))

(define
  (pass1/lib-assign->iform symbol library val)
  (let1 import-syms
        ($library.import-syms library)
        (aif (find10
               (lambda (import) (eq? symbol (first import)))
               import-syms)
             ($global-assign (second it) (third it) val)
             ($global-assign
               ($library.name library)
               symbol
               val))))

(define
  (pass1/refer->iform symbol library lvars)
  (acond ((find10
            (lambda (lvar) (eq? ($lvar.sym lvar) symbol))
            lvars)
          ($lvar.ref-count++! it)
          ($local-ref it))
         ((pass1/lib-refer->iform symbol library) it)
         (#t ($global-ref (quote (top level)) symbol))))

(define
  (pass1/assign->iform sexp library lvars tail?)
  (let* ((symbol (second sexp))
         (val (third sexp))
         (iform (pass1/sexp->iform val library lvars tail?)))
        (acond ((find10
                  (lambda (lvar) (eq? ($lvar.sym lvar) symbol))
                  lvars)
                ($lvar.set-count++! it)
                ($local-assign it iform))
               ((pass1/lib-assign->iform symbol library iform)
                it)
               (#t
                ($global-assign (quote (top level)) symbol iform)))))

(define
  (pass1/body->iform body library lvars tail?)
  (let1 iforms
        ($map1-with-tail
          (lambda
            (b t?)
            (pass1/sexp->iform
              (pass1/expand b)
              library
              lvars
              (and t? tail?)))
          body)
        (if (= 1 (length iforms))
            (car iforms)
            ($seq iforms tail?))))

(define
  (pass1/lambda->iform name sexp library lvars)
  (define
    (dotpair->list p)
    (let loop
         ((p p))
         (cond ((and (not (pair? p)) (not (null? p)))
                (cons p (quote ())))
               ((null? p) (quote ()))
               (else (cons (car p) (loop (cdr p)))))))
  (let* ((vars (second sexp))
         (body (cddr sexp))
         (parsed-vars (parse-lambda-vars vars))
         (optional-arg? (first parsed-vars))
         (vars (second parsed-vars))
         (this-lvars
           ($map1 (lambda (sym) ($lvar sym #f 0 0)) vars)))
        ($lambda
          (cons (source-info sexp)
                (cons name (dotpair->list (second sexp))))
          name
          (if optional-arg?
              (- (length vars) 1)
              (length vars))
          (if optional-arg? 1 0)
          this-lvars
          (pass1/body->iform
            body
            library
            (append2 this-lvars lvars)
            #t)
          (quote ())
          (quote ()))))

(define libraries (make-eq-hashtable))

(define-macro
  (make-identifier alias libname name)
  (quasiquote
    (list (unquote alias)
          (unquote libname)
          (unquote name))))

(define
  (copy-identifier i)
  (list (first i) (second i) (third i)))

(define
  (library-name form)
  (remove-tail (second form) pair?))

(define
  (pass1/and->iform sexp library lvars tail?)
  (define
    (rec s)
    (match s
           (() ($const #t))
           ((s)
            (pass1/sexp->iform
              (pass1/expand s)
              library
              lvars
              tail?))
           ((e . more)
            ($if (pass1/sexp->iform
                   (pass1/expand e)
                   library
                   lvars
                   tail?)
                 (rec more)
                 ($it)))
           (else (error "syntax-error: malformed and:" sexp))))
  (rec (cdr sexp)))

(define
  (pass1/or->iform sexp library lvars tail?)
  (define
    (rec s)
    (match s
           (() ($const #f))
           ((s)
            (pass1/sexp->iform
              (pass1/expand s)
              library
              lvars
              tail?))
           ((e . more)
            ($if (pass1/sexp->iform
                   (pass1/expand e)
                   library
                   lvars
                   tail?)
                 ($it)
                 (rec more)))
           (else (error "syntax-error: malformed or:" sexp))))
  (rec (cdr sexp)))

(define
  (pass1/library->iform sexp library lvars)
  (define
    (get-identifier symbol libname imports)
    (aif (find10
           (lambda (import) (eq? symbol (first import)))
           imports)
         (copy-identifier it)
         (make-identifier symbol libname symbol)))
  (define
    (get-rename-identifier
      rename-set
      libname
      imports)
    (aif (find10
           (lambda
             (import)
             (eq? (first rename-set) (first import)))
           imports)
         (let1 identifier
               (copy-identifier it)
               (set-car! identifier (second rename-set))
               identifier)
         (make-identifier
           (second rename-set)
           libname
           (first rename-set))))
  (define
    (extract-exports imports libname form)
    (let loop
         ((export (cdr form)) (ret (quote ())))
         (cond ((null? export) ret)
               ((and (pair? (car export))
                     (eq? (caar export) (quote rename)))
                (loop (cdr export)
                      (append2
                        ret
                        ($map1 (lambda
                                 (p)
                                 (get-rename-identifier p libname imports))
                               (cdar export)))))
               (else (loop (cdr export)
                           (cons (get-identifier (car export) libname imports)
                                 ret))))))
  (let1 lib
        ($library
          (library-name sexp)
          (quote ())
          (quote ())
          (quote ())
          (quote ())
          (quote ())
          #f)
        ($library.set-import!
          lib
          (pass1/import->iform (fourth sexp) lib))
        ($library.set-export-syms!
          lib
          (extract-exports
            ($library.import-syms lib)
            ($library.name lib)
            (third sexp)))
        ($library.set-body! lib (cddddr sexp))
        (hashtable-set!
          libraries
          ($library.name lib)
          lib)
        lib))

(define
  (pass1/import->iform sexp library)
  (define
    (library-name form)
    (libname->symbol (remove-tail form pair?)))
  (define
    (parse-level form)
    (cond ((symbol? form)
           (case form
                 ((expand) 1)
                 ((run) 0)
                 (else (error "unknown for"))))
          ((and (pair? form)
                (= (length form) 2)
                (eq? (first form) (quote meta)))
           (second form))
          (else (error "unknown level on meta"))))
  (define
    (import-iter form level)
    (case (first form)
          ((for)
           (import-iter
             (second form)
             (parse-level (third form))))
          ((only)
           (let1 only-binds
                 (cddr form)
                 (acond ((hashtable-ref
                           libraries
                           (library-name (second form))
                           #f)
                         ($library.add-import-syms!
                           library
                           ($filter-map1
                             (lambda
                               (x)
                               (if (memq (car x) only-binds)
                                   (copy-identifier x)
                                   #f))
                             ($library.export-syms it)))
                         ($import-spec ($library.name it) level))
                        (#t
                         (error "library "
                                (library-name (second form))
                                " not found")))))
          ((except)
           (let1 except-binds
                 (cddr form)
                 (acond ((hashtable-ref
                           libraries
                           (library-name (second form))
                           #f)
                         ($library.add-import-syms!
                           library
                           ($filter-map1
                             (lambda
                               (x)
                               (if (memq (car x) except-binds)
                                   #f
                                   (copy-identifier x)))
                             ($library.export-syms it)))
                         ($import-spec ($library.name it) level))
                        (#t
                         (error "library "
                                (library-name (second form))
                                " not found")))))
          ((rename)
           (let1 renames
                 (cddr form)
                 (acond ((hashtable-ref
                           libraries
                           (library-name (second form))
                           #f)
                         ($library.add-import-syms!
                           library
                           ($filter-map1
                             (lambda
                               (x)
                               (aif (find10
                                      (lambda
                                        (rename)
                                        (eq? (first x) (first rename)))
                                      renames)
                                    (make-identifier
                                      (second it)
                                      (second x)
                                      (third x))
                                    (copy-identifier x)))
                             ($library.export-syms it)))
                         ($import-spec ($library.name it) level))
                        (#t
                         (error "library "
                                (library-name (second form))
                                " not found")))))
          ((prefix)
           (let1 prefix
                 (symbol->string (third form))
                 (acond ((hashtable-ref
                           libraries
                           (library-name (second form))
                           #f)
                         ($library.add-import-syms!
                           library
                           ($filter-map1
                             (lambda
                               (x)
                               (make-identifier
                                 (string->symbol
                                   (string-append
                                     prefix
                                     (symbol->string (first x))))
                                 (second x)
                                 (third x)))
                             ($library.export-syms it)))
                         ($import-spec ($library.name it) level))
                        (#t
                         (error "library "
                                (library-name (second form))
                                " not found")))))
          (else (acond ((hashtable-ref libraries (library-name form) #f)
                        ($library.add-import-syms!
                          library
                          ($map1 copy-identifier ($library.export-syms it)))
                        ($import-spec ($library.name it) level))
                       (#t
                        (error "library "
                               (library-name form)
                               " not found"))))))
  ($import
    ($map1 (lambda (i) (import-iter i 0)) (cdr sexp))))

(define
  (pass1/macroexpand sexp)
  (let1 proc
        (first sexp)
        (acond ((and (symbol? proc)
                     (assoc proc ($library.macro top-level-library)))
                (pass1/expand (vm/apply (cdr it) (cdr sexp))))
               (#t sexp))))

(define
  (pass1/sexp->iform sexp library lvars tail?)
  (define
    (sexp->iform sexp)
    (pass1/sexp->iform
      (pass1/expand sexp)
      library
      lvars
      tail?))
  (define
    (operator-nargs->iform op tag)
    (let* ((args (cdr sexp)) (len (length args)))
          (cond ((= 0 len)
                 (case op
                       ((+) (sexp->iform 0))
                       ((*) (sexp->iform 1))
                       (else (error op " got too few argment"))))
                ((= 1 len)
                 (case op
                       ((-) (sexp->iform (* -1 (car args))))
                       ((/)
                        (sexp->iform
                          (quasiquote (/ 1 (unquote (car args))))))
                       (else (sexp->iform (car args)))))
                ((= 2 len)
                 ($asm tag
                       (list (sexp->iform (first args))
                             (sexp->iform (second args)))))
                (else (let1 args-iform
                            ($map1 sexp->iform args)
                            (fold (lambda (x y) ($asm tag (list y x)))
                                  (car args-iform)
                                  (cdr args-iform)))))))
  (define
    (call-1arg->iform tag)
    ($asm tag
          (list (pass1/sexp->iform
                  (pass1/expand (second sexp))
                  library
                  lvars
                  tail?))))
  (define
    (call-1arg-optional->iform tag)
    ($asm tag
          (list (pass1/sexp->iform
                  (if (null? (cdr sexp))
                      (quote ())
                      (pass1/expand (second sexp)))
                  library
                  lvars
                  tail?))))
  (define
    (call-2args->iform tag)
    ($asm tag
          (list (pass1/sexp->iform
                  (pass1/expand (second sexp))
                  library
                  lvars
                  tail?)
                (pass1/sexp->iform
                  (pass1/expand (third sexp))
                  library
                  lvars
                  tail?))))
  (define
    (call-3args->iform tag)
    ($asm tag
          (list (pass1/sexp->iform
                  (pass1/expand (second sexp))
                  library
                  lvars
                  tail?)
                (pass1/sexp->iform
                  (pass1/expand (third sexp))
                  library
                  lvars
                  tail?)
                (pass1/sexp->iform
                  (pass1/expand (fourth sexp))
                  library
                  lvars
                  tail?))))
  (define
    (numcmp->iform operator args tag)
    (let1 len
          (length args)
          (cond ((> 2 len)
                 (error operator " got too few argument"))
                ((= 2 len)
                 ($asm tag
                       (list (sexp->iform (first args))
                             (sexp->iform (second args)))))
                (else (sexp->iform
                        (conditions->if (apply-each-pair operator args)))))))
  (cond ((pair? sexp)
         (case (car sexp)
               ((cons)
                ($asm (quote CONS)
                      ($map1 sexp->iform (cdr sexp))))
               ((and)
                (pass1/and->iform sexp library lvars tail?))
               ((or) (pass1/or->iform sexp library lvars tail?))
               ((begin)
                (pass1/body->iform
                  (pass1/expand (cdr sexp))
                  library
                  lvars
                  tail?))
               ((values)
                ($asm (quote VALUES)
                      ($map1 sexp->iform (cdr sexp))))
               ((define)
                (match sexp
                       (((quote define) name ((quote lambda) . more))
                        (let1 closure
                              (make-list-with-src-slot
                                (cons (quote lambda) more))
                              (set-source-info!
                                closure
                                (source-info (third sexp)))
                              ($define
                                ($library.name library)
                                name
                                (pass1/lambda->iform
                                  name
                                  closure
                                  library
                                  lvars))))
                       (else ($define
                               ($library.name library)
                               (second sexp)
                               (sexp->iform (third sexp))))))
               ((define-macro)
                (if (pair? (second sexp))
                    ($library.set-macro!
                      library
                      (acons (caadr sexp)
                             (compile-partial
                               (quasiquote
                                 (lambda
                                   (unquote (cdadr sexp))
                                   (unquote (third sexp))))
                               library)
                             ($library.macro library)))
                    ($library.set-macro!
                      library
                      (acons (second sexp)
                             (compile-partial (third sexp))
                             ($library.macro library))))
                ($undef))
               ((receive)
                (match sexp
                       (((quote receive) vars vals . body)
                        (receive
                          (vars reqargs optarg)
                          (parse-lambda-args vars)
                          (let1 this-lvars
                                ($map1 (lambda (sym) ($lvar sym #f 0 0)) vars)
                                ($receive
                                  this-lvars
                                  reqargs
                                  optarg
                                  (sexp->iform vals)
                                  (pass1/body->iform
                                    (pass1/expand body)
                                    library
                                    (append2 this-lvars lvars)
                                    tail?)
                                  tail?))))
                       (else (syntax-error "malformed receive"))))
               ((let)
                (let* ((vars ($map1 car (second sexp)))
                       (vals ($map1 cadr (second sexp)))
                       (body (cddr sexp))
                       (inits ($map1 sexp->iform vals))
                       (this-lvars
                         (map (lambda (sym init) ($lvar sym init 0 0))
                              vars
                              inits)))
                      ($let (quote let)
                            this-lvars
                            inits
                            (pass1/body->iform
                              (pass1/expand body)
                              library
                              (append2 this-lvars lvars)
                              tail?)
                            tail?
                            (source-info sexp))))
               ((letrec)
                (let* ((vars ($map1 car (second sexp)))
                       (vals ($map1 cadr (second sexp)))
                       (body (cddr sexp))
                       (this-lvars
                         ($map1 (lambda (sym) ($lvar sym ($undef) 0 0))
                                vars))
                       (inits ($map1 (lambda
                                       (x)
                                       (pass1/sexp->iform
                                         x
                                         library
                                         (append2 this-lvars lvars)
                                         tail?))
                                     vals)))
                      (for-each
                        (lambda
                          (lvar init)
                          ($lvar.set-init-val! lvar init))
                        this-lvars
                        inits)
                      ($let (quote rec)
                            this-lvars
                            inits
                            (pass1/body->iform
                              (pass1/expand body)
                              library
                              (append2 this-lvars lvars)
                              tail?)
                            tail?
                            (source-info sexp))))
               ((lambda)
                (pass1/lambda->iform
                  (quote lambda)
                  sexp
                  library
                  lvars))
               ((library)
                (pass1/library->iform sexp library lvars))
               ((import) (pass1/import->iform sexp library))
               ((set!)
                (pass1/assign->iform
                  (quasiquote
                    (set! (unquote (second sexp))
                          (unquote (pass1/expand (third sexp)))))
                  library
                  lvars
                  tail?))
               ((if)
                (let ((test (second sexp)) (then (third sexp)))
                     ($if (pass1/sexp->iform
                            (pass1/expand test)
                            library
                            lvars
                            #f)
                          (pass1/sexp->iform
                            (pass1/expand then)
                            library
                            lvars
                            tail?)
                          (if (null? (cdddr sexp))
                              ($undef)
                              (pass1/sexp->iform
                                (pass1/expand (fourth sexp))
                                library
                                lvars
                                tail?)))))
               ((call/cc)
                ($call-cc (sexp->iform (second sexp)) tail?))
               ((call-with-current-continuation)
                ($call-cc (sexp->iform (second sexp)) tail?))
               ((quote) ($const (second sexp)))
               ((make-vector)
                (if (null? (cddr sexp))
                    ($asm (quote MAKE_VECTOR)
                          (list (pass1/sexp->iform
                                  (pass1/expand (second sexp))
                                  library
                                  lvars
                                  tail?)
                                (pass1/sexp->iform
                                  (pass1/expand (quote ()))
                                  library
                                  lvars
                                  tail?)))
                    (call-2args->iform (quote MAKE_VECTOR))))
               ((+)
                (operator-nargs->iform
                  (quote +)
                  (quote NUMBER_ADD)))
               ((-)
                (operator-nargs->iform
                  (quote -)
                  (quote NUMBER_SUB)))
               ((*)
                (operator-nargs->iform
                  (quote *)
                  (quote NUMBER_MUL)))
               ((/)
                (operator-nargs->iform
                  (quote /)
                  (quote NUMBER_DIV)))
               ((=)
                (numcmp->iform
                  (quote =)
                  (cdr sexp)
                  (quote NUMBER_EQUAL)))
               ((>=)
                (numcmp->iform
                  (quote >=)
                  (cdr sexp)
                  (quote NUMBER_GE)))
               ((>)
                (numcmp->iform
                  (quote >)
                  (cdr sexp)
                  (quote NUMBER_GT)))
               ((<)
                (numcmp->iform
                  (quote <)
                  (cdr sexp)
                  (quote NUMBER_LT)))
               ((<=)
                (numcmp->iform
                  (quote <=)
                  (cdr sexp)
                  (quote NUMBER_LE)))
               ((vector?) (call-1arg->iform (quote VECTOR_P)))
               ((vector-length)
                (call-1arg->iform (quote VECTOR_LENGTH)))
               ((vector-set!)
                (call-3args->iform (quote VECTOR_SET)))
               ((vector-ref)
                (call-2args->iform (quote VECTOR_REF)))
               ((car) (call-1arg->iform (quote CAR)))
               ((cdr) (call-1arg->iform (quote CDR)))
               ((caar) (call-1arg->iform (quote CAAR)))
               ((cadr) (call-1arg->iform (quote CADR)))
               ((cdar) (call-1arg->iform (quote CDAR)))
               ((cddr) (call-1arg->iform (quote CDDR)))
               ((set-car!) (call-2args->iform (quote SET_CAR)))
               ((set-cdr!) (call-2args->iform (quote SET_CDR)))
               ((eq?) (call-2args->iform (quote EQ)))
               ((eqv?) (call-2args->iform (quote EQV)))
               ((equal?) (call-2args->iform (quote EQUAL)))
               ((not) (call-1arg->iform (quote NOT)))
               ((null?) (call-1arg->iform (quote NULL_P)))
               ((pair?) (call-1arg->iform (quote PAIR_P)))
               ((symbol?) (call-1arg->iform (quote SYMBOL_P)))
               ((read) (call-1arg-optional->iform (quote READ)))
               ((read-char)
                (call-1arg-optional->iform (quote READ_CHAR)))
               (else (let1 proc
                           (first sexp)
                           (acond ((and (symbol? proc)
                                        (assoc proc ($library.macro library)))
                                   (sexp->iform
                                     (vm/apply (cdr it) (cdr sexp))))
                                  ((and (symbol? proc)
                                        (find10
                                          (lambda (sym) (eq? (first sym) proc))
                                          ($library.import-syms library)))
                                   (let* ((lib (hashtable-ref
                                                 libraries
                                                 (second it)
                                                 #f))
                                          (mac (assoc (third it)
                                                      ($library.macro lib))))
                                         (if mac
                                             (sexp->iform
                                               (pass1/expand
                                                 (vm/apply
                                                   (cdr mac)
                                                   (cdr sexp))))
                                             ($call (sexp->iform proc)
                                                    ($map1 sexp->iform
                                                           (cdr sexp))
                                                    tail?
                                                    #f))))
                                  (#t
                                   ($call (sexp->iform proc)
                                          ($map1 sexp->iform (cdr sexp))
                                          tail?
                                          #f)))))))
        ((symbol? sexp)
         (pass1/refer->iform sexp library lvars))
        (else ($const sexp))))

(define
  (pretty-iform iform)
  (define labels (quote ()))
  (define
    (indent count)
    (dotimes (i count) (write-char #\space)))
  (define (nl ind) (newline) (indent ind))
  (define
    (lvar->string lvar)
    (format
      "~a[~a ~a]"
      ($lvar.sym lvar)
      ($lvar.ref-count lvar)
      ($lvar.set-count lvar)))
  (define
    (rec ind iform)
    (cond ((tag? iform $CONST)
           (format #t "($CONST ~s)" ($const.val iform)))
          ((tag? iform $UNDEF) (display "($UNDEF)"))
          ((tag? iform $LAMBDA)
           (format
             #t
             "($LAMBDA[~a ~a ~a]"
             ($lambda.name iform)
             (map lvar->string ($lambda.lvars iform))
             ($lambda.flag iform))
           (nl (+ ind 2))
           (rec (+ ind 2) ($lambda.body iform))
           (display ")"))
          ((tag? iform $SEQ)
           (format #t "($SEQ")
           (for-each
             (lambda
               (node)
               (nl (+ ind 2))
               (rec (+ ind 2) node))
             ($seq.body iform))
           (display ")"))
          ((tag? iform $LIBRARY)
           (format
             #t
             "($LIBRARY ~a export [~a] import [~a]"
             ($library.name iform)
             ($library.export-syms iform)
             ($library.import-syms iform))
           (nl (+ ind 2))
           (display ")"))
          ((tag? iform $LOCAL-REF)
           (format
             #t
             "($LOCAL-REF ~a)"
             (lvar->string ($local-ref.lvar iform))))
          ((tag? iform $GLOBAL-REF)
           (format
             #t
             "($GLOBAL-REF ~a ~a)"
             ($global-ref.libname iform)
             ($global-ref.sym iform)))
          ((tag? iform $LOCAL-ASSIGN)
           (format
             #t
             "($LOCAL-ASSIGN ~a"
             (lvar->string ($local-assign.lvar iform)))
           (nl (+ ind 2))
           (rec (+ ind 2) ($local-assign.val iform))
           (display ")"))
          ((tag? iform $GLOBAL-ASSIGN)
           (format
             #t
             "($GLOBAL-ASSIGN ~a ~a)"
             ($global-assign.sym iform)
             ($global-assign.val iform)))
          ((tag? iform $LET)
           (let* ((hdr (format "($LET ("))
                  (xind (+ ind (string-length hdr))))
                 (display hdr)
                 (for-each
                   (lambda
                     (var init)
                     (let1 z
                           (format "(~a " (lvar->string var))
                           (display z)
                           (rec (+ xind (string-length z)) init)
                           (display ")")
                           (nl xind)))
                   ($let.lvars iform)
                   ($let.inits iform))
                 (display ")")
                 (nl (+ ind 2))
                 (rec (+ ind 2) ($let.body iform))
                 (display ")")))
          ((tag? iform $IF)
           (display "($IF ")
           (rec (+ ind 5) ($if.test iform))
           (nl (+ ind 2))
           (rec (+ ind 2) ($if.then iform))
           (nl (+ ind 2))
           (rec (+ ind 2) ($if.else iform))
           (display ")"))
          ((tag? iform $LABEL)
           (cond ((assq iform labels)
                  =>
                  (lambda (p) (format #t "label#~a" (cdr p))))
                 (else (let1 num
                             (length labels)
                             (push! labels (cons iform num))
                             (format #t "($label #~a" num)
                             (nl (+ ind 2))
                             (rec (+ ind 2) ($label.body iform))
                             (display ")")))))
          ((tag? iform $ASM)
           (let1 insn
                 ($asm.insn iform)
                 (format #t "($asm ~a" insn))
           (for-each
             (lambda
               (node)
               (nl (+ ind 2))
               (rec (+ ind 2) node))
             ($asm.args iform))
           (display ")"))
          ((tag? iform $DEFINE)
           (format
             #t
             "($DEFINE ~a:~a"
             ($define.libname iform)
             ($define.sym iform))
           (nl (+ ind 2))
           (rec (+ ind 2) ($define.val iform))
           (display ")"))
          ((tag? iform $CALL-CC)
           (display "($CALL-CC ")
           (rec 0 ($call-cc.proc iform))
           (display ")"))
          ((tag? iform $LABEL)
           (display "($LABEL ")
           (rec 0 ($label.body iform))
           (display ")"))
          ((tag? iform $CALL)
           (let1 pre
                 (cond (($call.tail? iform)
                        =>
                        (lambda (x) "($call[tail] "))
                       (else "($call "))
                 (format #t pre)
                 (format #t "[~a]" ($call.type iform))
                 (rec (+ ind (string-length pre))
                      ($call.proc iform))
                 (for-each
                   (lambda
                     (node)
                     (nl (+ ind 2))
                     (rec (+ ind 2) node))
                   ($call.args iform))
                 (display ")")))
          (else (error "pretty-iform: unknown tag:" (tag iform)))))
  (rec 0 iform)
  (newline))

(define SMALL_LAMBDA_SIZE 12)

(define
  pass2/dispatch-table
  (make-vector $INSN-NUM))

(define
  (pass2/$let iform closures)
  ($let.set-body!
    iform
    (pass2/optimize ($let.body iform) closures))
  ($let.set-inits!
    iform
    ($map1 (lambda (i) (pass2/optimize i closures))
           ($let.inits iform)))
  (let1 o
        (pass2/eliminate-let iform)
        (if (eq? o iform) o (pass2/optimize o closures))))

(define
  (pass2/$receive iform closures)
  ($receive.set-body!
    iform
    (pass2/optimize ($receive.body iform) closures))
  ($receive.set-vals!
    iform
    (pass2/optimize ($receive.vals iform) closures))
  iform)

(define
  (pass2/$local-ref iform closures)
  (pass2/optimize-local-ref iform)
  iform)

(define
  (pass2/$seq iform closures)
  ($seq.set-body!
    iform
    ($map1 (lambda (x) (pass2/optimize x closures))
           ($seq.body iform)))
  iform)

(define
  (pass2/const-inliner iform)
  (let ((insn ($asm.insn iform))
        (args ($asm.args iform)))
       (case insn
             ((NUMBER_ADD)
              (when (and (tag? (first args) $CONST)
                         (tag? (second args) $CONST))
                    (vector-set! iform 0 $CONST)
                    ($const.set-val!
                      iform
                      (+ ($const.val (first args))
                         ($const.val (second args))))))
             ((NUMBER_MUL)
              (when (and (tag? (first args) $CONST)
                         (tag? (second args) $CONST))
                    (vector-set! iform 0 $CONST)
                    ($const.set-val!
                      iform
                      (* ($const.val (first args))
                         ($const.val (second args))))))
             ((NUMBER_MINUS)
              (when (and (tag? (first args) $CONST)
                         (tag? (second args) $CONST))
                    (vector-set! iform 0 $CONST)
                    ($const.set-val!
                      iform
                      (- ($const.val (first args))
                         ($const.val (second args))))))
             (else #f))))

(define
  (pass2/$asm iform closures)
  ($asm.set-args!
    iform
    ($map1 (lambda (x) (pass2/optimize x closures))
           ($asm.args iform)))
  (pass2/const-inliner iform)
  iform)

(define
  (pass2/$lambda iform closures)
  ($lambda.set-body!
    iform
    (pass2/optimize
      ($lambda.body iform)
      (cons iform closures)))
  iform)

(define
  (pass2/$if iform closures)
  (let ((test-c
          (pass2/optimize ($if.test iform) closures))
        (then-c
          (pass2/optimize ($if.then iform) closures))
        (else-c
          (pass2/optimize ($if.else iform) closures)))
       ($if test-c then-c else-c)))

(define
  (pass2/$call iform closures)
  (pass2/collect-call iform closures))

(define (pass2/empty iform closures) iform)

(define
  (pass2/register insn proc)
  (vector-set! pass2/dispatch-table insn proc))

(pass2/register $CONST pass2/empty)

(pass2/register $LAMBDA pass2/$lambda)

(pass2/register $LOCAL-REF pass2/$local-ref)

(pass2/register $LOCAL-ASSIGN pass2/empty)

(pass2/register $GLOBAL-ASSIGN pass2/empty)

(pass2/register $GLOBAL-REF pass2/empty)

(pass2/register $SEQ pass2/$seq)

(pass2/register $UNDEF pass2/empty)

(pass2/register $IF pass2/$if)

(pass2/register $ASM pass2/$asm)

(pass2/register $DEFINE pass2/empty)

(pass2/register $CALL pass2/$call)

(pass2/register $CALL-CC pass2/empty)

(pass2/register $LET pass2/$let)

(pass2/register $LIST pass2/empty)

(pass2/register $LIBRARY pass2/empty)

(pass2/register $IMPORT pass2/empty)

(pass2/register $IT pass2/empty)

(pass2/register $RECEIVE pass2/$receive)

(define
  (pass2/optimize iform closures)
  ((vector-ref
     pass2/dispatch-table
     (vector-ref iform 0))
   iform
   closures))

(define
  (pass2/optimize-local-ref iform)
  (let* ((lvar ($local-ref.lvar iform))
         (init-val ($lvar.init-val lvar)))
        (cond ((and init-val
                    (zero? ($lvar.set-count lvar))
                    (tag? init-val $CONST))
               (set-tag! iform $CONST)
               ($lvar.ref-count--! lvar)
               ($const.set-val! iform ($const.val init-val)))
              ((and init-val
                    (tag? init-val $LOCAL-REF)
                    (zero? ($lvar.set-count ($local-ref.lvar init-val))))
               ($lvar.ref-count--! lvar)
               ($lvar.ref-count++! ($local-ref.lvar init-val))
               ($local-ref.copy iform init-val)
               (pass2/optimize-local-ref iform))
              (else iform))))

(define
  (pass2/eliminate-let iform)
  (let ((vars ($let.lvars iform))
        (inits ($let.inits iform))
        (body ($let.body iform)))
       (for-each pass2/optimize-closure vars inits)
       (let* ((v (pass2/remove-vars vars inits))
              (new-vars (vector-ref v 0))
              (new-inits (vector-ref v 1))
              (removed-inits (vector-ref v 2)))
             (cond ((null? new-vars)
                    (if (null? removed-inits)
                        body
                        ($seq (append2 removed-inits (list body))
                              ($let.tail? iform))))
                   (else ($let.set-lvars! iform new-vars)
                         ($let.set-inits! iform new-inits)
                         ($let.set-body! iform body)
                         (unless
                           (null? removed-inits)
                           (if (tag? body $SEQ)
                               ($seq.set-body!
                                 body
                                 (append2 removed-inits ($seq.body body)))
                               ($let.set-body!
                                 iform
                                 ($seq (append2 removed-inits (list body))
                                       ($let.tail? iform)))))
                         iform)))))

(define
  (iform-copy-zip-lvs orig-lvars lv-alist)
  (let1 new-lvars
        ($map1 (lambda (lv) (make-lvar ($lvar.sym lv)))
               orig-lvars)
        (cons new-lvars
              (foldr2 acons lv-alist orig-lvars new-lvars))))

(define
  (iform-copy-lvar lvar lv-alist)
  (cond ((assq lvar lv-alist) => (lambda (p) (cdr p)))
        (else lvar)))

(define
  (iform-copy iform lv-alist)
  (let1 t
        (tag iform)
        (cond ((= $DEFINE t)
               ($define
                 ($define.libname iform)
                 ($define.sym iform)
                 (iform-copy ($define.val iform) lv-alist)))
              ((= $LOCAL-REF t)
               ($local-ref
                 (iform-copy-lvar
                   ($local-ref.lvar iform)
                   lv-alist)))
              ((= $LOCAL-ASSIGN t)
               ($local-assign
                 (iform-copy-lvar
                   ($local-assign.lvar iform)
                   lv-alist)
                 (iform-copy ($local-assign.val iform) lv-alist)))
              ((= $GLOBAL-REF t)
               ($global-ref
                 ($global-ref.libname iform)
                 ($global-ref.sym iform)))
              ((= $GLOBAL-ASSIGN t)
               ($global-assign
                 ($global-assign.libname iform)
                 ($global-assign.sym iform)
                 (iform-copy ($global-assign.val iform) lv-alist)))
              ((= $CONST t) ($const ($const.val iform)))
              ((= $IF t)
               ($if (iform-copy ($if.test iform) lv-alist)
                    (iform-copy ($if.then iform) lv-alist)
                    (iform-copy ($if.else iform) lv-alist)))
              ((= $LET t)
               (let* ((ret (iform-copy-zip-lvs ($let.lvars iform) lv-alist))
                      (newlvs (car ret))
                      (newalist (cdr ret)))
                     ($let ($let.type iform)
                           newlvs
                           (let1 al
                                 (case ($let.type iform)
                                       ((let) lv-alist)
                                       ((rec) newalist))
                                 ($map1 (lambda (x) (iform-copy x al))
                                        ($let.inits iform)))
                           (iform-copy ($let.body iform) newalist)
                           ($let.tail? iform)
                           ($let.src iform))))
              ((= $LAMBDA t)
               (let* ((ret (iform-copy-zip-lvs
                             ($lambda.lvars iform)
                             lv-alist))
                      (newlvs (car ret))
                      (newalist (cdr ret)))
                     ($lambda
                       ($lambda.src iform)
                       ($lambda.name iform)
                       ($lambda.reqargs iform)
                       ($lambda.optarg iform)
                       newlvs
                       (iform-copy ($lambda.body iform) newalist)
                       ($lambda.flag iform)
                       ($lambda.calls iform))))
              ((= $SEQ t)
               ($seq ($map1 (lambda (x) (iform-copy x lv-alist))
                            ($seq.body iform))
                     ($seq.tail? iform)))
              ((= $CALL t)
               ($call (iform-copy ($call.proc iform) lv-alist)
                      ($map1 (lambda (x) (iform-copy x lv-alist))
                             ($call.args iform))
                      #f
                      ($call.type iform)))
              ((= $ASM t)
               ($asm ($asm.insn iform)
                     ($map1 (lambda (x) (iform-copy x lv-alist))
                            ($asm.args iform))))
              (else iform))))

(define
  (pass2/optimize-closure lvar lambda-node)
  (when (and (zero? ($lvar.set-count lvar))
             (> ($lvar.ref-count lvar) 0)
             (tag? lambda-node $LAMBDA))
        (or (and (= ($lvar.ref-count lvar)
                    (length ($lambda.calls lambda-node)))
                 (let* ((ret (pass2/classify-calls
                               ($lambda.calls lambda-node)
                               lambda-node))
                        (locals (first ret))
                        (recs (second ret))
                        (tail-recs (third ret)))
                       (and (null? recs)
                            (pair? locals)
                            (or (and (null? (cdr locals))
                                     (pass2/local-call-embedder
                                       lvar
                                       lambda-node
                                       (car locals)
                                       tail-recs))
                                (and (null? tail-recs)
                                     (< (iform-count-size-upto
                                          lambda-node
                                          SMALL_LAMBDA_SIZE)
                                        SMALL_LAMBDA_SIZE)
                                     (pass2/local-call-inliner
                                       lvar
                                       lambda-node
                                       locals))))))
            (pass2/local-call-optimizer lvar lambda-node))))

(define-macro
  (sum-items cnt . items)
  (if (null? items)
      cnt
      (let1 target-list?
            (and (pair? (car items))
                 (eq? (caar items) (quote *)))
            (quasiquote
              (let1 s1
                    ((unquote
                       (if target-list? (quote rec-list) (quote rec)))
                     (unquote
                       (if target-list? (cadar items) (car items)))
                     (unquote cnt))
                    (if (>= s1 limit)
                        limit
                        (sum-items s1 (unquote-splicing (cdr items)))))))))

(define
  (iform-count-size-upto iform limit)
  (define
    (rec iform cnt)
    (let1 t
          (tag iform)
          (cond ((= $DEFINE t)
                 (sum-items (+ cnt 1) ($define.val iform)))
                ((= $LOCAL-REF t) (+ cnt 1))
                ((= $GLOBAL-REF t) (+ cnt 1))
                ((= $CONST t) (+ cnt 1))
                ((= $LOCAL-ASSIGN t)
                 (sum-items (+ cnt 1) ($local-assign.val iform)))
                ((= $GLOBAL-ASSIGN t)
                 (sum-items (+ cnt 1) ($global-assign.val iform)))
                ((= $IF t)
                 (sum-items
                   (+ cnt 1)
                   ($if.test iform)
                   ($if.then iform)
                   ($if.else iform)))
                ((= $LET t)
                 (sum-items
                   (+ cnt 1)
                   (* ($let.inits iform))
                   ($let.body iform)))
                ((= $LAMBDA t)
                 (sum-items (+ cnt 1) ($lambda.body iform)))
                ((= $LABEL t)
                 (sum-items cnt ($label.body iform)))
                ((= $SEQ t)
                 (sum-items cnt (* ($seq.body iform))))
                ((= $CALL t)
                 (sum-items
                   (+ cnt 1)
                   ($call.proc iform)
                   (* ($call.args iform))))
                ((= $ASM t)
                 (sum-items (+ cnt 1) (* ($asm.args iform))))
                (else (error "[internal error] iform-count-size-upto: unknown iform tag:"
                             (tag iform))))))
  (define
    (rec-list iform-list cnt)
    (cond ((null? iform-list) cnt)
          ((>= cnt limit) limit)
          (else (rec-list
                  (cdr iform-list)
                  (rec (car iform-list) cnt)))))
  (rec iform 0))

(define
  (adjust-arglist reqargs optarg iargs name)
  (unless
    (argcount-ok? iargs reqargs (> optarg 0))
    (errorf
      "wrong number of arguments: ~a requires ~a, but got ~a at ~a"
      name
      reqargs
      (length iargs)
      (source-info iargs)))
  (if (zero? optarg)
      iargs
      (receive
        (reqs opts)
        (split-at iargs reqargs)
        (append2 reqs (list ($list opts))))))

(define
  (argcount-ok? args reqargs optarg?)
  (let1 nargs
        (length args)
        (or (and (not optarg?) (= nargs reqargs))
            (and optarg? (>= nargs reqargs)))))

(define
  (pass2/local-call-inliner lvar lambda-node calls)
  (define
    (inline-it call-node lambda-node)
    (let1 inlined
          (pass2/expand-inlined-procedure
            lambda-node
            ($call.args call-node))
          (vector-set! call-node 0 $SEQ)
          (if (tag? inlined $SEQ)
              ($seq.set-body! call-node ($seq.body inlined))
              ($seq.set-body! call-node (list inlined)))))
  ($lvar.set-ref-count! lvar 0)
  ($lambda.set-flag! lambda-node (quote dissolved))
  (let loop
       ((calls calls))
       (cond ((null? (cdr calls))
              (inline-it (car calls) lambda-node))
             (else (inline-it
                     (car calls)
                     (iform-copy lambda-node (quote ())))
                   (loop (cdr calls))))))

(define
  (pass2/local-call-embedder
    lvar
    lambda-node
    call
    rec-calls)
  (let ((reqargs ($lambda.reqargs lambda-node))
        (optarg ($lambda.optarg lambda-node))
        (name ($lambda.name lambda-node)))
       ($call.set-args!
         call
         (adjust-arglist
           reqargs
           optarg
           ($call.args call)
           name))
       ($lvar.ref-count--! lvar)
       ($call.set-type! call (quote embed))
       ($call.set-proc! call lambda-node)
       ($lambda.set-flag! lambda-node (quote dissolved))
       (unless
         (null? rec-calls)
         (let1 body
               ($label #f ($lambda.body lambda-node))
               ($lambda.set-body! lambda-node body)
               (dolist
                 (jcall rec-calls)
                 ($lvar.ref-count--! lvar)
                 ($call.set-args!
                   jcall
                   (adjust-arglist
                     reqargs
                     optarg
                     ($call.args jcall)
                     name))
                 ($call.set-proc! jcall call)
                 ($call.set-type! jcall (quote jump)))))))

(define
  (pass2/local-call-optimizer lvar lambda-node)
  (let ((reqargs ($lambda.reqargs lambda-node))
        (optarg ($lambda.optarg lambda-node))
        (name ($lambda.name lambda-node))
        (calls ($lambda.calls lambda-node)))
       (dolist
         (call calls)
         ($call.set-args!
           (car call)
           (adjust-arglist
             reqargs
             optarg
             ($call.args (car call))
             name))
         ($call.set-type! (car call) (quote local)))
       ($lambda.set-calls! lambda-node (quote ()))))

(define
  (pass2/classify-calls call&envs lambda-node)
  (define
    (direct-call? env)
    (let loop
         ((env env))
         (cond ((null? env) #t)
               ((eq? (car env) lambda-node) #t)
               ((eq? ($lambda.flag (car env)) (quote dissolved))
                (loop (cdr env)))
               (else #f))))
  (let loop
       ((call&envs call&envs)
        (local (quote ()))
        (rec (quote ()))
        (trec (quote ())))
       (match call&envs
              (() (list local rec trec))
              (((call . env) . more)
               (case ($call.type call)
                     ((tail-rec)
                      (if (direct-call? env)
                          (loop more local rec (cons call trec))
                          (loop more local (cons call rec) trec)))
                     ((rec) (loop more local (cons call rec) trec))
                     (else (loop more (cons call local) rec trec)))))))

(define
  (pass2/remove-vars vars init-iforms)
  (let loop
       ((vars vars)
        (init-iforms init-iforms)
        (rl (quote ()))
        (ri (quote ()))
        (rr (quote ())))
       (cond ((null? vars)
              (quasiquote
                #((unquote (reverse rl))
                  (unquote (reverse ri))
                  (unquote (reverse rr)))))
             ((and (= 0 ($lvar.ref-count (car vars)))
                   (zero? ($lvar.set-count (car vars))))
              (cond ((tag? (car init-iforms) $LOCAL-REF)
                     ($lvar.ref-count--!
                       ($local-ref.lvar (car init-iforms)))))
              (loop (cdr vars)
                    (cdr init-iforms)
                    rl
                    ri
                    (if (memq (tag (car init-iforms))
                              (quasiquote
                                ((unquote $CONST)
                                 (unquote $LOCAL-REF)
                                 (unquote $LAMBDA))))
                        rr
                        (cons (car init-iforms) rr))))
             (else (loop (cdr vars)
                         (cdr init-iforms)
                         (cons (car vars) rl)
                         (cons (car init-iforms) ri)
                         rr)))))

(define
  (pass2/self-recursing? closure closures)
  (find10 (lambda (c) (eq? closure c)) closures))

(define
  (pass2/classify-local-ref-call
    iform
    closures
    tail?)
  (let1 lvar
        ($local-ref.lvar iform)
        (if (> ($lvar.set-count lvar) 0) (quote local))
        (let1 init-val
              ($lvar.init-val lvar)
              (cond ((and init-val (tag? init-val $LAMBDA))
                     (cond ((pass2/self-recursing? init-val closures)
                            (if tail? (quote tail-rec) (quote rec)))
                           ((= ($lvar.ref-count lvar) 1)
                            ($lvar.ref-count--! lvar)
                            ($lvar.set-init-val! lvar (quote ()))
                            init-val)
                           (else (quote local))))
                    (else #f)))))

(define
  (pass2/expand-inlined-procedure iform iargs)
  (let ((lvars ($lambda.lvars iform))
        (args (pass2/adjust-arglist
                ($lambda.reqargs iform)
                ($lambda.optarg iform)
                iargs
                ($lambda.name iform))))
       (for-each
         (lambda (lv a) ($lvar.set-init-val! lv a))
         lvars
         args)
       ($let (quote let)
             lvars
             args
             ($lambda.body iform)
             #f
             #f)))

(define
  (pass2/argcount-ok? args reqargs optarg?)
  (let1 nargs
        (length args)
        (or (and (not optarg?) (= nargs reqargs))
            (and optarg? (>= nargs reqargs)))))

(define
  (pass2/adjust-arglist reqargs optarg iargs name)
  (unless
    (pass2/argcount-ok? iargs reqargs (> optarg 0))
    (errorf
      "wrong number of arguments: ~a requires ~a, but got ~a at ~a"
      name
      reqargs
      (length iargs)
      (source-info iargs)))
  (if (zero? optarg)
      iargs
      (let* ((ret-args (pass2/split-args iargs reqargs))
             (reqs (car ret-args))
             (opts (cdr ret-args)))
            (append2 reqs (list ($list opts))))))

(define
  (pass2/split-args args reqargs)
  (let loop
       ((i reqargs) (rest args) (r (quote ())))
       (cond ((= i 0) (cons (reverse r) rest))
             ((null? rest)
              (error "given list is too short:" args))
             (else (loop (- i 1) (cdr rest) (cons (car rest) r))))))

(define
  (pass2/collect-call iform closures)
  (cond (($call.type iform) iform)
        (else (let ((proc ($call.proc iform))
                    (args ($call.args iform)))
                   (cond ((tag? proc $LAMBDA)
                          (pass2/optimize
                            (pass2/expand-inlined-procedure proc args)
                            closures))
                         ((and (tag? proc $LOCAL-REF)
                               (pass2/classify-local-ref-call
                                 proc
                                 closures
                                 ($call.tail? iform)))
                          =>
                          (lambda
                            (type)
                            (cond ((vector? type)
                                   ($call.set-proc! iform type)
                                   (let1 o
                                         (pass2/expand-inlined-procedure
                                           type
                                           args)
                                         (pass2/optimize o closures)
                                         o))
                                  ((not type) iform)
                                  (else (let1 lambda-iform
                                              ($lvar.init-val
                                                ($local-ref.lvar proc))
                                              ($call.set-type! iform type)
                                              ($lambda.set-calls!
                                                lambda-iform
                                                (cons (cons iform closures)
                                                      ($lambda.calls
                                                        lambda-iform)))
                                              ($call.set-args!
                                                iform
                                                ($map1 (lambda
                                                         (x)
                                                         (pass2/optimize
                                                           x
                                                           closures))
                                                       args))
                                              iform)))))
                         (else ($call.set-args!
                                 iform
                                 ($map1 (lambda
                                          (x)
                                          (pass2/optimize x closures))
                                        args))
                               iform))))))

(define
  (pass3/find-free iform locals can-frees)
  (define
    (rec i l labels-seen)
    (let1 t
          (tag i)
          (cond ((= $CONST t) (quote ()))
                ((= $LET t)
                 (append2
                   ($append-map1
                     (lambda (fm) (rec fm l labels-seen))
                     ($let.inits i))
                   (rec ($let.body i)
                        (append2 l ($let.lvars i))
                        labels-seen)))
                ((= $RECEIVE t)
                 (append2
                   (rec ($receive.vals i) l labels-seen)
                   (rec ($receive.body i)
                        (append2 l ($receive.lvars i))
                        labels-seen)))
                ((= $SEQ t)
                 ($append-map1
                   (lambda (fm) (rec fm l labels-seen))
                   ($seq.body i)))
                ((= $LAMBDA t)
                 (rec ($lambda.body i)
                      (append2 l ($lambda.lvars i))
                      labels-seen))
                ((= $LOCAL-ASSIGN t)
                 (let1 lvar
                       ($local-assign.lvar i)
                       (append2
                         (if (memq lvar can-frees) (list lvar) (quote ()))
                         (rec ($local-assign.val i) l labels-seen))))
                ((= $LOCAL-REF t)
                 (let1 lvar
                       ($local-ref.lvar i)
                       (cond ((memq lvar l) (quote ()))
                             ((memq lvar can-frees) (list lvar))
                             (else (quote ())))))
                ((= $GLOBAL-REF t)
                 (let* ((sym ($global-ref.sym i))
                        (found (find10
                                 (lambda (x) (eq? ($lvar.sym x) sym))
                                 can-frees)))
                       (if found (list found) (quote ()))))
                ((= $UNDEF t) (quote ()))
                ((= $IF t)
                 (append2
                   (rec ($if.test i) l labels-seen)
                   (append2
                     (rec ($if.then i) l labels-seen)
                     (rec ($if.else i) l labels-seen))))
                ((= $ASM t)
                 ($append-map1
                   (lambda (fm) (rec fm l labels-seen))
                   ($asm.args i)))
                ((= $DEFINE t)
                 (rec ($define.val i) l labels-seen))
                ((= $CALL t)
                 (append2
                   ($append-map1
                     (lambda (fm) (rec fm l labels-seen))
                     ($call.args i))
                   (rec ($call.proc i) l labels-seen)))
                ((= $CALL-CC t)
                 (rec ($call-cc.proc i) l labels-seen))
                ((= $GLOBAL-ASSIGN t)
                 (rec ($global-assign.val i) l labels-seen))
                ((= $LIST t)
                 ($append-map1
                   (lambda (fm) (rec fm l labels-seen))
                   ($list.args i)))
                ((= $LABEL t)
                 (if (memq i labels-seen)
                     (quote ())
                     (rec ($label.body i) l (cons i labels-seen))))
                ((= $IMPORT t) (quote ()))
                ((= $LIBRARY t) (quote ()))
                ((= $IT t) (quote ()))
                (else (error "pass3/find-free unknown iform:" (tag i))))))
  (uniq (rec iform locals (quote ()))))

(define
  (pass3/find-sets iform lvars)
  (define
    (rec i)
    (let1 t
          (tag i)
          (cond ((= $CONST t) (quote ()))
                ((= $LET t)
                 (append
                   ($append-map1 rec ($let.inits i))
                   (rec ($let.body i))))
                ((= $RECEIVE t)
                 (append
                   (rec ($receive.vals i))
                   (rec ($receive.body i))))
                ((= $SEQ t) ($append-map1 rec ($seq.body i)))
                ((= $LAMBDA t) (rec ($lambda.body i)))
                ((= $LOCAL-ASSIGN t)
                 (let1 lvar
                       ($local-assign.lvar i)
                       (append
                         (if (memq lvar lvars) (list lvar) (quote ()))
                         (rec ($local-assign.val i)))))
                ((= $LOCAL-REF t) (quote ()))
                ((= $GLOBAL-REF t) (quote ()))
                ((= $UNDEF t) (quote ()))
                ((= $IF t)
                 (append
                   (rec ($if.test i))
                   (rec ($if.then i))
                   (rec ($if.else i))))
                ((= $ASM t) ($append-map1 rec ($asm.args i)))
                ((= $DEFINE t) (rec ($define.val i)))
                ((= $CALL t)
                 (append
                   ($append-map1 rec ($call.args i))
                   (rec ($call.proc i))))
                ((= $CALL-CC t) (rec ($call-cc.proc i)))
                ((= $GLOBAL-ASSIGN t)
                 (rec ($global-assign.val i)))
                ((= $LIST t) ($append-map1 rec ($list.args i)))
                ((= $LABEL t) (quote ()))
                ((= $IMPORT t) (quote ()))
                ((= $LIBRARY t) (quote ()))
                ((= $IT t) (quote ()))
                (else (error "pass3/find-sets unknown iform:" i)))))
  (uniq (rec iform)))

(define
  (make-code-builder)
  (list (quote builder)))

(define
  (code-builder-put1! cb x)
  (append! cb (list x)))

(define
  (code-builder-put2! cb a b)
  (append! cb (list a b)))

(define
  (code-builder-put3! cb a b c)
  (append! cb (list a b c)))

(define
  (code-builder-put4! cb a b c d)
  (append! cb (list a b c d)))

(define
  (code-builder-put5! cb a b c d e)
  (append! cb (list a b c d e)))

(define
  (code-builder-append! cb1 cb2)
  (let loop
       ((e (cdr cb2)))
       (cond ((null? e) (quote ()))
             (else (code-builder-put1! cb1 (car e))
                   (loop (cdr e))))))

(define (code-builder-emit cb) (cdr cb))

(define-macro
  (cput! cb . more)
  (match more
         (() (quote ()))
         ((a b c d e . f)
          (quasiquote
            (begin (code-builder-put5!
                     (unquote cb)
                     (unquote a)
                     (unquote b)
                     (unquote c)
                     (unquote d)
                     (unquote e))
                   (cput! (unquote cb) (unquote-splicing f)))))
         ((a b c d . e)
          (quasiquote
            (begin (code-builder-put4!
                     (unquote cb)
                     (unquote a)
                     (unquote b)
                     (unquote c)
                     (unquote d))
                   (cput! (unquote cb) (unquote-splicing e)))))
         ((a b c . d)
          (quasiquote
            (begin (code-builder-put3!
                     (unquote cb)
                     (unquote a)
                     (unquote b)
                     (unquote c))
                   (cput! (unquote cb) (unquote-splicing d)))))
         ((a b . c)
          (quasiquote
            (begin (code-builder-put2!
                     (unquote cb)
                     (unquote a)
                     (unquote b))
                   (cput! (unquote cb) (unquote-splicing c)))))
         ((a . b)
          (quasiquote
            (begin (code-builder-put1! (unquote cb) (unquote a))
                   (cput! (unquote cb) (unquote-splicing b)))))))

(define
  (pass3/collect-free cb frees-here locals frees)
  (fold (lambda
          (i accum)
          (let1 size
                (pass3/compile-refer cb i locals frees)
                (cput! cb (quote PUSH))
                (+ size accum)))
        0
        (reverse frees-here)))

(define
  (pass3/symbol-lookup
    lvar
    locals
    frees
    return-local
    return-free)
  (let next-local
       ((locals locals) (n 0))
       (if (null? locals)
           (let next-free
                ((free frees) (n 0))
                (cond ((null? free)
                       (error "pass3/symbol-lookup bug? Unknown lvar:"
                              lvar))
                      ((eq? (car free) lvar) (return-free n))
                      (else (next-free (cdr free) (+ n 1)))))
           (if (eq? (car locals) lvar)
               (return-local n)
               (next-local (cdr locals) (+ n 1))))))

(define
  (pass3/compile-refer cb lvar locals frees)
  (pass3/symbol-lookup
    lvar
    locals
    frees
    (lambda (n) (cput! cb (quote REFER_LOCAL) n) 0)
    (lambda (n) (cput! cb (quote REFER_FREE) n) 0)))

(define
  (pass3/compile-assign cb lvar locals frees)
  (pass3/symbol-lookup
    lvar
    locals
    frees
    (lambda (n) (cput! cb (quote ASSIGN_LOCAL) n) 0)
    (lambda (n) (cput! cb (quote ASSIGN_FREE) n) 0)))

(define
  (pass3/make-boxes cb sets vars)
  ($for-each1-with-rindex
    (lambda
      (index var)
      (if (memq var sets) (cput! cb (quote BOX) index)))
    vars))

(define
  pass3/dispatch-table
  (make-vector $INSN-NUM))

(define
  (pass3/register insn proc)
  (vector-set! pass3/dispatch-table insn proc))

(define
  (pass3/$const
    cb
    iform
    locals
    frees
    can-frees
    sets
    tail)
  (cput! cb (quote CONSTANT) ($const.val iform))
  0)

(define
  (pass3/$it
    cb
    iform
    locals
    frees
    can-frees
    sets
    tail)
  0)

(define
  (pass3/$list
    cb
    iform
    locals
    frees
    can-frees
    sets
    tail)
  (let1 args
        ($list.args iform)
        (begin0
          (fold (lambda
                  (i accum)
                  (let1 size
                        (pass3/rec cb i locals frees can-frees sets tail)
                        (cput! cb (quote PUSH))
                        (+ size accum)))
                0
                args)
          (cput! cb (quote LIST) (length args)))))

(define
  (pass3/$local-ref
    cb
    iform
    locals
    frees
    can-frees
    sets
    tail)
  (pass3/compile-refer
    cb
    ($local-ref.lvar iform)
    locals
    frees)
  (when (memq ($local-ref.lvar iform) sets)
        (cput! cb (quote INDIRECT)))
  0)

(define
  (pass3/$local-assign
    cb
    iform
    locals
    frees
    can-frees
    sets
    tail)
  (let ((val-stack-size
          (pass3/rec
            cb
            ($local-assign.val iform)
            locals
            frees
            can-frees
            sets
            #f))
        (var-stack-size
          (pass3/compile-assign
            cb
            ($local-ref.lvar iform)
            locals
            frees)))
       (+ val-stack-size var-stack-size)))

(define
  top-level-sym
  (string->symbol "top level "))

(define
  (merge-libname-sym libname sym)
  (string->symbol
    (string-append
      (symbol->string libname)
      ":$:"
      (symbol->string sym))))

(define
  (pass3/$global-ref
    cb
    iform
    locals
    frees
    can-frees
    sets
    tail)
  (let1 sym
        ($global-ref.sym iform)
        (let next-free
             ((free frees) (n 0))
             (cond ((null? free)
                    (cput! cb
                           (quote REFER_GLOBAL)
                           (merge-libname-sym
                             ($global-ref.libname iform)
                             sym))
                    0)
                   ((eq? ($lvar.sym (car free)) sym)
                    (cput! cb (quote REFER_FREE) n)
                    0)
                   (else (next-free (cdr free) (+ n 1)))))))

(define
  (pass3/$global-assign
    cb
    iform
    locals
    frees
    can-frees
    sets
    tail)
  (let1 sym
        ($global-assign.sym iform)
        (let next-free
             ((free frees) (n 0))
             (cond ((null? free)
                    (begin0
                      (pass3/rec
                        cb
                        ($global-assign.val iform)
                        locals
                        frees
                        can-frees
                        sets
                        #f)
                      (cput! cb
                             (quote ASSIGN_GLOBAL)
                             (merge-libname-sym
                               ($global-assign.libname iform)
                               sym))))
                   ((eq? ($lvar.sym (car free)) sym)
                    (begin0
                      (pass3/rec
                        cb
                        ($global-assign.val iform)
                        locals
                        frees
                        can-frees
                        sets
                        #f)
                      (cput! cb (quote ASSIGN_FREE) n)))
                   (else (next-free (cdr free) (+ n 1)))))))

(define
  (pass3/$seq
    cb
    iform
    locals
    frees
    can-frees
    sets
    tail)
  (let loop
       ((form ($seq.body iform)) (size 0))
       (cond ((null? form) size)
             (else (let1 tail?
                         (if (null? (cdr form)) tail #f)
                         (loop (cdr form)
                               (+ size
                                  (pass3/rec
                                    cb
                                    (car form)
                                    locals
                                    frees
                                    can-frees
                                    sets
                                    tail?))))))))

(define
  (pass3/$undef
    cb
    iform
    locals
    frees
    can-frees
    sets
    tail)
  (cput! cb (quote UNDEF))
  0)

(define
  (pass3/$asm
    cb
    iform
    locals
    frees
    can-frees
    sets
    tail)
  (define
    (compile-1arg insn args)
    (begin0
      (pass3/rec
        cb
        (first args)
        locals
        frees
        can-frees
        sets
        #f)
      (cput! cb insn)))
  (define
    (compile-2arg insn args)
    (let ((x (pass3/compile-arg
               cb
               (first args)
               locals
               frees
               can-frees
               sets
               #f))
          (y (pass3/rec
               cb
               (second args)
               locals
               frees
               can-frees
               sets
               #f)))
         (cput! cb insn)
         (+ x y)))
  (define
    (compile-3arg insn args)
    (let ((x (pass3/compile-arg
               cb
               (first args)
               locals
               frees
               can-frees
               sets
               #f))
          (y (pass3/compile-arg
               cb
               (second args)
               locals
               frees
               can-frees
               sets
               #f))
          (z (pass3/rec
               cb
               (third args)
               locals
               frees
               can-frees
               sets
               #f)))
         (cput! cb insn)
         (+ x y z)))
  (define
    (compile-n-args args)
    (let loop
         ((args args) (stack-size 0))
         (cond ((null? args) stack-size)
               ((null? (cdr args))
                (+ stack-size
                   (pass3/rec
                     cb
                     (car args)
                     locals
                     frees
                     can-frees
                     sets
                     #f)))
               (else (loop (cdr args)
                           (+ stack-size
                              (pass3/compile-arg
                                cb
                                (car args)
                                locals
                                frees
                                can-frees
                                sets
                                #f)))))))
  (let1 args
        ($asm.args iform)
        (case ($asm.insn iform)
              ((NUMBER_ADD)
               (compile-2arg (quote NUMBER_ADD) args))
              ((NUMBER_SUB)
               (compile-2arg (quote NUMBER_SUB) args))
              ((NUMBER_MUL)
               (compile-2arg (quote NUMBER_MUL) args))
              ((NUMBER_DIV)
               (compile-2arg (quote NUMBER_DIV) args))
              ((NUMBER_EQUAL)
               (compile-2arg (quote NUMBER_EQUAL) args))
              ((NUMBER_GE)
               (compile-2arg (quote NUMBER_GE) args))
              ((NUMBER_GT)
               (compile-2arg (quote NUMBER_GT) args))
              ((NUMBER_LT)
               (compile-2arg (quote NUMBER_LT) args))
              ((NUMBER_LE)
               (compile-2arg (quote NUMBER_LE) args))
              ((CONS) (compile-2arg (quote CONS) args))
              ((CAR) (compile-1arg (quote CAR) args))
              ((CDR) (compile-1arg (quote CDR) args))
              ((CAAR) (compile-1arg (quote CAAR) args))
              ((CADR) (compile-1arg (quote CADR) args))
              ((CDAR) (compile-1arg (quote CDAR) args))
              ((CDDR) (compile-1arg (quote CDDR) args))
              ((SET_CDR) (compile-2arg (quote SET_CDR) args))
              ((SET_CAR) (compile-2arg (quote SET_CAR) args))
              ((MAKE_VECTOR)
               (compile-2arg (quote MAKE_VECTOR) args))
              ((VECTOR_LENGTH)
               (compile-1arg (quote VECTOR_LENGTH) args))
              ((VECTOR_SET)
               (compile-3arg (quote VECTOR_SET) args))
              ((VECTOR_REF)
               (compile-2arg (quote VECTOR_REF) args))
              ((EQ) (compile-2arg (quote EQ) args))
              ((EQV) (compile-2arg (quote EQV) args))
              ((EQUAL) (compile-2arg (quote EQUAL) args))
              ((PAIR_P) (compile-1arg (quote PAIR_P) args))
              ((NULL_P) (compile-1arg (quote NULL_P) args))
              ((SYMBOL_P) (compile-1arg (quote SYMBOL_P) args))
              ((VECTOR_P) (compile-1arg (quote VECTOR_P) args))
              ((NOT) (compile-1arg (quote NOT) args))
              ((OPEN_INPUT_FILE)
               (compile-1arg (quote OPEN_INPUT_FILE) args))
              ((READ) (compile-1arg (quote READ) args))
              ((READ_CHAR)
               (compile-1arg (quote READ_CHAR) args))
              ((VALUES)
               (begin0
                 (compile-n-args args)
                 (cput! cb (quote VALUES) (length args))))
              ((APPLY)
               (let1 end-of-frame
                     (make-label)
                     (cput! cb (quote FRAME) (ref-label end-of-frame))
                     (let1 arg2-size
                           (pass3/rec
                             cb
                             (second args)
                             locals
                             frees
                             can-frees
                             sets
                             #f)
                           (cput! cb (quote PUSH))
                           (let1 arg1-size
                                 (pass3/rec
                                   cb
                                   (first args)
                                   locals
                                   frees
                                   can-frees
                                   sets
                                   #f)
                                 (cput! cb (quote APPLY) end-of-frame)
                                 (+ arg1-size arg2-size)))))
              (else (print "unknown insn on pass3/$asm")))))

(define
  (pass3/$if
    cb
    iform
    locals
    frees
    can-frees
    sets
    tail)
  (let ((end-of-else (make-label))
        (begin-of-else (make-label)))
       (let1 test-size
             (pass3/rec
               cb
               ($if.test iform)
               locals
               frees
               can-frees
               sets
               #f)
             (cput! cb (quote TEST) (ref-label begin-of-else))
             (let1 then-size
                   (pass3/rec
                     cb
                     ($if.then iform)
                     locals
                     frees
                     can-frees
                     sets
                     tail)
                   (cput! cb
                          (quote UNFIXED_JUMP)
                          (ref-label end-of-else)
                          begin-of-else)
                   (let1 else-size
                         (pass3/rec
                           cb
                           ($if.else iform)
                           locals
                           frees
                           can-frees
                           sets
                           tail)
                         (cput! cb end-of-else)
                         (+ test-size then-size else-size))))))

(define
  (pass3/$define
    cb
    iform
    locals
    frees
    can-frees
    sets
    tail)
  (begin0
    (pass3/rec
      cb
      ($define.val iform)
      locals
      frees
      can-frees
      sets
      #f)
    (cput! cb
           (quote DEFINE_GLOBAL)
           (merge-libname-sym
             ($define.libname iform)
             ($define.sym iform)))))

(define
  (pass3/compile-arg
    cb
    arg
    locals
    frees
    can-frees
    sets
    tail)
  (let1 size
        (pass3/rec cb arg locals frees can-frees sets #f)
        (cput! cb (quote PUSH))
        (+ size 1)))

(define
  (pass3/compile-args
    cb
    args
    locals
    frees
    can-frees
    sets
    tail)
  (fold (lambda
          (i accum)
          (let1 size
                (pass3/compile-arg
                  cb
                  i
                  locals
                  frees
                  can-frees
                  sets
                  tail)
                (+ size accum)))
        0
        args))

(define
  (pass3/$call
    cb
    iform
    locals
    frees
    can-frees
    sets
    tail)
  (case ($call.type iform)
        ((jump)
         (let1 label
               ($lambda.body ($call.proc ($call.proc iform)))
               (cput! cb
                      (quote REDUCE)
                      (length ($call.args iform)))
               (begin0
                 (pass3/compile-args
                   cb
                   ($call.args iform)
                   locals
                   frees
                   can-frees
                   sets
                   #f)
                 (cput! cb
                        (quote SHIFT)
                        (length ($call.args iform))
                        (length ($call.args iform))
                        (quote UNFIXED_JUMP)
                        label))))
        ((embed)
         (let* ((label ($lambda.body ($call.proc iform)))
                (body ($label.body label))
                (vars ($lambda.lvars ($call.proc iform)))
                (frees-here
                  (pass3/find-free
                    body
                    vars
                    (append2 locals (append2 frees can-frees))))
                (sets-here
                  (append2 (pass3/find-sets body vars) sets)))
               (cput! cb (quote LET_FRAME))
               (let1 free-size
                     (if (> (length frees-here) 0)
                         (pass3/collect-free cb frees-here locals frees)
                         0)
                     (when (> (length frees-here) 0)
                           (cput! cb (quote DISPLAY) (length frees-here)))
                     (let1 args-size
                           (pass3/compile-args
                             cb
                             ($call.args iform)
                             locals
                             frees-here
                             can-frees
                             sets
                             #f)
                           (pass3/make-boxes cb sets-here vars)
                           (cput! cb
                                  (quote ENTER)
                                  (length ($call.args iform))
                                  label)
                           (let1 body-size
                                 (pass3/rec
                                   cb
                                   body
                                   vars
                                   frees-here
                                   (%set-union can-frees vars)
                                   (%set-union
                                     sets-here
                                     (%set-intersect sets frees-here))
                                   (if tail (+ tail (length vars) 2) #f))
                                 (cput! cb
                                        (quote LEAVE)
                                        (length ($call.args iform)))
                                 (+ args-size body-size free-size))))))
        (else (let1 end-of-frame
                    (make-label)
                    (unless
                      tail
                      (cput! cb (quote FRAME) (ref-label end-of-frame)))
                    (let* ((args-size
                             (pass3/compile-args
                               cb
                               ($call.args iform)
                               locals
                               frees
                               can-frees
                               sets
                               #f))
                           (proc-size
                             (pass3/rec
                               cb
                               ($call.proc iform)
                               locals
                               frees
                               can-frees
                               sets
                               #f)))
                          (when tail
                                (cput! cb
                                       (quote SHIFT)
                                       (length ($call.args iform))
                                       tail))
                          (cput! cb
                                 (quote CALL)
                                 (length ($call.args iform)))
                          (unless tail (cput! cb end-of-frame))
                          (+ args-size proc-size))))))

(define
  (pass3/$call-cc
    cb
    iform
    locals
    frees
    can-frees
    sets
    tail)
  (let1 end-of-frame
        (make-label)
        (unless
          tail
          (cput! cb (quote FRAME) (ref-label end-of-frame)))
        (cput! cb
               (quote MAKE_CONTINUATION)
               (if tail 1 0)
               (quote PUSH))
        (begin0
          (pass3/rec
            cb
            ($call-cc.proc iform)
            locals
            frees
            can-frees
            sets
            #f)
          (when tail (cput! cb (quote SHIFT) 1 tail))
          (cput! cb (quote CALL) 1)
          (unless tail (cput! cb end-of-frame)))))

(define
  (pass3/$lambda
    cb
    iform
    locals
    frees
    can-frees
    sets
    tail)
  (let* ((vars ($lambda.lvars iform))
         (body ($lambda.body iform))
         (frees-here
           (pass3/find-free
             body
             vars
             (append2 locals (append2 frees can-frees))))
         (sets-here
           (append2 (pass3/find-sets body vars) sets))
         (end-of-closure (make-label))
         (lambda-cb (make-code-builder)))
        (let1 free-size
              (if (> (length frees-here) 0)
                  (pass3/collect-free cb frees-here locals frees)
                  0)
              (cput! cb
                     (quote CLOSURE)
                     (ref-label end-of-closure)
                     (length vars)
                     (> ($lambda.optarg iform) 0)
                     (length frees-here))
              (let1 body-size
                    (pass3/rec
                      lambda-cb
                      body
                      vars
                      frees-here
                      (%set-union can-frees vars)
                      (%set-union
                        sets-here
                        (%set-intersect sets frees-here))
                      (length vars))
                    (cput! cb
                           (+ body-size free-size (length vars) 4)
                           ($lambda.src iform))
                    (pass3/make-boxes cb sets-here vars)
                    (code-builder-append! cb lambda-cb)
                    (cput! cb
                           (quote RETURN)
                           (length vars)
                           end-of-closure)
                    0))))

(define
  (pass3/$receive
    cb
    iform
    locals
    frees
    can-frees
    sets
    tail)
  (let* ((vars ($receive.lvars iform))
         (body ($receive.body iform))
         (frees-here
           (append2
             (pass3/find-free
               ($receive.vals iform)
               locals
               (append2 locals (append2 frees can-frees)))
             (pass3/find-free
               body
               vars
               (append2 locals (append2 frees can-frees)))))
         (sets-here
           (append2 (pass3/find-sets body vars) sets)))
        (cput! cb (quote LET_FRAME))
        (let1 free-size
              (if (> (length frees-here) 0)
                  (pass3/collect-free cb frees-here locals frees)
                  0)
              (when (> (length frees-here) 0)
                    (cput! cb (quote DISPLAY) (length frees-here)))
              (let1 vals-size
                    (pass3/rec
                      cb
                      ($receive.vals iform)
                      locals
                      frees-here
                      can-frees
                      sets
                      #f)
                    (cput! cb
                           (quote RECEIVE)
                           ($receive.reqargs iform)
                           ($receive.optarg iform))
                    (pass3/make-boxes cb sets-here vars)
                    (cput! cb (quote ENTER) (length vars))
                    (let1 body-size
                          (pass3/rec
                            cb
                            body
                            vars
                            frees-here
                            (%set-union can-frees vars)
                            (%set-union
                              sets-here
                              (%set-intersect sets frees-here))
                            (if tail (+ tail (length vars) 2) #f))
                          (cput! cb (quote LEAVE) (length vars))
                          (+ body-size vals-size free-size))))))

(define
  (pass3/$let
    cb
    iform
    locals
    frees
    can-frees
    sets
    tail)
  (if (eq? ($let.type iform) (quote rec))
      (pass3/letrec
        cb
        iform
        locals
        frees
        can-frees
        sets
        tail)
      (let* ((vars ($let.lvars iform))
             (body ($let.body iform))
             (frees-here
               (append2
                 ($append-map1
                   (lambda
                     (i)
                     (pass3/find-free
                       i
                       locals
                       (append2 locals (append2 frees can-frees))))
                   ($let.inits iform))
                 (pass3/find-free
                   body
                   vars
                   (append2 locals (append2 frees can-frees)))))
             (sets-here
               (append2 (pass3/find-sets body vars) sets)))
            (cput! cb (quote LET_FRAME))
            (let1 free-size
                  (if (> (length frees-here) 0)
                      (pass3/collect-free cb frees-here locals frees)
                      0)
                  (when (> (length frees-here) 0)
                        (cput! cb (quote DISPLAY) (length frees-here)))
                  (let1 args-size
                        (pass3/compile-args
                          cb
                          ($let.inits iform)
                          locals
                          frees-here
                          can-frees
                          sets
                          tail)
                        (pass3/make-boxes cb sets-here vars)
                        (cput! cb (quote ENTER) (length vars))
                        (let1 body-size
                              (pass3/rec
                                cb
                                body
                                vars
                                frees-here
                                (%set-union can-frees vars)
                                (%set-union
                                  sets-here
                                  (%set-intersect sets frees-here))
                                (if tail (+ tail (length vars) 2) #f))
                              (cput! cb (quote LEAVE) (length vars))
                              (+ body-size args-size free-size)))))))

(define
  (pass3/letrec
    cb
    iform
    locals
    frees
    can-frees
    sets
    tail)
  (let* ((vars ($let.lvars iform))
         (body ($let.body iform))
         (frees-here
           (append2
             ($append-map1
               (lambda
                 (i)
                 (pass3/find-free
                   i
                   vars
                   (append2 locals (append2 frees can-frees))))
               ($let.inits iform))
             (pass3/find-free
               body
               vars
               (append2 locals (append2 frees can-frees)))))
         (sets-here
           (append
             vars
             (pass3/find-sets body vars)
             ($append-map1
               (lambda (i) (pass3/find-sets i vars))
               ($let.inits iform))
             sets))
         (args ($let.inits iform)))
        (cput! cb (quote LET_FRAME))
        (let1 free-size
              (if (> (length frees-here) 0)
                  (pass3/collect-free cb frees-here locals frees)
                  0)
              (when (> (length frees-here) 0)
                    (cput! cb (quote DISPLAY) (length frees-here)))
              (let loop
                   ((args args))
                   (cond ((null? args) (quote ()))
                         (else (cput! cb (quote UNDEF) (quote PUSH))
                               (loop (cdr args)))))
              (pass3/make-boxes cb sets-here vars)
              (cput! cb (quote ENTER) (length vars))
              (let1 assign-size
                    (let loop
                         ((args args) (size 0) (index 0))
                         (cond ((null? args) size)
                               (else (let1 stack-size
                                           (pass3/rec
                                             cb
                                             (car args)
                                             vars
                                             frees-here
                                             (%set-union can-frees vars)
                                             (%set-union
                                               sets-here
                                               (%set-intersect
                                                 sets
                                                 frees-here))
                                             #f)
                                           (cput! cb
                                                  (quote ASSIGN_LOCAL)
                                                  index)
                                           (loop (cdr args)
                                                 (+ stack-size size)
                                                 (+ index 1))))))
                    (let1 body-size
                          (pass3/rec
                            cb
                            body
                            vars
                            frees-here
                            (%set-union can-frees vars)
                            (%set-union
                              sets-here
                              (%set-intersect sets frees-here))
                            (if tail (+ tail (length vars) 2) #f))
                          (cput! cb (quote LEAVE) (length vars))
                          (+ free-size assign-size body-size))))))

(define
  (pass3/$import
    cb
    iform
    locals
    frees
    can-frees
    sets
    tail)
  (define
    (rec form)
    (for-each
      (lambda
        (s)
        (let* ((libname ($import-spec.libname s))
               (lib (hashtable-ref libraries libname))
               (end-of-frame (make-label)))
              (rec ($library.import lib))
              (cput! cb
                     (quote FRAME)
                     (ref-label end-of-frame)
                     (quote IMPORT)
                     libname
                     end-of-frame)))
      ($import.import-specs form))
    0)
  (rec iform))

(define
  (pass3/$library
    cb
    iform
    locals
    frees
    can-frees
    sets
    tail)
  (cput! cb
         (quote LIBRARY)
         ($library.name iform)
         iform)
  0)

(pass3/register $CONST pass3/$const)

(pass3/register $LAMBDA pass3/$lambda)

(pass3/register $LOCAL-REF pass3/$local-ref)

(pass3/register
  $LOCAL-ASSIGN
  pass3/$local-assign)

(pass3/register
  $GLOBAL-ASSIGN
  pass3/$global-assign)

(pass3/register $GLOBAL-REF pass3/$global-ref)

(pass3/register $SEQ pass3/$seq)

(pass3/register $UNDEF pass3/$undef)

(pass3/register $IF pass3/$if)

(pass3/register $ASM pass3/$asm)

(pass3/register $DEFINE pass3/$define)

(pass3/register $CALL pass3/$call)

(pass3/register $CALL-CC pass3/$call-cc)

(pass3/register $LET pass3/$let)

(pass3/register $LIST pass3/$list)

(pass3/register $LIBRARY pass3/$library)

(pass3/register $IMPORT pass3/$import)

(pass3/register $IT pass3/$it)

(pass3/register $RECEIVE pass3/$receive)

(define
  (pass3/rec
    cb
    iform
    locals
    frees
    can-frees
    sets
    tail)
  ((vector-ref
     pass3/dispatch-table
     (vector-ref iform 0))
   cb
   iform
   locals
   frees
   can-frees
   sets
   tail))

(define
  (pass3 iform locals frees can-frees sets tail)
  (let1 cb
        (make-code-builder)
        (pass3/rec
          cb
          iform
          locals
          frees
          can-frees
          sets
          tail)
        (code-builder-emit cb)))

(define
  (pass4 lst)
  (pass4/fixup-labels
    (list->vector (append2 lst (quote (HALT))))))

(define
  (compile-library-body! lib)
  (let1 body
        ($append-map1
          (lambda
            (sexp)
            (pass3 (pass2/optimize
                     (pass1/sexp->iform
                       (pass1/expand sexp)
                       lib
                       (quote ())
                       #f)
                     (quote ()))
                   (quote ())
                   *free-lvars*
                   (quote ())
                   (quote ())
                   #f))
          ($library.body lib))
        ($library.set-compiled-body!
          lib
          (pass4 (quasiquote ((unquote-splicing body) RETURN 0))))))

(define
  (compile-partial sexp . lib)
  (let1 ss
        (pass1/expand sexp)
        (vector->list
          (pass4/fixup-labels
            (list->vector
              (merge-insn
                (pass3 (pass2/optimize
                         (pass1/sexp->iform
                           ss
                           (if (null? lib) top-level-library (car lib))
                           (quote ())
                           #f)
                         (quote ()))
                       (quote ())
                       *free-lvars*
                       (quote ())
                       (quote ())
                       #f)))))))

(define-macro
  (pass4/fixup-labels-clollect insn)
  (quasiquote
    (begin (vector-set! ret j (unquote insn))
           (vector-set! ret (+ j 1) (vector-ref v (+ i 1)))
           (loop (+ i 2) (+ j 2)))))

(define-macro
  (pass4/fixup-labels-insn insn)
  (quasiquote
    (let1 label
          (hashtable-ref
            labels
            (vector-ref code (+ i 1))
            #f)
          (cond (label (vector-set! code i (unquote insn))
                       (vector-set! code (+ i 1) (- label i 1))
                       (loop (+ i 2)))
                (else (loop (+ i 1)))))))

(define
  (pass4/fixup-labels v)
  (define
    (collect-labels)
    (let* ((len (vector-length v))
           (ret (make-vector len (quote NOP)))
           (labels (make-eq-hashtable)))
          (let loop
               ((i 0) (j 0))
               (cond ((= i len) (values ret labels))
                     (else (let1 insn
                                 (vector-ref v i)
                                 (cond ((eq? insn (quote UNFIXED_JUMP))
                                        (pass4/fixup-labels-clollect
                                          (quote UNFIXED_JUMP)))
                                       ((eq? insn (quote TEST))
                                        (pass4/fixup-labels-clollect
                                          (quote TEST)))
                                       ((eq? insn (quote NUMBER_LE_TEST))
                                        (pass4/fixup-labels-clollect
                                          (quote NUMBER_LE_TEST)))
                                       ((eq? insn (quote NOT_TEST))
                                        (pass4/fixup-labels-clollect
                                          (quote NOT_TEST)))
                                       ((eq? insn
                                             (quote REFER_LOCAL0_EQV_TEST))
                                        (pass4/fixup-labels-clollect
                                          (quote REFER_LOCAL0_EQV_TEST)))
                                       ((eq? insn (quote FRAME))
                                        (pass4/fixup-labels-clollect
                                          (quote FRAME)))
                                       ((eq? insn (quote PUSH_FRAME))
                                        (pass4/fixup-labels-clollect
                                          (quote PUSH_FRAME)))
                                       ((eq? insn (quote CLOSURE))
                                        (pass4/fixup-labels-clollect
                                          (quote CLOSURE)))
                                       ((and (vector? insn)
                                             (> (vector-length insn) 0)
                                             (tag? insn $LABEL))
                                        (hashtable-set! labels insn j)
                                        (loop (+ i 1) j))
                                       (else (vector-set! ret j insn)
                                             (loop (+ i 1) (+ j 1))))))))))
  (receive
    (code labels)
    (collect-labels)
    (let1 len
          (vector-length code)
          (let loop
               ((i 0))
               (cond ((= i len) code)
                     (else (let1 insn
                                 (vector-ref code i)
                                 (cond ((eq? insn (quote UNFIXED_JUMP))
                                        (pass4/fixup-labels-insn
                                          (quote LOCAL_JMP)))
                                       ((eq? insn (quote CLOSURE))
                                        (pass4/fixup-labels-insn
                                          (quote CLOSURE)))
                                       ((eq? insn (quote TEST))
                                        (pass4/fixup-labels-insn (quote TEST)))
                                       ((eq? insn (quote NUMBER_LE_TEST))
                                        (pass4/fixup-labels-insn
                                          (quote NUMBER_LE_TEST)))
                                       ((eq? insn (quote NOT_TEST))
                                        (pass4/fixup-labels-insn
                                          (quote NOT_TEST)))
                                       ((eq? insn
                                             (quote REFER_LOCAL0_EQV_TEST))
                                        (pass4/fixup-labels-insn
                                          (quote REFER_LOCAL0_EQV_TEST)))
                                       ((eq? insn (quote FRAME))
                                        (pass4/fixup-labels-insn
                                          (quote FRAME)))
                                       ((eq? insn (quote PUSH_FRAME))
                                        (pass4/fixup-labels-insn
                                          (quote PUSH_FRAME)))
                                       (else (loop (+ i 1)))))))))))

(define
  *free-lvars*
  ($map1 (lambda (p) ($lvar p (quote ()) 0 0))
         *free-vars-decl*))

(define
  (merge-insn sexp)
  (define
    (iter s)
    (cond ((null? s) (quote ()))
          (else (match s
                       (((quote REFER_LOCAL0_PUSH)
                         (quote CONSTANT)
                         .
                         rest)
                        (iter (quasiquote
                                (REFER_LOCAL0_PUSH_CONSTANT
                                  (unquote-splicing rest)))))
                       (((quote REFER_LOCAL1_PUSH)
                         (quote CONSTANT)
                         .
                         rest)
                        (iter (quasiquote
                                (REFER_LOCAL1_PUSH_CONSTANT
                                  (unquote-splicing rest)))))
                       (((quote REFER_LOCAL) 1 (quote PUSH) . rest)
                        (iter (quasiquote
                                (REFER_LOCAL1_PUSH (unquote-splicing rest)))))
                       (((quote REFER_LOCAL) 0 (quote PUSH) . rest)
                        (iter (quasiquote
                                (REFER_LOCAL0_PUSH (unquote-splicing rest)))))
                       (((quote REFER_LOCAL) 0 . rest)
                        (iter (quasiquote
                                (REFER_LOCAL0 (unquote-splicing rest)))))
                       (((and x (not (quote CONSTANT)))
                         (quote NUMBER_SUB)
                         (quote PUSH)
                         .
                         rest)
                        (iter (quasiquote
                                ((unquote x)
                                 NUMBER_SUB_PUSH
                                 (unquote-splicing rest)))))
                       (((quote PUSH) (quote ENTER) . rest)
                        (iter (cons (quote PUSH_ENTER) rest)))
                       (((quote CONSTANT) v (quote PUSH) . rest)
                        (iter (quasiquote
                                (CONSTANT_PUSH
                                  (unquote v)
                                  (unquote-splicing rest)))))
                       (((quote REFER_FREE) 0 (quote PUSH) . rest)
                        (iter (quasiquote
                                (REFER_FREE0_PUSH (unquote-splicing rest)))))
                       (((quote REFER_FREE) 1 (quote PUSH) . rest)
                        (iter (quasiquote
                                (REFER_FREE1_PUSH (unquote-splicing rest)))))
                       (((quote REFER_FREE) 2 (quote PUSH) . rest)
                        (iter (quasiquote
                                (REFER_FREE2_PUSH (unquote-splicing rest)))))
                       (((quote REFER_FREE) n (quote PUSH) . rest)
                        (iter (quasiquote
                                (REFER_FREE_PUSH
                                  (unquote n)
                                  (unquote-splicing rest)))))
                       (((quote REFER_FREE) 0 . rest)
                        (iter (quasiquote
                                (REFER_FREE0 (unquote-splicing rest)))))
                       (((quote REFER_FREE) 1 . rest)
                        (iter (quasiquote
                                (REFER_FREE1 (unquote-splicing rest)))))
                       (((quote REFER_FREE) 2 . rest)
                        (iter (quasiquote
                                (REFER_FREE2 (unquote-splicing rest)))))
                       (((quote REFER_LOCAL) 1 . rest)
                        (iter (quasiquote
                                (REFER_LOCAL1 (unquote-splicing rest)))))
                       (((quote REFER_LOCAL) 2 . rest)
                        (iter (quasiquote
                                (REFER_LOCAL2 (unquote-splicing rest)))))
                       (((quote LEAVE) 1 . rest)
                        (iter (quasiquote (LEAVE1 (unquote-splicing rest)))))
                       (((quote NUMBER_LE) (quote TEST) . rest)
                        (iter (quasiquote
                                (NUMBER_LE_TEST (unquote-splicing rest)))))
                       (((quote NUMBER_ADD) (quote PUSH) . rest)
                        (iter (quasiquote
                                (NUMBER_ADD_PUSH (unquote-splicing rest)))))
                       (((quote RETURN) 1 . rest)
                        (iter (quasiquote (RETURN1 (unquote-splicing rest)))))
                       (((quote RETURN) 2 . rest)
                        (iter (quasiquote (RETURN2 (unquote-splicing rest)))))
                       (((quote RETURN) 3 . rest)
                        (iter (quasiquote (RETURN3 (unquote-splicing rest)))))
                       (((quote CALL) 2 . rest)
                        (iter (quasiquote (CALL2 (unquote-splicing rest)))))
                       (((quote REFER_LOCAL0)
                         (quote EQV)
                         (quote TEST)
                         .
                         rest)
                        (iter (quasiquote
                                (REFER_LOCAL0_EQV_TEST
                                  (unquote-splicing rest)))))
                       (((quote PUSH) (quote CONSTANT) . rest)
                        (iter (quasiquote
                                (PUSH_CONSTANT (unquote-splicing rest)))))
                       (((quote PUSH) (quote FRAME) . rest)
                        (iter (quasiquote
                                (PUSH_FRAME (unquote-splicing rest)))))
                       (((and x (not (quote CONSTANT_PUSH)))
                         (quote PUSH)
                         (quote FRAME)
                         .
                         rest)
                        (iter (quasiquote
                                ((unquote x)
                                 PUSH_FRAME
                                 (unquote-splicing rest)))))
                       (((quote REFER_FREE) 3 . rest)
                        (iter (quasiquote
                                (REFER_FREE3 (unquote-splicing rest)))))
                       (((quote REFER_LOCAL) 3 . rest)
                        (iter (quasiquote
                                (REFER_LOCAL3 (unquote-splicing rest)))))
                       (((quote CAR) (quote PUSH) . rest)
                        (iter (quasiquote (CAR_PUSH (unquote-splicing rest)))))
                       (((quote CDR) (quote PUSH) . rest)
                        (iter (quasiquote (CDR_PUSH (unquote-splicing rest)))))
                       (((quote REFER_FREE0) (quote INDIRECT) . rest)
                        (iter (quasiquote
                                (REFER_FREE0_INDIRECT
                                  (unquote-splicing rest)))))
                       (((quote REFER_LOCAL2) (quote PUSH) . rest)
                        (iter (quasiquote
                                (REFER_LOCAL2_PUSH (unquote-splicing rest)))))
                       (((quote SHIFT) m n (quote CALL) o . rest)
                        (iter (quasiquote
                                (SHIFT_CALL
                                  (unquote m)
                                  (unquote n)
                                  (unquote o)
                                  (unquote-splicing rest)))))
                       (((quote CALL) 3 . rest)
                        (iter (quasiquote (CALL3 (unquote-splicing rest)))))
                       (((quote REFER_FREE1) (quote INDIRECT) . rest)
                        (iter (quasiquote
                                (REFER_FREE1_INDIRECT
                                  (unquote-splicing rest)))))
                       (((quote NOT) (quote TEST) . rest)
                        (iter (quasiquote (NOT_TEST (unquote-splicing rest)))))
                       (((quote REFER_GLOBAL)
                         lib-id
                         (quote CALL)
                         n
                         .
                         rest)
                        (iter (quasiquote
                                (REFER_GLOBAL_CALL
                                  (unquote lib-id)
                                  (unquote n)
                                  (unquote-splicing rest)))))
                       (((quote REFER_LOCAL0)
                         (quote NUMBER_ADD_PUSH)
                         .
                         rest)
                        (iter (cons (quote REFER_LOCAL0_NUMBER_ADD_PUSH)
                                    rest)))
                       (((quote REFER_LOCAL0) (quote VECTOR_SET) . rest)
                        (iter (cons (quote REFER_LOCAL0_VECTOR_SET) rest)))
                       (((quote REFER_LOCAL0) (quote VECTOR_REF) . rest)
                        (iter (cons (quote REFER_LOCAL0_VECTOR_REF) rest)))
                       (((quote REFER_LOCAL) n (quote PUSH) . rest)
                        (iter (quasiquote
                                (REFER_LOCAL_PUSH
                                  (unquote n)
                                  (unquote-splicing rest)))))
                       (else (cons (car s) (iter (cdr s))))))))
  sexp)

(define
  (compile sexp)
  (pass4 (merge-insn
           (pass3 (let1 x
                        (pass2/optimize
                          (pass1/sexp->iform
                            (pass1/expand sexp)
                            top-level-library
                            (quote ())
                            #f)
                          (quote ()))
                        x)
                  (quote ())
                  *free-lvars*
                  (quote ())
                  (quote ())
                  #f))))

(define
  (compile-no-optimize sexp)
  (pass4 (pass3 (pass1/sexp->iform
                  (pass1/expand sexp)
                  top-level-library
                  (quote ())
                  #f)
                (quote ())
                *free-lvars*
                (quote ())
                (quote ())
                #f)))

#f