(((title "Mosh User's Reference") (author "Higepon") (affiliation . "") (abstract (ast "div" ((ast "p" ("This is a reference manual of " #t (ast "a" ("Mosh") (href "http://code.google.com/p/mosh-scheme/") double xhtml10-transitional ()) #t ", an R6RS Scheme implementation.") () double xhtml10-transitional ()) #t (ast "p" ("This manual is for version 0.0.3.") () double xhtml10-transitional ()) #t (ast "p" ("On version 0.0.3, all procedures defined at top level. This problem will be fixed version 0.0.4 or later.") () double xhtml10-transitional ())) () double xhtml10-transitional ())) (scheme-source-file . "/home/taro/mosh/library.scm/") (laml-resource . "false") (documentation-commenting-style . not-provided) (default-attribute-explanation . not-provided) (source-destination-delta . "") (css-prestylesheet . "normal") (css-stylesheet . "monar") (css-stylesheet-copying . not-provided) (make-dtd-manual-template . not-provided) (keep-syntactical-comment-file . not-provided) (manual-destination-name . not-provided) (mirror-names-defined . not-provided) (mirror-name-prefix . not-provided) (attribute-sorting . not-provided) (scheme-source-linking . "false")) ((kind "manual-section") (section-title "Base library.") (section-body "R6RS chapter 11.")) ((kind "manual-page") (examples (example "(eqv? 'a 'a)                             =>  #t") (example "(eqv? 'a 'b)                             =>  #f") (example "(eqv? 2 2)                               =>  #t") (example "(eqv? '() '())                           =>  #t") (example "(eqv? 100000000 100000000)               =>  #t") (example "(eqv? (cons 1 2) (cons 1 2))             =>  #f") (example "(eqv? (lambda () 1)") (example "(eqv? #f 'nil)                          =>  #f")) (description "<p>The eqv? procedure defines a useful equivalence relation on objects. <p>Briefly, it returns #t if obj1 and obj2 should normally be regarded as the same object and #f otherwise.</p> <p>The eqv? procedure returns #t if one of the following holds:</p> <p>Obj1 and obj2 are both booleans and are the same according to the boolean=? procedure.</p> <p>Obj1 and obj2 are both symbols and are the same according to the symbol=? procedure.</p> <p>Obj1 and obj2 are both exactnumber objects and are numerically equal.</p> <p>Obj1 and obj2 are both inexactnumber objects, are numerically equal, and yield the same results (in the sense of eqv?) when passed as arguments to any other procedure that can be defined as a finite composition of Scheme's standard arithmetic procedures.</p> <p>Obj1 and obj2 are both characters and are the same character according to the char=? procedure .</p> <p>Both obj1 and obj2 are the empty list.</p> <p>Obj1 and obj2 are objects such as pairs, vectors, bytevectors , strings, hashtables, records, ports, or hashtables that refer to the same locations in the store.</p> <p>Obj1 and obj2 are record-type descriptors that are specified to be eqv? in library.</p> <p>The eqv? procedure returns #f if one of the following holds:</p> <p>Obj1 and obj2 are of different types.</p> <p>Obj1 and obj2 are booleans for which the boolean=? procedure returns #f.</p> <p>Obj1 and obj2 are symbols for which the symbol=? procedure returns #f.</p> <p>One of obj1 and obj2 is an exact number object but the other is an inexact number object.</p> <p>Obj1 and obj2 are rational number objects for which the = procedure returns #f.</p> <p>Obj1 and obj2 yield different results (in the sense of eqv?) when passed as arguments to any other procedure that can be defined as a finite composition of Scheme's standard arithmetic procedures.</p> <p>Obj1 and obj2 are characters for which the char=? procedure returns #f.</p> <p>One of obj1 and obj2 is the empty list, but the other is not.</p> <p>Obj1 and obj2 are objects such as pairs, vectors, bytevectors (library chapter on \"Bytevectors\"), strings, records (library chapter on \"Records\"), ports, or hashtables that refer to distinct locations.</p> <p>Obj1 and obj2 are pairs, vectors, strings, or records, or hashtables, where the applying the same accessor (i.e. car, cdr, vector-ref, string-ref, or record accessors) to both yields results for which eqv? returns #f.</p> <p>Obj1 and obj2 are procedures that would behave differently (return different values or have different side effects) for some arguments.</p> (lambda () 2)) => #f ") (form "(eqv? obj1 obj2)") (returns "#t if equal") (title "eqv?")) ((kind "manual-page") (description "A lambda expression evaluates to a procedure. <p>The environment in effect when the lambda expression is evaluated is remembered as part of the procedure.</p> <p>When the procedure is later called with some arguments, the environment in which the lambda expression was evaluated is extended by binding the variables in the parameter list to fresh locations, and the resulting argument values are stored in those locations.</p> <p>Then, the expressions in the body of the lambda expression are evaluated sequentially in the extended environment. The results of the last expression in the body are returned as the results of the procedure call.</p> ") (form "(lambda [formals] [body])") (returns "A procedure") (title "lambda")) ((kind "manual-page") (cross-references (reference "Quasiquote" "quasiquote" "http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_768")) (description "Quasiquote ") (form "(quasiquote [qq template])") (title "quasiquote")) ((kind "manual-page") (description "Evaluates to the datum value represented by [datum]. ") (form "(quote [datum])") (returns "quoted object") (title "quote")) ((kind "manual-page") (description "<p>An if expression is evaluated as follows: first, [test] is evaluated.</p> <p>If it yields a true value, then [consequent] is evaluated and its values are returned.Otherwise <alternate> is evaluated and its values are returned.</p> <p>If <test> yields #f and no [alternate] is specified, then the result of the expression is unspecified.</p> ") (form "(if [test] [consequent] [alternate]) (if [test] [consequent])") (title "if")) ((kind "manual-page") (examples (example "(let ((x 2) (y 3))\n           (* x y)) =>  6") (example "(let ((x 2) (y 3))\n           (let ((x 7)\n             (z (+ x y)))\n               (* z x)))  => 35")) (description "<p>(let [bindings] [body])</p> <p>Syntax: [Bindings] must have the form</p> <p> (([variable1] [init1]) ...),</p> <p>where each [init] is an expression.</p> <p>Any variable must not appear more than once in the [variable]s.</p> ") (form "(let [bindings] [body])") (title "let")) ((kind "manual-page") (examples (example "(let ((x 2) (y 3))\n           (let* ((x 7)\n                 (z (+ x y)))\n                   (* z x))) =>70")) (description "<p>(let* [bindings] [body])</p> <p>Syntax: [Bindings] must have the form</p> <p>(([variable1] [init1]) ...),</p> <p>Semantics: The let* form is similar to let, but the [init]s are evaluated and bindings created sequentially from left to right, with the regionof each binding including the bindings to its right as well as [body].</p> <p>Thus the second [init] is evaluated in an environment in which the first binding is visible and initialized, and so on.</p> ") (form "(let* [bindings] [body])") (title "let*")) ((kind "manual-page") (description "<p>(letrec [bindings] [body])</p> <p>Syntax: [Bindings] must have the form</p> <p>(([variable1] [init1]) ...),</p> <p>Any variable must not appear more than once in the [variable]s.</p> <p>Semantics: The [variable]s are bound to fresh locations, the [init]s are evaluated in the resulting environment (in some unspecified order), each [variable] is assigned to the result of the corresponding [init], the [body] is evaluated in the resulting environment, and the values of the last expression in <body> are returned.</p> <p>Each binding of a [variable] has the entire letrec expression as its region, making it possible to define mutually recursive procedures.</p> ") (form "(letrec [bindings] [body])") (title "letrec")) ((kind "manual-page") (examples (example "(not #t)           =>  #f") (example "(not 3)            =>  #f") (example "(not (list 3))     =>  #f") (example "(not #f)           =>  #t") (example "(not '())          =>  #f") (example "(not (list))       =>  #f") (example "(not 'nil)         =>  #f")) (description "Returns #t if obj is #f, and returns #f otherwise. ") (form "(not obj)") (returns "#t if obj is #f, and returns #f otherwise.") (title "not")) ((kind "manual-page") (examples (example "(or (= 2 2) (> 2 1))                    =>  #t") (example "(or (= 2 2) (< 2 1))                    =>  #t") (example "(or #f #f #f)                           =>  #f") (example "(or '(b c) (/ 3 0))                     =>  (b c)")) (description "If there are no [test]s, #f is returned. Otherwise, the [test] expressions are evaluated from left to right until a [test] returns a true value val or the last [test] is reached. <p>In the former case, the or expression returns val without evaluating the remaining expressions. In the latter case, the last expression is evaluated and its values are returned.</p> ") (form "(or [test1] ...)") (title "or")) ((kind "manual-page") (description "<p>[Expression] is evaluated, and the resulting value is stored in the location to which [variable] is bound. </p><p>[Variable] must be bound either in some regionenclosing the set! expression or at the top level.</p> ") (form "(set! [variable] [expression])") (returns "unspecified") (title "set!")) ((kind "manual-page") (description "Returns #t if obj is a symbol, otherwise returns #f. ") (form "(symbol? obj)") (returns "#t if obj is a symbol, otherwise returns #f.") (title "symbol?")) ((kind "manual-page") (description "Returns the number of elements in vector as an exact integer object. ") (form "(vector-length vector)") (returns "The number of elements in vector as an exact integer object.") (title "vector-length")) ((kind "manual-page") (examples (example "(vector-ref '#(1 1 2 3 5 8 13 21) 5) =>  8")) (description "Returns the contents of elementk of vector. ") (pre-condition "K must be a valid index of vector.") (form "(vector-ref vector k)") (returns "The contents of elementk of vector.") (title "vector-ref")) ((kind "manual-page") (examples (example "<pre>(let ((vec (vector 0 '(2 2 2 2) \"Anna\")))\n                   (vector-set! vec 1 '(\"Sue\" \"Sue\"))\n                   vec)\n               =>  #(0 (\"Sue\" \"Sue\") \"Anna\")</pre>")) (description "stores obj in element k of vector, and returns unspecified values. ") (pre-condition "K must be a valid index of vector.") (form "(vector-set! vector k obj)") (returns "unspecified") (title "vector-set!")) ((kind "manual-page") (description "If there are no [test]s, #t is returned. Otherwise, the [test] expressions are evaluated from left to right until a [test] returns #f or the last [test] is reached. <p>In the former case, the and expression returns #f without evaluating the remaining expressions. In the latter case, the last expression is evaluated and its values are returned.</p> ") (form "(and [test1] ...)") (title "and")) ((kind "manual-page") (description "The apply procedure calls proc with the elements of the list (append (list arg1 ...) rest-args) as the actual arguments. ") (pre-condition "Rest-args must be a list. Proc should accept n arguments, where n is number of args plus the length of rest-args.") (form "(apply proc arg1 ... rest-args)") (returns "The apply procedure calls proc with the elements of the list (append (list arg1 ...) rest-args) as the actual arguments.") (title "apply")) ((kind "manual-page") (description "<p>The [begin] keyword has two different roles, depending on its context:</p> <p>It may appear as a form in a [body] , [library body] , or [top-level body], or directly nested in a begin form that appears in a body. In this case, the begin form must have the shape specified in the first header line.</p> <p>This use of begin acts as a splicing form the forms inside the [body] are spliced into the surrounding body, as if the begin wrapper were not actually present.</p> <p>A begin form in a [body] or [library body] must be non-empty if it appears after the first [expression] within the body. It may appear as an ordinary expression and must have the shape specified in the second header line.</p> <p>In this case, the [expression]s are evaluated sequentially from left to right, and the values of the last [expression] are returned. This expression type is used to sequence side effects such as assignments or input and output.</p> ") (form "(begin [form] ...) (begin [expression] [expression] ...)") (title "begin")) ((kind "manual-page") (description "<p>The procedure call-with-current-continuation (which is the same as the procedure call/cc) packages the current continuation as an \"escape procedure\"and passes it as an argument to proc.</p> <p>The escape procedure is a Scheme procedure that, if it is later called, will abandon whatever continuation is in effect at that later time and will instead reinstate the continuation that was in effect when the escape procedure was created.</p> ") (form "(call-with-current-continuation proc)") (title "call-with-current-continuation")) ((kind "manual-page") (examples (example "<pre>(case (* 2 3)\n                 ((2 3 5 7) 'prime)\n                 ((1 4 6 8 9) 'composite))  =>  composite</pre>")) (description "<p>case expression is evaluated as follows.</p> <p>[Key] is evaluated and its result is compared using eqv? against the data represented by the [datum]s of each [case clause] in turn, proceeding in order from left to right through the set of clauses.</p> <p>If the result of evaluating [key] is equivalent to a datum of a [case clause], the corresponding [expression]s are evaluated from left to right and the results of the last expression in the [case clause] are returned as the results of the case expression. Otherwise, the comparison process continues.</p> <p>If the result of evaluating [key] is different from every datum in each set, then if there is an else clause its expressions are evaluated and the results of the last are the results of the case expression; otherwise the case expression returns unspecified values.</p> ") (form "(case [key] [case clause1] [case clause2] ...)") (title "case")) ((kind "manual-page") (examples (example "<pre>(cond ((> 3 2) 'greater)\n                ((< 3 2) 'less)) =>  greater</pre>") (example "<pre>(cond ((> 3 3) 'greater)\n                ((< 3 3) 'less)\n                (else 'equal))   =>  equal</pre>") (example "<pre>(cond ('(1 2 3) => cadr)\n                (else #f))       =>  2</pre>")) (description "<p>A cond expression is evaluated by evaluating the [test] expressions of successive [cond clause]s in order until one of them evaluates to a true value.</p> <p>When a [test] evaluates to a true value, then the remaining [expression]s in its [cond clause] are evaluated in order, and the results of the last [expression] in the [cond clause] are returned as the results of the entire cond expression.</p> <p>If the selected [cond clause] contains only the [test] and no [expression]s, then the value of the [test] is returned as the result. If the selected [cond clause] uses the => alternate form, then the [expression] is evaluated. Its value must be a procedure.</p> <p>This procedure should accept one argument; it is called on the value of the [test] and the values returned by this procedure are returned by the cond expression.</p> <p>If all [test]s evaluate to #f, and there is no else clause, then the conditional expression returns unspecified values; if there is an else clause, then its [expression]s are evaluated, and the values of the last one are returned.</p> ") (form "(cond [cond clause1] [cond clause2] ...)") (title "cond")) ((kind "manual-page") (description "The define form is used to create variable bindings and may appear anywhere other definitions may appear. ") (form "(define [variable] [expression]) (define [variable]) (define ([variable] [formals]) [body]) (define ([variable] . [formal]) [body])") (title "define")) ((kind "manual-page") (description "The define-macro form is used to create traditional macro. ") (form "(define-macro (name . args) body)") (title "define-macro")) ((kind "manual-page") (description "Returns the product of their arguments. ") (form "(* z1 ...)") (returns "The product of their arguments.") (title "*")) ((kind "manual-page") (description "Returns the sum of their arguments. ") (form "(+ z1 ...)") (returns "The sum of their arguments.") (title "+")) ((kind "manual-page") (description "Returns the division of their arguments. ") (form "(/ z1 ...)") (returns "The division of their arguments.") (title "/")) ((kind "manual-page") (description "Returns the modulo of their arguments. ") (form "(mod z1 z2)") (returns "The modulo of their arguments.") (title "mode")) ((kind "manual-page") (description "With two or more arguments, this procedures returns the difference of its arguments, associating to the left. With one argument, however, it returns the additive inverse of its argument. ") (form "(- z1 z2 ...) (- z)") (returns "With two or more arguments, this procedures returns the difference of its arguments, associating to the left. With one argument, however, it returns the additive inverse of its argument.") (title "-")) ((kind "manual-page") (description "Returns #t if its arguments are monotonically increasing and #f otherwise. ") (form "(< x1 x2 x3 ...)") (returns "#t if its arguments are monotonically increasing and #f otherwise.") (title "<")) ((kind "manual-page") (description "Returns #t if its arguments are monotonically nondecreasing and #f otherwise. ") (form "(<= x1 x2 x3 ...)") (returns "#t if its arguments are monotonically nondecreasing and #f otherwise.") (title "<=")) ((kind "manual-page") (description "Returns #t if its arguments are equal and #f otherwise. ") (form "(= x1 x2 x3 ...)") (returns "#t if its arguments are equal and #f otherwise.") (title "=")) ((kind "manual-page") (description "Returns #t if its arguments are monotonically decreasing and #f otherwise. ") (form "(> x1 x2 x3 ...)") (returns "#t if its arguments are monotonically decreasing and #f otherwise.") (title ">")) ((kind "manual-page") (description "Returns #t if its arguments are monotonically increasing and #f otherwise. ") (form "(> x1 x2 x3 ...)") (returns "#t if its arguments are monotonically increasing and #f otherwise.") (title ">=")) ((kind "manual-page") (description "Returns a newly allocated vector whose elements contain the given arguments. Analogous to list. ") (form "(vector obj ...)") (returns "A newly allocated vector whose elements contain the given arguments. Analogous to list.") (title "vector")) ((kind "manual-page") (description "Returns #t if obj is a pair, and otherwise returns #f. ") (form "(pair? obj)") (returns "#t if obj is a pair, and otherwise returns #f.") (title "pair?")) ((kind "manual-page") (cross-references (internal-references "Base Library" "call-with-values")) (description "Delivers all of its arguments to its continuation. ") (form "(values obj ...)") (returns "Delivers all of its arguments to its continuation.") (title "values")) ((kind "manual-page") (description "This error procedure will be replaced with R6RS (error) ") (form "(error message)") (returns "This error procedure will be replaced with R6RS (error)") (title "error")) ((kind "manual-page") (description "Returns the name of symbol as an immutable string. ") (form "(symbol->string symbol)") (returns "Returns the name of symbol as an immutable string.") (title "symbol->string")) ((kind "manual-page") (description "Returns #t if obj is either #t or #f and returns #f otherwise. ") (form "(boolean? obj)") (returns "#t if obj is either #t or #f and returns #f otherwise.") (title "boolean?")) ((kind "manual-page") (examples (example "(eq? 'a 'a) =>  #t") (example "(eq? '(a) '(a))                         =>  #f (unspecified on R6RS)") (example "(eq? (list 'a) (list 'a))               =>  #f") (example "(eq? \"a\" \"a\")                           =>  #f (unspecified on R6RS)") (example "(eq? \"\" \"\")                             =>  #f (unspecified on R6RS)") (example "(eq? '() '())                           =>  #t") (example "(eq? 2 2)                               =>  #t (unspecified on R6RS)") (example "(eq? #\\A #\\A)                           =>  #t (unspecified on R6RS)") (example "(eq? car car)                           =>  #t") (example "<pre>(let ((n (+ 2 3)))\n                (eq? n n))                       =>  #t (unspecified on R6RS)</pre>") (example "<pre>(let ((x '(a)))\n                (eq? x x))                       =>  #t (unspecified on R6RS)</pre>") (example "<pre>(let ((x '#()))\n                 (eq? x x))                      =>  #t (unspecified on R6RS)</pre>") (example "<pre>(let ((p (lambda (x) x)))\n                (eq? p p))                       =>  #t (unspecified on R6RS)</pre>")) (description "<p>The eq? predicate is similar to eqv? except that in some cases it is capable of discerning distinctions finer than those detectable by eqv?.</p> <p>The eq? and eqv? predicates are guaranteed to have the same behavior on symbols, booleans, the empty list, pairs, procedures, non-empty strings, bytevectors, and vectors, and records.</p> ") (returns "#t if eq?") (title "eq?") (form (eq?))) ((kind "manual-page") (description "Returns #t if obj is a vector. Otherwise the procedure returns #f. ") (form "(vector? obj)") (returns "#t if obj is a vector. Otherwise the procedure returns #f.") (title "vector?")) ((kind "manual-page") (examples (example "(equal? 'a 'a)                                 =>  #t") (example "(equal? '(a) '(a))                             =>  #t") (example "(equal? '(a (b) c) '(a (b) c))                 =>  #t") (example "(equal? \"abc\" \"abc\")                           =>  #t") (example "(equal? 2 2)                                   =>  #t") (example "(equal? (make-vector 5 'a) (make-vector 5 'a)) =>  #t")) (description "The equal? predicate returns #t if and only if the unfoldings of its arguments into regular trees are equal as ordered trees. ") (form "(equal? obj1 obj2)") (returns "#t if and only if the unfoldings of its arguments into regular trees are equal as ordered trees.") (title "equal?")) ((kind "manual-page") (description "Returns #t if obj is a character, otherwise returns #f. ") (form "(char? obj)") (returns "#t if obj is a character, otherwise returns #f.") (title "char?")) ((kind "manual-page") (description "Returns #t if all given charctors are same charctor. ") (form "(char=? char1 char2 char3 ...)") (returns "#t if all given charctors are same charctor.") (title "char=?")) ((kind "manual-page") (description "Given a character, char->integer returns its Unicode scalar value as an exact integer object. ") (form "(char->integer char)") (returns "Given a character, char->integer returns its Unicode scalar value as an exact integer object.") (title "char->integer")) ((kind "manual-page") (description "For a Unicode scalar value sv, integer->char returns its associated character. ") (form "(integer->char sv)") (returns "For a Unicode scalar value sv, integer->char returns its associated character.") (title "integer->char")) ((kind "manual-page") (description "(not implemented yet) Returns #t if obj is a list, #f otherwise. By definition, all lists are chains of pairs that have finite length and are terminated by the empty list. ") (form "(list? obj)") (returns "#t if obj is a list, #f otherwise. By definition, all lists are chains of pairs that have finite length and are terminated by the empty list.") (title "list?")) ((kind "manual-page") (examples (example "(cons 'a '())                   =>  (a)") (example "(cons '(a) '(b c d))            =>  ((a) b c d)") (example "(cons \"a\" '(b c))               =>  (\"a\" b c)") (example "(cons 'a 3)                     =>  (a . 3)") (example "(cons '(a b) 'c)                =>  ((a b) . c)")) (description "Returns a newly allocated pair whose car is obj1 and whose cdr is obj2. The pair is guaranteed to be different (in the sense of eqv?) from every existing object. ") (returns "A newly allocated pair whose car is obj1 and whose cdr is obj2.") (form "(cons obj1 obj2)") (title "cons")) ((kind "manual-page") (examples (example "(car '(a b c))                  =>  a") (example "(car '((a) b c d))              =>  (a)") (example "(car '(1 . 2))                  =>  1") (example "(car '())                       &assertion exception (not implemented yet)")) (description "Returns the contents of the car field of pair. ") (returns "The contents of the car field of pair.") (form "(car pair)") (title "car")) ((kind "manual-page") (examples (example "(cdr '((a) b c d))              =>  (b c d)") (example "(cdr '(1 . 2))                  =>  2") (example "(cdr '())                       &assertion exception (not implemented yet)")) (description "Returns the contents of the cdr field of pair. ") (returns "The contents of the cdr field of pair.") (form "(cdr pair)") (title "cdr")) ((kind "manual-page") (description "Returns #t if obj is the empty list, #f otherwise. ") (returns "#t if obj is the empty list, #fotherwise.") (form "(null? obj)") (title "null?")) ((kind "manual-page") (description "<p>Returns #t if the strings are the same length and contain the same characters in the same positions.</p> <p>Otherwise, the string=? procedure returns #f.Returns #t if obj is a string, otherwise returns #f.</p> ") (form "(string=? string1 string2 string3 ...)") (returns "Returns #t if the strings are the same length and contain the same characters in the same positions.") (title "string=?")) ((kind "manual-page") (description "Returns a newly allocated string of length k. If char is given, then all elements of the string are initialized to char, otherwise the contents of the string are unspecified. ") (form "(make-string k &optional char)") (returns "allocated string of length k.") (title "make-string")) ((kind "manual-page") (description "Returns #t if obj is a string, otherwise returns #f. ") (form "(string? obj)") (returns "#t if obj is a string, otherwise returns #f.") (title "string?")) ((kind "manual-page") (description "Returns the number of characters in the given string as an exact integer object. ") (returns "the number of characters in the given string as an exact integer object.") (form "(string-length string)") (title "string-length")) ((kind "manual-page") (description "character at index k in string ") (pre-condition "K must be a valid index of string.") (returns "character at index k in string") (form "(string-ref string k)") (title "string-ref")) ((kind "manual-page") (description "stores char in element k of string. ") (returns "unspecified") (form "(string-set! string k char)") (title "string-set!")) ((kind "manual-page") (examples (example "(eq? 'JollyWog\n    (string->symbol\n      (symbol->string 'JollyWog))) => #t")) (description "Returns the symbol whose name is string. ") (form "(string->symbol string)") (title "string->symbol")) ((kind "manual-page") (description "Returns a number by the given string. ") (form "(string->number string)") (returns "number") (title "string->number")) ((kind "manual-page") (description "Returns a newly allocated string whose characters form the concatenation of the given strings. ") (form "(string-append string ...)") (returns "A newly allocated string whose characters form the concatenation of the given strings.") (title "string-append")) ((kind "manual-page") (description "Splits string by splitter and returns a list of strings. splitter can be a character. ") (form "(string-split string splitter)") (returns "a list of splitted strings.") (title "string-split")) ((kind "manual-page") (description "Takes a number object and returns as a string an external representation of the given number object. ") (form "(number->string z)") (returns "Takes a number object and returns as a string an external representation of the given number object.") (title "number->string")) ((kind "manual-page") (parameters (parameter "radix" "must be 16. (2, 8, 10 is not implemented yet)")) (description "Takes a number object and a radix and returns as a string an external representation of the given number object in the given radix. ") (form "(number->string z radix)") (returns "Takes a number object and a radix and returns as a string an external representation of the given number object in the given radix.") (title "number->string")) ((kind "manual-page") (description "return #t if obj is number object and #f otherwise. ") (returns "#t if obj is number object and #f otherwise") (title "number?") (form (number? obj))) ((kind "manual-page") (description "returns (car (car p)) ") (pre-condition "p is pair") (returns "(car (car p))") (title "caar") (form (caar p))) ((kind "manual-page") (description "returns (cdr (car p)) ") (pre-condition "p is pair") (returns "(cdr (car p))") (title "cdar") (form (cdar p))) ((kind "manual-page") (description "returns (car (cdr p)) ") (pre-condition "p is pair") (returns "(car (cdr p))") (title "cadr") (form (cadr p))) ((kind "manual-page") (description "returns (cdr (cdr p)) ") (pre-condition "p is pair") (returns "(cdr (cdr p))") (title "cddr") (form (cddr p))) ((kind "manual-page") (description "returns (car (car (car p))) ") (pre-condition "p is pair") (returns "(car (car (car p)))") (title "caaar") (form (caaar p))) ((kind "manual-page") (description "returns (cdr (car (car p))) ") (pre-condition "p is pair") (returns "(cdr (car (car p)))") (title "cdaar") (form (cdaar p))) ((kind "manual-page") (description "returns (car (cdr (car p))) ") (pre-condition "p is pair") (returns "(car (cdr (car p)))") (title "cadar") (form (cadar p))) ((kind "manual-page") (description "returns (cdr (cdr (car p))) ") (pre-condition "p is pair") (returns "(cdr (cdr (car p)))") (title "cddar") (form (cddar p))) ((kind "manual-page") (description "returns (car (car (cdr p))) ") (pre-condition "p is pair") (returns "(car (car (cdr p)))") (title "caadr") (form (caadr p))) ((kind "manual-page") (description "returns (cdr (car (cdr p))) ") (pre-condition "p is pair") (returns "(cdr (car (cdr p)))") (title "cdadr") (form (cdadr p))) ((kind "manual-page") (description "returns (car (cdr (cdr p))) ") (pre-condition "p is pair") (returns "(car (cdr (cdr p)))") (title "caddr") (form (caddr p))) ((kind "manual-page") (description "returns (cdr (cdr (cdr p))) ") (pre-condition "p is pair") (returns "(cdr (cdr (cdr p)))") (title "cdddr") (form (cdddr p))) ((kind "manual-page") (description "returns (car (car (car (car p)))) ") (pre-condition "p is pair") (returns "(car (car (car (car p))))") (title "caaaar") (form (caaaar p))) ((kind "manual-page") (description "returns (cdr (car (car (car p)))) ") (pre-condition "p is pair") (returns "(cdr (car (car (car p))))") (title "cdaaar") (form (cdaaar p))) ((kind "manual-page") (description "returns (car (cdr (car (car p)))) ") (pre-condition "p is pair") (returns "(car (cdr (car (car p))))") (title "cadaar") (form (cadaar p))) ((kind "manual-page") (description "returns (cdr (cdr (car (car p)))) ") (pre-condition "p is pair") (returns "(cdr (cdr (car (car p))))") (title "cddaar") (form (cddaar p))) ((kind "manual-page") (description "returns (car (car (cdr (car p)))) ") (pre-condition "p is pair") (returns "(car (car (cdr (car p))))") (title "caadar") (form (caadar p))) ((kind "manual-page") (description "returns (cdr (car (cdr (car p)))) ") (pre-condition "p is pair") (returns "(cdr (car (cdr (car p))))") (title "cdadar") (form (cdadar p))) ((kind "manual-page") (description "returns (car (cdr (cdr (car p)))) ") (pre-condition "p is pair") (returns "(car (cdr (cdr (car p))))") (title "caddar") (form (caddar p))) ((kind "manual-page") (description "returns (cdr (cdr (cdr (car p)))) ") (pre-condition "p is pair") (returns "(cdr (cdr (cdr (car p))))") (title "cdddar") (form (cdddar p))) ((kind "manual-page") (description "returns (car (car (car (cdr p)))) ") (pre-condition "p is pair") (returns "(car (car (car (cdr p))))") (title "caaadr") (form (caaadr p))) ((kind "manual-page") (description "returns (cdr (car (car (cdr p)))) ") (pre-condition "p is pair") (returns "(cdr (car (car (cdr p))))") (title "cdaadr") (form (cdaadr p))) ((kind "manual-page") (description "returns (car (cdr (car (cdr p)))) ") (pre-condition "p is pair") (returns "(car (cdr (car (cdr p))))") (title "cadadr") (form (cadadr p))) ((kind "manual-page") (description "returns (cdr (cdr (car (cdr p)))) ") (pre-condition "p is pair") (returns "(cdr (cdr (car (cdr p))))") (title "cddadr") (form (cddadr p))) ((kind "manual-page") (description "returns (car (car (cdr (cdr p)))) ") (pre-condition "p is pair") (returns "(car (car (cdr (cdr p))))") (title "caaddr") (form (caaddr p))) ((kind "manual-page") (description "returns (cdr (car (cdr (cdr p)))) ") (pre-condition "p is pair") (returns "(cdr (car (cdr (cdr p))))") (title "cdaddr") (form (cdaddr p))) ((kind "manual-page") (description "returns (car (cdr (cdr (cdr p)))) ") (pre-condition "p is pair") (returns "(car (cdr (cdr (cdr p))))") (title "cadddr") (form (cadddr p))) ((kind "manual-page") (description "returns (cdr (cdr (cdr (cdr p)))) ") (pre-condition "p is pair") (returns "(cdr (cdr (cdr (cdr p))))") (title "cddddr") (form (cddddr p))) ((kind "manual-page") (description "returns (car (car (car (car (car p))))) ") (pre-condition "p is pair") (returns "(car (car (car (car (car p)))))") (title "caaaaar") (form (caaaaar p))) ((kind "manual-page") (description "returns (cdr (car (car (car (car p))))) ") (pre-condition "p is pair") (returns "(cdr (car (car (car (car p)))))") (title "cdaaaar") (form (cdaaaar p))) ((kind "manual-page") (description "returns (car (cdr (car (car (car p))))) ") (pre-condition "p is pair") (returns "(car (cdr (car (car (car p)))))") (title "cadaaar") (form (cadaaar p))) ((kind "manual-page") (description "returns (cdr (cdr (car (car (car p))))) ") (pre-condition "p is pair") (returns "(cdr (cdr (car (car (car p)))))") (title "cddaaar") (form (cddaaar p))) ((kind "manual-page") (description "returns (car (car (cdr (car (car p))))) ") (pre-condition "p is pair") (returns "(car (car (cdr (car (car p)))))") (title "caadaar") (form (caadaar p))) ((kind "manual-page") (description "returns (cdr (car (cdr (car (car p))))) ") (pre-condition "p is pair") (returns "(cdr (car (cdr (car (car p)))))") (title "cdadaar") (form (cdadaar p))) ((kind "manual-page") (description "returns (car (cdr (cdr (car (car p))))) ") (pre-condition "p is pair") (returns "(car (cdr (cdr (car (car p)))))") (title "caddaar") (form (caddaar p))) ((kind "manual-page") (description "returns (cdr (cdr (cdr (car (car p))))) ") (pre-condition "p is pair") (returns "(cdr (cdr (cdr (car (car p)))))") (title "cdddaar") (form (cdddaar p))) ((kind "manual-page") (description "returns (car (car (car (cdr (car p))))) ") (pre-condition "p is pair") (returns "(car (car (car (cdr (car p)))))") (title "caaadar") (form (caaadar p))) ((kind "manual-page") (description "returns (cdr (car (car (cdr (car p))))) ") (pre-condition "p is pair") (returns "(cdr (car (car (cdr (car p)))))") (title "cdaadar") (form (cdaadar p))) ((kind "manual-page") (description "returns (car (cdr (car (cdr (car p))))) ") (pre-condition "p is pair") (returns "(car (cdr (car (cdr (car p)))))") (title "cadadar") (form (cadadar p))) ((kind "manual-page") (description "returns (cdr (cdr (car (cdr (car p))))) ") (pre-condition "p is pair") (returns "(cdr (cdr (car (cdr (car p)))))") (title "cddadar") (form (cddadar p))) ((kind "manual-page") (description "returns (car (car (cdr (cdr (car p))))) ") (pre-condition "p is pair") (returns "(car (car (cdr (cdr (car p)))))") (title "caaddar") (form (caaddar p))) ((kind "manual-page") (description "returns (cdr (car (cdr (cdr (car p))))) ") (pre-condition "p is pair") (returns "(cdr (car (cdr (cdr (car p)))))") (title "cdaddar") (form (cdaddar p))) ((kind "manual-page") (description "returns (car (cdr (cdr (cdr (car p))))) ") (pre-condition "p is pair") (returns "(car (cdr (cdr (cdr (car p)))))") (title "cadddar") (form (cadddar p))) ((kind "manual-page") (description "returns (cdr (cdr (cdr (cdr (car p))))) ") (pre-condition "p is pair") (returns "(cdr (cdr (cdr (cdr (car p)))))") (title "cddddar") (form (cddddar p))) ((kind "manual-page") (description "returns (car (car (car (car (cdr p))))) ") (pre-condition "p is pair") (returns "(car (car (car (car (cdr p)))))") (title "caaaadr") (form (caaaadr p))) ((kind "manual-page") (description "returns (cdr (car (car (car (cdr p))))) ") (pre-condition "p is pair") (returns "(cdr (car (car (car (cdr p)))))") (title "cdaaadr") (form (cdaaadr p))) ((kind "manual-page") (description "returns (car (cdr (car (car (cdr p))))) ") (pre-condition "p is pair") (returns "(car (cdr (car (car (cdr p)))))") (title "cadaadr") (form (cadaadr p))) ((kind "manual-page") (description "returns (cdr (cdr (car (car (cdr p))))) ") (pre-condition "p is pair") (returns "(cdr (cdr (car (car (cdr p)))))") (title "cddaadr") (form (cddaadr p))) ((kind "manual-page") (description "returns (car (car (cdr (car (cdr p))))) ") (pre-condition "p is pair") (returns "(car (car (cdr (car (cdr p)))))") (title "caadadr") (form (caadadr p))) ((kind "manual-page") (description "returns (cdr (car (cdr (car (cdr p))))) ") (pre-condition "p is pair") (returns "(cdr (car (cdr (car (cdr p)))))") (title "cdadadr") (form (cdadadr p))) ((kind "manual-page") (description "returns (car (cdr (cdr (car (cdr p))))) ") (pre-condition "p is pair") (returns "(car (cdr (cdr (car (cdr p)))))") (title "caddadr") (form (caddadr p))) ((kind "manual-page") (description "returns (cdr (cdr (cdr (car (cdr p))))) ") (pre-condition "p is pair") (returns "(cdr (cdr (cdr (car (cdr p)))))") (title "cdddadr") (form (cdddadr p))) ((kind "manual-page") (description "returns (car (car (car (cdr (cdr p))))) ") (pre-condition "p is pair") (returns "(car (car (car (cdr (cdr p)))))") (title "caaaddr") (form (caaaddr p))) ((kind "manual-page") (description "returns (cdr (car (car (cdr (cdr p))))) ") (pre-condition "p is pair") (returns "(cdr (car (car (cdr (cdr p)))))") (title "cdaaddr") (form (cdaaddr p))) ((kind "manual-page") (description "returns (car (cdr (car (cdr (cdr p))))) ") (pre-condition "p is pair") (returns "(car (cdr (car (cdr (cdr p)))))") (title "cadaddr") (form (cadaddr p))) ((kind "manual-page") (description "returns (cdr (cdr (car (cdr (cdr p))))) ") (pre-condition "p is pair") (returns "(cdr (cdr (car (cdr (cdr p)))))") (title "cddaddr") (form (cddaddr p))) ((kind "manual-page") (description "returns (car (car (cdr (cdr (cdr p))))) ") (pre-condition "p is pair") (returns "(car (car (cdr (cdr (cdr p)))))") (title "caadddr") (form (caadddr p))) ((kind "manual-page") (description "returns (cdr (car (cdr (cdr (cdr p))))) ") (pre-condition "p is pair") (returns "(cdr (car (cdr (cdr (cdr p)))))") (title "cdadddr") (form (cdadddr p))) ((kind "manual-page") (description "returns (car (cdr (cdr (cdr (cdr p))))) ") (pre-condition "p is pair") (returns "(car (cdr (cdr (cdr (cdr p)))))") (title "caddddr") (form (caddddr p))) ((kind "manual-page") (description "returns (cdr (cdr (cdr (cdr (cdr p))))) ") (pre-condition "p is pair") (returns "(cdr (cdr (cdr (cdr (cdr p)))))") (title "cdddddr") (form (cdddddr p))) ((kind "manual-page") (description "Returns whether x is even. ") (returns "whether x is even") (title "even?") (form (even? x))) ((kind "manual-page") (parameters (parameter "producer" "must be a procedure and should accept zero arguments") (parameter "consumer" "must be a procedure and should accept as many values as producer returns")) (cross-references (internal-references "SRFI-8 Binding to multiple values." "receive")) (description "Calls producer with no arguments and a continuation that, when passed some values, calls the consumer procedure with those values as arguments. The continuation for the call to consumer is the continuation of the call to call-with-values. ") (returns "result of consumer") (title "call-with-values") (form (call-with-values producer consumer))) ((kind "manual-page") (examples (example "(list-tail '(a b c d) 2) => (c d)")) (description "returns the subchain of pairs of list obtained by omitting the first k elements ") (pre-condition "l should be a list of size at least k.") (returns "the subchain of pairs of list obtained by omitting the first k elements") (title "list-tail") (form (list-tail l k))) ((kind "manual-page") (examples (example "(list-ref '(a b c d) 2) => c")) (description "returns the kth element of list. ") (pre-condition "l must be a list whose length is at least k + 1.") (returns "returns the kth element of list.") (title "list-ref") (form (list-ref l k))) ((kind "manual-page") (examples (example "(vector->list '#(dah dah didah)) => (dah dah didah)")) (description "returns a newly allocated list of the objects contained in the elements of vector ") (returns "returns a newly allocated list of the objects contained in the elements of vector") (title "vector->list") (form (vector->list v))) ((kind "manual-page") (description "tests if the number object is = to zero ") (returns "#t is (= n 0)") (title "zero?") (form (zero? n))) ((kind "manual-page") (examples (example "(list 'a (+ 3 4) 'c) => (a 7 c)") (example "(list) => ()")) (description "Returns a newly allocated list of its arguments. ") (returns "a newly allocated list of its arguments.") (form "(list obj ...)") (title "list")) ((kind "manual-page") (examples (example "(abs -7) => 7")) (description "Returns the absolute value of its argument. ") (returns "Returns the absolute value of its argument.") (title "abs") (form (abs n))) ((kind "manual-page") (parameters (parameter "ll" "should all have the same length.") (parameter "proc" "should accept as many arguments as there are lists and return a single value. should not mutate any of the lists.")) (examples (example "(map cadr '((a b) (d e) (g h))) => (b e h)") (example "(map (lambda (n) (expt n n)) '(1 2 3 4 5)) => (1 4 27 256 3125)") (example "(map + '(1 2 3) '(4 5 6)) => (5 7 9)")) (description "The map procedure applies proc element-wise to the elements of the lists and returns a list of the results, in order. ") (returns "a list of the results") (form "(map proc list1 list2 ...)") (title "map")) ((kind "manual-page") (description "Returns the length of list. (length '(a b c)) => 3 (length '(a (b) (c d e))) => 3 (length '()) => 0 ") (returns "the length of list.") (title "length") (form (length l))) ((kind "manual-page") (examples (example "(reverse '(a b c)) => (c b a)") (example "(reverse '(a (b c) d (e (f)))) => ((e (f)) d (b c) a)")) (description "Returns a newly allocated list consisting of the elements of list in reverse order. ") (returns "a newly allocated list consisting of the elements of list in reverse order.") (title "reverse") (form (reverse l))) ((kind "manual-page") (description "The list->string procedure returns a newly allocated string formed from the characters in list. ") (returns "The list->string procedure returns a newly allocated string formed from the characters in list.") (title "list->string") (form (list->string l))) ((kind "manual-page") (examples (example "(let ((v (make-vector 5)))\n (for-each (lambda (i)\n             (vector-set! v i (* i i)))\n           '(0 1 2 3 4))\n v)  => #(0 1 4 9 16)") (example "(for-each (lambda (x) x) '(1 2 3 4)) => unspecified") (example "(for-each even? ’()) => unspecified")) (description "The for-each procedure applies proc element-wise to the elements of the lists for its side effects, in order from the first elements to the last. ") (form "(for-each proc list1 list2 ...)") (pre-condition "The lists should all have the same length. Proc should accept as many arguments as there are lists. Proc should not mutate any of the lists.") (returns "The return values of for-each are unspecified.") (title "for-each")) ((kind "manual-page") (examples (example "(list->vector '(dididit dah)) => #(dididit dah)")) (description "The list->vector procedure returns a newly created vector initialized to the elements of the list list. ") (returns "The list->vector procedure returns a newly created vector initialized to the elements of the list list.") (title "list->vector") (form (list->vector l))) ((kind "manual-page") (examples (example "(append '(x) '(y))                      =>  (x y)") (example "(append '(a) '(b c d))                  =>  (a b c d)") (example "(append '(a (b)) '((c)))                =>  (a (b) (c))") (example "(append '(a b) '(c . d))                =>  (a b c . d)") (example "(append '() 'a)                         =>  a")) (description "Returns a possibly improper list consisting of the elements of the first list followed by the elements of the other lists, with obj as the cdr of the final pair. An improper list results if obj is not a list. ") (returns "Returns a possibly improper list consisting of the elements of the first list followed by the elements of the other lists, with obj as the cdr of the final pair. An improper list results if obj is not a list.") (post-condition "If append constructs a nonempty chain of pairs, it is always newly allocated. If no pairs are allocated, obj is returned.") (title "append") (form (append . ll))) ((kind "manual-section") (section-title "Bytevectors.") (section-body "R6RS library Chapter 2. ")) ((kind "manual-page") (description "Stores octet in element k of bytevector. ") (pre-condition "K must be a valid index of bytevector.") (form "(bytevector-u8-set! bytevector k octet)") (returns "unspecified") (title "bytevector-u8-set!")) ((kind "manual-page") (description "Returns, as an exact integer object, the number of bytes in bytevector. ") (form "(bytevector-length bytevector)") (returns "As an exact integer object, the number of bytes in bytevector.") (title "bytevector-length")) ((kind "manual-page") (description "Returns the byte at index k of bytevector, as an octet. ") (pre-condition "K must be a valid index of bytevector.") (form "(bytevector-u8-ref bytevector k)") (returns "the byte at index k of bytevector, as an octet.") (title "bytevector-u8-ref")) ((kind "manual-page") (description "Returns a newly allocated (unless empty) string whose character sequence is encoded by the given bytevector. ") (form "(utf8->string bytevector)") (returns "A newly allocated (unless empty) string whose character sequence is encoded by the given bytevector.") (title "utf8->string")) ((kind "manual-section") (section-title "List utilities.") (section-body "R6RS library Chapter 3.")) ((kind "manual-page") (description "Return the first sublist of list whose car satisfies a given condition with eq?, where the sublists of lists are the lists returned by (list-tail list k) for k less than the length of list. ") (form "(memq obj list)") (pre-condition "Proc should accept one argument and return a single value. Proc should not mutate list.") (returns "The first sublist of list whose car satisfies a given condition, where the sublists of lists are the lists returned by (list-tail list k) for k less than the length of list.") (title "memq")) ((kind "manual-page") (examples (example "(fold-left + 0 '(1 2 3 4 5)) => 15") (example "(fold-left (lambda (a e) (cons e a)) '()\n          '(1 2 3 4 5)) => (5 4 3 2 1)") (example "(fold-left (lambda (count x) \n            (if (odd? x) (+ count 1) count)) \n            0 \n            '(3 1 4 1 5 9 2 6 5 3)) \n          => 7") (example "(fold-left (lambda (max-len s) \n            (max max-len (string-length s))) \n            0 \n            '(\"longest\" \"long\" \"longer\")) \n          => 7") (example "(fold-left + 0 '(1 2 3) '(4 5 6)) \n          => 21") (example "(fold-left cons '(q) '(a b c)) \n           => ((((q) . a) . b) . c)")) (description "<p>The fold-left procedure iterates the combine procedure over an accumulator value and the elements of the lists from left to right, starting with an accumulator value of nil.</p> <p>More specifically, fold-left returns nil if the lists are empty. If they are not empty, combine is first applied to nil and the respective first elements of the lists in order.</p> <p>The result becomes the new accumulator value, and combine is applied to the new accumulator value and the respective next elements of the list.</p> <p>This step is repeated until the end of the list is reached; then the accumulator value is returned. Combine is always called in the same dynamic environment as fold-left itself.</p> ") (form "(fold-left combine nil list1 list2 ...listn)") (todo "be compatible with R6RS") (pre-condition "The lists should all have the same length. Combine must be a procedure. It should accept one more argument than there are lists and return a single value. It should not mutate the list arguments.") (returns "accumlated pair") (title "fold-left")) ((kind "manual-page") (examples (example "(fold-right + 0 '(1 2 3 4 5))\n          => 15") (example "(fold-right cons '() '(1 2 3 4 5))\n         => (1 2 3 4 5)") (example "(fold-right (lambda (x l)\n           (if (odd? x) (cons x l) l))\n           '()\n           '(3 1 4 1 5 9 2 6 5))\n          => (3 1 1 5 9 5)") (example "(fold-right cons '(q) '(a b c))\n         => (a b c q)") (example "(fold-right + 0 '(1 2 3) '(4 5 6))\n         => 21")) (description "<p>The fold-right procedure iterates the combine procedure over the elements of the lists from right to left and an accumulator value, starting with an accumulator value of nil.</p> <p>More specifically, fold-right returns nil if the lists are empty. If they are not empty, combine is first applied to the respective last elements of the lists in order and nil.</p> <p>The result becomes the new accumulator value, and combine is applied to the respective previous elements of the lists and the new accumulator value.</p> <p>This step is repeated until the beginning of the list is reached; then the accumulator value is returned.</p> <p>Proc is always called in the same dynamic environment as fold-right itself.</p> ") (form "(fold-right combine nil list1 list2 ...listn)") (pre-condition "The lists should all have the same length. Combine must be a procedure. It should accept one more argument than there are lists and return a single value. Combine should not mutate the list arguments.") (todo "r6rs compatible") (returns "accumulated pair") (title "fold-right")) ((kind "manual-page") (examples (example "(remp even? '(3 1 4 1 5 9 2 6 5)) => (3 1 1 5 9 5)")) (description "The remp procedure applies proc to each element of list and returns a list of the elements of list for which proc returned #f. ") (pre-condition "Proc should accept one argument and return a single value. Proc should not mutate list.") (returns "The remp procedure applies proc to each element of list and returns a list of the elements of list for which proc returned #f.") (title "remp") (form (remp pred l))) ((kind "manual-page") (parameters (parameter "proc" "Proc should accept one argument and return a single value. Proc should not mutate list.")) (examples (example "(filter even? '(3 1 4 1 5 9 2 6)) => (4 2 6)")) (description "<p>The filter procedure applies proc to each element of list and returns a list of the elements of list for which proc returned a true value.</p> <p>The elements of the result list(s) are in the same order as they appear in the input list.</p> ") (returns "returns a list of the elements of list for which proc returned a true value.") (form "(filter proc list)") (title "filter")) ((kind "manual-page") (examples (example "(find even? '(3 1 4 1 5 9)) => 4") (example "(find even? '(3 1 5 1 5 9)) => #f")) (description "<p>The find procedure applies proc to the elements of list in order. If proc returns a true value for an element, find immediately returns that element. If proc returns #f for all elements of the list, find returns #f.</p> ") (pre-condition "Proc should accept one argument and return a single value. Proc should not mutate list.") (returns "The find procedure applies proc to the elements of list in order. If proc returns a true value for an element, find immediately returns that element. If proc returns #f for all elements of the list, find returns #f.") (title "find") (form (find pred lst))) ((kind "manual-page") (examples (example "(assv 5 '((2 3) (5 7) (11 13))) => (5 7)")) (description "<p>Find the first pair in alist whose car field satisfies a given condition, and returns that pair without traversing alist further. If no pair in alist satisfies the condition, then #f is returned.</p> <p>The assoc procedure uses equal? to compare obj with the car fields of the pairs in alist, while assv uses eqv? and assq uses eq?.</p> ") (pre-condition "Alist (for \"association list\") should be a list of pairs. Proc should accept one argument and return a single value. Proc should not mutate alist.") (title "assv") (form (assv obj alist))) ((kind "manual-page") (examples (example "(assoc (list 'a) '(((a)) ((b)) ((c)))) => ((a))")) (description "<p>Find the first pair in alist whose car field satisfies a given condition, and returns that pair without traversing alist further. If no pair in alist satisfies the condition, then #f is returned.</p> <p>The assoc procedure uses equal? to compare obj with the car fields of the pairs in alist, while assv uses eqv? and assq uses eq?.</p> ") (pre-condition "Alist (for \"association list\") should be a list of pairs. Proc should accept one argument and return a single value. Proc should not mutate alist.") (title "assoc") (form (assoc obj alist))) ((kind "manual-section") (section-title "Control structures.") (section-body "R6RS library Chapter 5.")) ((kind "manual-page") (examples (example "<pre>(do ((vec (make-vector 5))\n           (i 0 (+ i 1)))\n           ((= i 5) vec)\n             (vector-set! vec i i)) =>  #(0 1 2 3 4)</pre>") (example "<pre>(let ((x '(1 3 5 7 9)))\n           (do ((x x (cdr x))\n             (sum 0 (+ sum (car x))))\n             ((null? x) sum)))</pre>")) (description "<p>The [init] expressions are evaluated (in some unspecified order), the [variable]s are bound to fresh locations, the results of the [init] expressions are stored in the bindings of the [variable]s, and then the iteration phase begins.</p> <p>Each iteration begins by evaluating [test]; if the result is #f, then the [command]s are evaluated in order for effect, the [step] expressions are evaluated in some unspecified order, the [variable]s are bound to fresh locations holding the results, and the next iteration begins.</p> <p>If [test] evaluates to a true value, the [expression]s are evaluated from left to right and the values of the last [expression] are returned.</p> <p>If no [expression]s are present, then the do expression returns unspecified values.</p> <p>The regionof the binding of a [variable] consists of the entire do expression except for the [init]s.</p> <p>A [step] may be omitted, in which case the effect is the same as if ([variable] [init] [variable]) had been written instead of ([variable] [init]).</p> ") (form "(do (([variable1] [init1] [step1]) ...) ([test] [expression] ...) [command] ...)") (title "do")) ((kind "manual-page") (description "Evaluates test. If it yields false value, body … are evaluated sequentially, and the result(s) of the last evaluation is(are) returned. Otherwise, unspecified value is returned. ") (form "(unless test body ...)") (title "unless")) ((kind "manual-page") (description "Evaluates test. If it yields true value, body … are evaluated sequentially, and the result(s) of the last evaluation is(are) returned. Otherwise, unspecified value is returned. ") (form "(when test body ...)") (title "when")) ((kind "manual-section") (section-title "Exceptions and conditionsI/O.") (section-body "R6RS library Chapter 7.")) ((kind "manual-page") (description "Raises a non-continuable exception by invoking the current exception handler on obj. ") (form "(raise obj)") (title "raise")) ((kind "manual-page") (description "Returns the results of invoking thunk. Handler is installed as the current exception handler for the dynamic extent (as determined by dynamic-wind) of the invocation of thunk. ") (pre-condition "Handler must be a procedure and should accept one argument. Thunk must be a procedure that accepts zero arguments.") (returns "the results of invoking thunk.") (form "(with-exception-handler handler thunk)") (title "with-exception-handler")) ((kind "manual-page") (description "<p>(guard ([variable] syntax</p> <p>[cond clause1] [cond clause2] ...)</p> <p>[body])</p> <p>=> auxiliary syntax</p> <p>else auxiliary syntax</p> <p>Semantics: Evaluating a guard form evaluates [body] with an exception handler that binds the raised object to [variable] and within the scope of that binding evaluates the clauses as if they were the clauses of a cond expression. </p> <p>That implicit cond expression is evaluated with the continuation and dynamic environment of the guard expression. </p> <p>If every [cond clause]'s [test] evaluates to #f and there is no else clause, then raise is re-invoked on the raised object within the dynamic environment of the original call to raise except that the current exception handler is that of the guard expression.</p> ") (form "(guard ([variable] [cond clause1] [cond clause2] ...)") (title "guard")) ((kind "manual-page") (description "<p>Raises a continuable exception by invoking the current exception handler on obj.</p> <p>The handler is called with a continuation that is equivalent to the continuation of the call to raise-continuable, with these two exceptions:</p> <p>(1) the current exception handler is the one that was in place when the handler being called was installed, and (2) if the handler being called returns, then it will again become the current exception handler. </p> <p>If the handler returns, the values it returns become the values returned by the call to raise-continuable.</p> ") (form "(raise-continuable obj)") (title "raise-continuable")) ((kind "manual-section") (section-title "I/O.") (section-body "R6RS library Chapter 8.")) ((kind "manual-page") (description "Reads an external representation from textual-input-port and returns the datum it represents. ") (form "(read) (read textual-input-port)") (returns "datum") (title "read")) ((kind "manual-page") (description "Returns an output port for the named file. ") (form "(open-file-output-port filename)") (returns "An output port for the named file.") (title "open-file-output-port")) ((kind "manual-page") (description "Returns an input port for the named file. ") (form "(open-file-input-port filename)") (returns "An input port for the named file.") (title "open-file-input-port")) ((kind "manual-page") (description "Closes input-port or output-port, respectively. ") (form "(close-input-port input-port)") (returns "unspecified") (title "close-input-port")) ((kind "manual-page") (description "Returns a fresh binary input port connected to standard input. Whether the port supports the port-position and set-port-position! operations is implementation-dependent. ") (form "(standard-input-port)") (returns "A fresh binary input port connected to standard input. Whether the port supports the port-position and set-port-position! operations is implementation-dependent.") (title "standard-input-port")) ((kind "manual-page") (description "<p>Reads from binary-input-port, blocking as necessary, until count bytes are available from binary-input-port or until an end of file is reached.</p> <p>If count bytes are available before an end of file, get-bytevector-n returns a bytevector of size count. If fewer bytes are available before an end of file, get-bytevector-n returns a bytevector containing those bytes.</p> <p>In either case, the input port is updated to point just past the bytes read.</p> <p>If an end of file is reached before any bytes are available, get-bytevector-n returns the end-of-file object. </p> ") (pre-condition "Count must be an exact, non-negative integer object representing the number of bytes to be read.") (form "(get-bytevector-n binary-input-port count)") (returns "bytevector") (title "get-bytevector-n")) ((kind "manual-page") (description "Returns the end-of-file object. ") (form "(eof-object)") (returns "the end-of-file object.") (title "eof-object")) ((kind "manual-page") (description "<p>Returns a new textual port with the specified transcoder.</p> <p>Otherwise the new textual port's state is largely the same as that of binary-port.</p> <p>If binary-port is an input port, the new textual port will be an input port and will transcode the bytes that have not yet been read from binary-port. If binary-port is an output port, the new textual port will be an output port and will transcode output characters into bytes that are written to the byte sink represented by binary-port.</p> ") (form "(transcoded-port binary-port transcoder)") (returns "A new textual port with the specified transcoder.") (title "transcoded-port")) ((kind "manual-page") (description "Predefined codecs for the UTF-8 encoding schemes. ") (form "(utf-8-codec)") (returns "Predefined codecs for the UTF-8 encoding schemes.") (title "utf-8-codec")) ((kind "manual-page") (description "Returns transcoder with the behavior specified by its arguments. ") (form "(make-transcoder codec)") (returns "transcoder with the behavior specified by its arguments.") (title "make-transcoder")) ((kind "manual-page") (description "<p>Reads from binary-input-port, blocking as necessary, until a byte is available from binary-input-port or until an end of file is reached.</p> <p>If a byte becomes available, get-u8 returns the byte as an octet and updates binary-input-port to point just past that byte. If no input byte is seen before an end of file is reached, the end-of-file object is returned.</p> ") (form "(get-u8 binary-input-port)") (returns "a byte") (title "get-u8")) ((kind "manual-page") (description "<p>Note. This procedure is not implementednot all specification.</p> <p>Returns a newly created binary input port whose byte source is an arbitrary algorithm represented by the read! procedure.</p> <p>Id must be a string naming the new port, provided for informational purposes only. Read! must be a procedure and should behave as specified below; it will be called by operations that perform binary input.</p> <p>Each of the remaining arguments may be #f; if any of those arguments is not #f, it must be a procedure and should behave as specified below.</p> <p>(read! bytevector start count)</p> <p>Start will be a non-negative exact integer object, count will be a positive exact integer object, and bytevector will be a bytevector whose length is at least start + count.</p> <p>The read! procedure should obtain up to count bytes from the byte source, and should write those bytes into bytevector starting at index start.</p> <p>The read! procedure should return an exact integer object.</p> <p>This integer object should represent the number of bytes that it has read. To indicate an end of file, the read! procedure should write no bytes and return 0.</p> <p>(get-position)</p> <p>The get-position procedure (if supplied) should return an exact integer object representing the current position of the input port.</p> <p>If not supplied, the custom port will not support the port-position operation.</p> <p>(set-position! pos)</p> <p>Pos will be a non-negative exact integer object. The set-position! procedure (if supplied) should set the position of the input port to pos.</p> <p>If not supplied, the custom port will not support the set-port-position! operation.</p> <p>(close)</p> <p>The close procedure (if supplied) should perform any actions that are necessary when the input port is closed.</p> ") (form "(make-custom-binary-input-port id read! procedure get-position set-position! close)") (returns "A newly created binary input port whose byte source is an arbitrary algorithm represented by the read! procedure.") (title "make-custom-binary-input-port")) ((kind "manual-page") (description "Returns default textual ports for regular error output. Normally, this port is associated with standard error. ") (form "(current-error-port)") (returns "Default textual ports for regular error output. Normally, this port is associated with standard error.") (title "current-error-port")) ((kind "manual-page") (description "Writes the external representation of obj to textual-output-port. The write procedure operates in the same way as put-datum. If textual-output-port is omitted, it defaults to the value returned by current-output-port. ") (form "(write obj &optional textual-output-port)") (returns "unspecified") (title "write")) ((kind "manual-page") (description "Returns #t if obj is the end-of-file object, #f otherwise. ") (form "(eof-object? obj)") (returns "#t if obj is the end-of-file object, #f otherwise.") (title "eof-object?")) ((kind "manual-page") (description "<p>Reads from textual-input-port, blocking as necessary until a character is available from textual-input-port, or the data that are available cannot be the prefix of any valid encoding, or an end of file is reached.</p> <p>If a complete character is available before the next end of file, read-char returns that character, and updates the input port to point past that character. If an end of file is reached before any data are read, read-char returns the end-of-file object. If textual-input-port is omitted, it defaults to the value returned by current-input-port.</p> ") (form "(read-char &optional textual-input-port)") (returns "character") (title "read-char")) ((kind "manual-page") (description "Returns a textual input port whose characters are drawn from string. ") (form "(open-string-input-port string)") (returns "A textual input port whose characters are drawn from string.") (title "open-string-input-port")) ((kind "manual-page") (description "used internal ") (title "set-current-input-port!") (form (set-current-input-port!))) ((kind "manual-page") (description "used internal ") (title "set-current-output-port!") (form (set-current-output-port!))) ((kind "manual-page") (description "Opens filename for output, with empty file options, and returns the obtained port. ") (form "(open-output-file filename)") (returns "Opens filename for output, with empty file options, and returns the obtained port.") (title "open-output-file")) ((kind "manual-page") (description "Returns a default textual port for input. Normally, this default port is associated with standard input, but can be dynamically re-assigned using the with-input-from-file procedure ") (form "(current-input-port)") (returns "A default textual port for input. Normally, this default port is associated with standard input, but can be dynamically re-assigned using the with-input-from-file procedure") (title "current-input-port")) ((kind "manual-page") (description "Returns a default textual port for output. Normally, this default port is associated with standard output, but can be dynamically re-assigned using the with-output-from-file procedure ") (form "(current-output-port)") (returns "A default textual port for output. Normally, this default port is associated with standard output, but can be dynamically re-assigned using the with-output-from-file procedure") (title "current-output-port")) ((kind "manual-page") (description "Closes output-port. ") (form "(close-output-port output-port)") (returns "unspecified") (title "close-output-port")) ((kind "manual-page") (description "<p>Open the file named by filename for output, with no specified file options, and call proc with the obtained port as an argument.</p> <p>If proc returns, the port is closed automatically and the values returned by proc are returned. If proc does not return, the port is not closed automatically, unless it is possible to prove that the port will never again be used for an I/O operation.</p> ") (pre-condition "Proc should accept one argument.") (returns "the values returned by proc.") (title "call-with-output-file") (form (call-with-output-file filename proc))) ((kind "manual-page") (description "<p>Open the file named by filename for input, with no specified file options, and call proc with the obtained port as an argument.</p> <p>If proc returns, the port is closed automatically and the values returned by proc are returned. If proc does not return, the port is not closed automatically, unless it is possible to prove that the port will never again be used for an I/O operation.</p> ") (pre-condition "Proc should accept one argument.") (returns "the values returned by proc.") (title "call-with-input-file") (form (call-with-input-file filename proc))) ((kind "manual-page") (description "<p>Returns two values: a textual output port and an extraction procedure.</p> <p>The output port accumulates the characters written to it for later extraction by the procedure.</p> <p>The extraction procedure takes no arguments.</p> <p>When called, it returns a string consisting of all of the port's accumulated characters (regardless of the current position),removes the accumulated characters from the port, and resetsthe port's position</p> ") (returns "string-output-port, extraction procedure") (title "open-string-output-port") (form (open-string-output-port))) ((kind "manual-page") (parameters (parameter "proc" "proc must accept one argument")) (description "<p>Creates a textual output port that accumulates the characters written to it and calls proc with that output port as an argument.</p> <p>Whenever proc returns, a string consisting of all of the port's accumulated characters (regardless of the port's current position) is returned and the port is closed.</p> ") (returns "accumulated characters as string") (title "call-with-string-output-port") (form (call-with-string-output-port proc))) ((kind "manual-page") (parameters (parameter "proc" "proc must accept one argument")) (description "<p>Creates an output port that accumulates the bytes written to it and calls proc with that output port as an argument.</p> <p>Whenever proc returns, a bytevector consisting of all of the port's accumulated bytes (regardless of the port’s currentposition) is returned and the port is closed.</p> ") (returns "accumulated bytes as bytevector") (title "call-with-bytevector-output-port") (form (call-with-bytevector-output-port proc transcoder))) ((kind "manual-page") (parameters (parameter "transcoder" "transcoder")) (description "<p>Returns two values: an output port and an extraction procedure.</p> <p>The output port accumulates the bytes written to it for later extraction by the procedure.</p> <p>If transcoder is a transcoder, it becomes the transcoder associated with the port. If maybe-transcoder is #f or absent, the port will be a binary port and will support the port-position and set-port-position! operations.</p> <p>The extraction procedure takes no arguments. When called, it returns a bytevector consisting of all the port's accumulated bytes (regardless of the port’s current position), removes the accumulated bytes from the port, and resets the port's position.</p> ") (returns "bytevector-output-port and extraction procedure") (todo "when transcoder is empty or #f") (title "open-bytevector-output-port") (form (open-bytevector-output-port transcoder))) ((kind "manual-page") (parameters (parameter "bv" "bytevector") (parameter "proc" "proc must accept one argument")) (description "Applies proc element-wise to the elements of the bytevector for its side effects, in order from the first elements to the last. ") (returns "unspecified") (title "bytevector-for-each") (form (bytevector-for-each bv proc))) ((kind "manual-page") (parameters (parameter "obj" "object to write.") (parameter "textual-output-port" "writes obj to textual-output-port")) (description "<p><p>Writes a representation of obj to the given textual-output-port.</p></p> <p>Strings that appear in the written representation are not enclosed in doublequotes, and no characters are escaped within those strings.</p> <p>Character objects appear in the representation as if written by write-char instead of by write.</p> <p>The textual-output-port argument may be omitted, in which case it defaults to the value returned by current-output-port.</p> ") (form "(display obj) or (display obj textual-output-port)") (returns "unspecified") (title "display")) ((kind "manual-page") (parameters (parameter "textual-output-port" "port to write")) (description "<p>This is equivalent to using write-char to write #\\linefeed to textual-output-port. If textual-output-port is omitted, it defaults to the value returned by current-output-port.</p> ") (returns "unspecified") (todo "textual-output-port") (title "newline") (form (newline))) ((kind "manual-section") (section-title "File system.") (section-body "R6RS library Chapter 9. ")) ((kind "manual-page") (description "Returns #t if the named file exists at the time the procedure is called, #f otherwise. ") (form "(file-exists? filename)") (returns "Returns #t if the named file exists at the time the procedure is called, #f otherwise.") (title "file-exists?")) ((kind "manual-section") (section-title "Hashtables.") (section-body "R6RS library Chapter 13. ")) ((kind "manual-page") (description "<p>Returns a newly allocated mutable hashtable that accepts arbitrary objects as keys, and compares those keys with eq?. If an argument is given, the initial capacity of the hashtable is set to approximately k elements.</p> ") (form "(make-eq-hashtable) (make-eq-hashtable k)") (returns "A newly allocated mutable hashtable that accepts arbitrary objects as keys, and compares those keys with eq?. If an argument is given, the initial capacity of the hashtable is set to approximately k elements.") (title "make-eq-hashtable")) ((kind "manual-page") (description "Changes hashtable to associate key with obj, adding a new association or replacing any existing association for key. ") (form "(hashtable-set! hashtable key obj)") (returns "unspecified") (title "hash-table-set!")) ((kind "manual-page") (description "Returns the value in hashtable associated with key. If hashtable does not contain an association for key, default is returned. ") (form "(hashtable-ref hashtable key default)") (returns "the value in hashtable associated with key. If hashtable does not contain an association for key, default is returned.") (title "hash-table-ref")) ((kind "manual-page") (description "(not implmented) Returns a vector of all keys in hashtable. The order of the vector is unspecified. ") (form "(hashtable-keys hashtable)") (returns "A vector of all keys in hashtable. The order of the vector is unspecified.") (title "hash-table-keys")) ((kind "manual-section") (section-title "Eval.") (section-body "R6RS library Chapter 16. ")) ((kind "manual-page") (description "<p>Evaluates expression in the specified environment and returns its value.</p> <p>Note that currently the environment argument is ignored.</p> ") (returns "result") (form "(eval expression environment)") (title "eval")) ((kind "manual-section") (section-title "Mutable pairs.") (section-body "R6RS library Chapter 17. ")) ((kind "manual-page") (description "Stores obj in the car field of pair. ") (returns "unspecified") (form "(set-car! pair obj)") (title "set-car!")) ((kind "manual-page") (description "Stores obj in the cdr field of pair. ") (returns "unspecified") (form "(set-cdr! pair obj)") (title "set-cdr!")) ((kind "manual-section") (section-title "Regular expression.") (section-body "Regular expression is implmented with Oniguruma library.<br>")) ((kind "manual-page") (parameters (parameter "regexp" "A regular expression object.") (parameter "string" "String matched by regexp.")) (examples (example "(rxmatch #/123/ \"12\") => #f") (example "(rxmatch #/\\d+/ \"a345a\") => [regmatch]")) (cross-references (internal-references "Regular expression." "regexp")) (description "<p>Regexp is a regular expression object. A string string is matched by regexp. If it matches, the function returns a [regmatch] object. Otherwise it returns #f.</p> <p>You can use (#/regexp/ string) style instead of (rxmatch #/regexp/ string).</p> ") (returns "If it matches, the function returns a [regmatch] object. Otherwise it returns #f.") (form "(rxmatch regexp string)") (title "rxmatch")) ((kind "manual-page") (parameters (parameter "regexp" "A regular expression object.") (parameter "string" "String matched by regexp.")) (examples (example "(#/123/ \"12\") => #f") (example "(#/\\d+/ \"a345a\") => [regmatch]")) (cross-references (internal-references "Regular expression." "rxmatch")) (description "Regexp is a regular expression object. A string string is matched by regexp. If it matches, the function returns a [regmatch] object. Otherwise it returns #f. ") (returns "If it matches, the function returns a [regmatch] object. Otherwise it returns #f.") (form "(regexp string)") (title "regexp")) ((kind "manual-page") (examples (example "(regexp? #/abc/) => #t") (example "(regexp? \"abc\")  => #f")) (description "Returns #t if obj is a regexp object. ") (form "(regexp? obj)") (returns "#t if obj is a regexp object.") (title "regexp?")) ((kind "manual-page") (examples (example "(regexp->string #/abc/) => \"abc\"")) (description "Returns a source string describing the regexp regexp. The returned string is immutable. ") (returns "S source string describing the regexp regexp. The returned string is immutable.") (form "(regexp->string regexp)") (title "regexp->string")) ((kind "manual-page") (parameters (parameter "match" "[regmatch] object returned by rxmatch") (parameter "i" "index")) (examples (example "(rxmatch-start (#/\\d+/ \"aaaa\")) => #f") (example "(rxmatch-start (rxmatch #/(\\d+)(a)/ \"a345a\") 2) => 4")) (description "<p>If i equals to zero, the functions return start of entire match. With positive integer I, it returns those of I-th submatches.</p> <p>It is an error to pass other values to I. It is allowed to pass #f to match for convenience. The functions return #f in such case.</p> ") (returns "I-th submatches.") (form "(rxmatch-start match &optional (i 0))") (title "rxmatch-start")) ((kind "manual-page") (parameters (parameter "match" "[regmatch] object returned by rxmatch") (parameter "i" "index")) (examples (example "(rxmatch #/\\d+/ \"a345a\") => 4")) (description "<p>If i equals to zero, the functions return end of entire match. With positive integer I, it returns those of I-th submatches.</p> <p>It is an error to pass other values to I. It is allowed to pass #f to match for convenience. The functions return #f in such case.</p> ") (returns "I-th submatches.") (form "(rxmatch-end match &optional (i 0))") (title "rxmatch-end")) ((kind "manual-page") (parameters (parameter "match" "[regmatch] object returned by rxmatch") (parameter "i" "index")) (examples (example "(rxmatch-substring (#/\\d+/ \"a345a\")) => \"345\"")) (description "<p>If i equals to zero, the functions return substring of entire match. With positive integer I, it returns those of I-th submatches.</p> <p>It is an error to pass other values to I. It is allowed to pass #f to match for convenience. The functions return #f in such case.</p> ") (returns "I-th submatches.") (form "(rxmatch-substring match &optional (i 0))") (title "rxmatch-substring")) ((kind "manual-page") (examples (example "(rxmatch-after (#/abc/ \"123abcdef\")) => \"def\"")) (description "Returns substring of the input string after match. If optional argument is given, the i-th submatch is used (0-th submatch is the entire match). ") (returns "Substring of the input string after match.") (form "(rxmatch-after match &optional (i 0))") (title "rxmatch-after")) ((kind "manual-page") (examples (example "(rxmatch-before (#/abc/ \"123abcdef\")) => \"123\"")) (description "Returns substring of the input string before match. If optional argument is given, the i-th submatch is used (0-th submatch is the entire match). ") (returns "Substring of the input string before match.") (form "(rxmatch-before match &optional (i 0))") (title "rxmatch-before")) ((kind "manual-page") (examples (example "((#/abc/ \"123abcdef\") 0) => \"abc\"")) (cross-references (internal-references "Regular expression." "rxmatch-substring")) (description "Works same as (rxmatch-substring regmatch index), ") (form "(regmatch &optional index)") (title "regmatch")) ((kind "manual-page") (examples (example "((#/abc/ \"123abcdef\") 'before) => \"123\"")) (cross-references (internal-references "Regular expression." "rxmatch-before")) (description "Works same as (rxmatch-before regmatch) ") (form "(regmatch 'before &optional index)") (title "regmatch")) ((kind "manual-page") (examples (example "((#/abc/ \"123abcdef\") 'after) => \"def\"")) (cross-references (internal-references "Regular expression." "rxmatch-after")) (description "Works same as (rxmatch-after regmatch) ") (form "(regmatch 'after &optional index)") (title "regmatch")) ((kind "manual-page") (examples (example "(regexp-replace #/abc/ \"123abc456\" \"ABC\") => \"123ABC456\"")) (description "Replaces the part of string that matched to regexp for substitution. Just replaces the first match of regexp. ") (form "(regexp-replace regexp string substitution)") (returns "replaced string") (title "regexp-replace")) ((kind "manual-page") (description "Replaces the part of string that matched to regexp for substitution. Repeats the replacing throughout entire string. ") (form "(regexp-replace-all regexp string substitution)") (returns "replaced string") (title "regexp-replace-all")) ((kind "manual-page") (examples (example "(string->regexp \"abc\") #/abc")) (description "Takes string as a regexp specification, and constructs [regexp] object. ") (form "(string->regexp string)") (returns "[regexp] object") (title "string->regexp")) ((kind "manual-section") (section-title "System interfaces.") (section-body "")) ((kind "manual-page") (examples (example "(sys-getenv \"QUERY_STRING\")")) (description "Returns the value of the environment variable name as a string, or #f if the environment variable is not defined. ") (form "(sys-getenv name)") (returns "The value of the environment variable name as a string, or #f if the environment variable is not defined.") (title "sys-getenv")) ((kind "manual-page") (description "Returns a list of strings of the directory entries. ") (form "(sys-readdir path)") (returns "A list of strings of the directory entries.") (title "sys-readdir")) ((kind "manual-page") (description "get-timeofday ") (form "(get-timeofday)") (returns "(get-timeofday)") (title "get-timeofday")) ((kind "manual-section") (section-title "Generic.") (section-body "")) ((kind "manual-page") (description "Same as (let ((var val)) body ...) ") (form "(let1 var val body ...)") (title "let1")) ((kind "manual-page") (examples (example "(gensym) => G100")) (description "Returns a new symbol. ") (form "(gensym)") (returns "A new symbol.") (title "gensym")) ((kind "manual-page") (examples (example "(digit->integer #\\4) => 4") (example "(digit->integer #\\e 16) => 14") (example "(digit->integer #\\9 8) => #f")) (description "If given character char is a valid digit character in radix radix number, the corresponding integer is returned. Otherwise #f is returned. ") (form "(digit->integer char &optional (radix 10))") (returns "If given character char is a valid digit character in radix radix number, the corresponding integer is returned. Otherwise #f is returned.") (title "digit->integer")) ((kind "manual-page") (description "Writes a representation of obj to the current output port and (newline) Strings that appear in the written representation are not enclosed in doublequotes, and no characters are escaped within those strings. Character objects appear in the representation as if written by write-char instead of by write. ") (returns "unspecified values") (title "print") (form (print obj))) ((kind "manual-page") (parameters (parameter "l" "list") (parameter "proc" "should accept as many arguments as there are lists and return a single value.")) (description "The map1 procedure applies proc element-wise to the elements of the list and returns a list of the results, in order. ") (returns "a list of the results") (form "(map1 proc l)") (title "map1")) ((kind "manual-page") (description "Returns the cdr of first pair whose car fields satisfies a given key. ") (returns "Returns the cdr of first pair whose car fields satisfies a given key.") (title "assoc-ref") (form (assoc-ref lst key))) ((kind "manual-page") (description "Reads one line (a sequence of characters terminated by newline or EOF) from port and returns a string. ") (returns "line as a string") (title "read-line") (form (read-line . port))) ((kind "manual-page") (cross-references (internal-references "R6RS" "call-with-output-file")) (description "Same as (call-with-output-file path (lambda (port) (display content obj))) ") (returns "unspecified.") (title "write-to-file") (form (write-to-file path content))) ((kind "manual-page") (description "Read string from a file filename. ") (returns "whole file content as string") (title "file->string") (form (file->string filename))) ((kind "manual-page") (description "<p>Convenient string I/O procedure.</p> <pre>(define (call-with-string-io str proc)<br> (receive (out get-string) (open-string-output-port)<br> (let1 in (open-string-input-port str)<br> (proc in out)<br> (get-string))))</pre> ") (returns "output-string") (title "call-with-string-io") (form (call-with-string-io str proc))) ((kind "manual-page") (parameters (parameter "proc" "proc must accept one argument")) (description "Creates a textual input port from string str and calls proc with that input port as an argument. ") (returns "values proc returns") (title "call-with-string-input-port") (form (call-with-string-input-port str proc))) ((kind "manual-section") (section-title "CGI.") (section-body "Note this library will go away once it is switched to the new CGI library.")) ((kind "manual-page") (description "Escape some not safe characters. ") (returns "escaped string") (title "cgi-escape") (form (cgi-escape text))) ((kind "manual-page") (description "Apply \"% encode\" to string and return the result. Assumes input is UTF-8. ") (returns "encoded string") (title "cgi-encode") (form (cgi-encode text))) ((kind "manual-page") (examples (example "(receive (get-parameter get-request-method) (cgi-init) ...)")) (description "Initialize CGI library and returns get-parameter and get-request-method procedures. ") (returns "get-parameter and get-request-method procedures as multiple values.") (title "cgi-init") (form (cgi-init))) ((kind "manual-page") (description "Outputs HTTP header \"Status: 200 OK\\nContent-type: text/html; charset=utf-8\\n\" ") (returns "unspecified") (title "cgi-header") (form (cgi-header))) ((kind "manual-page") (parameters (parameter "url" "redirect URL")) (description "Outputs HTTP header \"Status: 302 Moved Temporarily\\nLocation: [url]\\n\\n\" ") (returns "unspecified") (title "cgi-moved-header") (form (cgi-moved-header url))) ((kind "manual-page") (description "used internal ") (title "cgi-parse-query-string") (form (cgi-parse-query-string input))) ((kind "manual-page") (description "Apply \"% decode\" to string and return the result. Assumes input is UTF-8. ") (returns "decoded string") (title "cgi-decode") (form (cgi-decode s))) ((kind "manual-section") (section-title "SRFI-1 List library.") (section-body "") (section-id "srfi-1")) ((kind "manual-page") (cross-references (reference "SRFI-1" "SRFI-1 List Library" "http://srfi.schemers.org/srfi-1/srfi-1.html")) (description "Synonym for car ") (form "(first pair)") (returns "(car pair)") (title "first")) ((kind "manual-page") (cross-references (reference "SRFI-1" "SRFI-1 List Library" "http://srfi.schemers.org/srfi-1/srfi-1.html")) (description "Synonym for cadr ") (returns "(cadr pair)") (title "second") (form (second pair))) ((kind "manual-page") (cross-references (reference "SRFI-1" "SRFI-1 List Library" "http://srfi.schemers.org/srfi-1/srfi-1.html")) (description "Synonym for caddr ") (returns "(caddr pair)") (title "third") (form (third pair))) ((kind "manual-page") (cross-references (reference "SRFI-1" "SRFI-1 List Library" "http://srfi.schemers.org/srfi-1/srfi-1.html")) (description "Synonym for cadddr ") (returns "(cadddr pair)") (title "fourth") (form (fourth pair))) ((kind "manual-section") (section-title "SRFI-8 Binding to multiple values.") (section-body "")) ((kind "manual-page") (examples (example "(receive (a b c) (values 1 2 3) (+ a b c)) => 6")) (description "<p>This is the way to receive multiple values.</p> <p>Formals can be a (maybe-improper) list of symbols.</p> <p>Expression is evaluated, and the returned value(s) are bound to formals like the binding of lambda formals, then body ... are evaluated.</p> ") (form "(receive formals expression body ...)") (returns "The results of the last expression in the body are the values of the receive-expression.") (title "receive")) ((kind "manual-section") (section-title "SRFI-28 Basic format strings.") (section-body "")) ((kind "manual-page") (examples (example "(format #f \"apple is ~a\" \"sweet\") => \"apple is sweet\"") (example "(call-with-output-string (lambda (out) (format out \"apple is ~a\" \"sweet\"))) => \"apple is sweet\"")) (description "<p>Format arg ... according to string.</p> <p>port specifies the destination;</p> <p>if it is an output port, the formatted result is written to it;</p> <p>if it is #t, the result is written to the current output port;</p> <p>if it is #f, the formatted result is returned as a string.</p> <p>Port can be omitted, as SRFI-28 format; it has the same effects as giving #f to the port.</p> <p>string is a string that contains format directives.</p> <p>A format directive is a character sequence begins with tilda, `~', and ends with some specific characters.</p> <p>The rest of string is copied to the output as is.</p> <p>Currently supported directive is ~a/~A (The corresponding argument is printed by display.), ~s/~S (The corresponding argument is printed by write.)</p> ") (form "(format string arg ...) (format port string arg ...)") (returns "unspecified or string") (title "format")))