<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><title>Mosh User&#39;s Reference</title> <link href="manual.css" rel="stylesheet" type="text/css" /></head> <body class="manual-body"><a name="MANUAL-TOP"></a> <table border="0px" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td width="33%" align="left" valign="top"><font size="2"><span><a href="./manual.html#MANUAL-INDEX">Manual alphabetic index</a></span></font></td> <td width="34%" align="center" valign="top"><font size="2"></font></td> <td width="33%" align="right" valign="top"><font size="2"><span class="manual-top-banner-when-generated">Generated: Thursday, June 12, 2008  by Higepon using  <a href="http://www.cs.aau.dk/~normark/schemedoc/">schemedoc</a></span></font></td></tr></tbody></table> <h1 class="manual-title">Mosh User&#39;s Reference</h1> <p></p>   <p></p> <a name="MANUAL-ABSTRACT"></a> <div class="manual-abstract"><div><p>This is a reference manual of  <a href="http://code.google.com/p/mosh-scheme/">Mosh</a> , an R6RS Scheme implementation.</p> <p>This manual is for version 0.0.3.</p> <p>On version 0.0.3, all procedures defined at top level. This problem will be fixed version 0.0.4 or later.</p></div></div> <p></p> <a name="MANUAL-TOC"></a> <div class="manual-table-of-contents-header">Table of Contents</div> <div style="margin-left:12px;"><div><table border="0"><tbody><tr><td width="280" valign="top"><a href="#SECTION1"><font size="2">1.  Base library.</font></a></td> <td width="280" valign="top"><a href="#SECTION7"><font size="2">7.  File system.</font></a></td> <td width="280" valign="top"><a href="#SECTION13"><font size="2">13.  Generic.</font></a></td></tr> <tr><td width="280" valign="top"><a href="#SECTION2"><font size="2">2.  Bytevectors.</font></a></td> <td width="280" valign="top"><a href="#SECTION8"><font size="2">8.  Hashtables.</font></a></td> <td width="280" valign="top"><a href="#SECTION14"><font size="2">14.  CGI.</font></a></td></tr> <tr><td width="280" valign="top"><a href="#SECTION3"><font size="2">3.  List utilities.</font></a></td> <td width="280" valign="top"><a href="#SECTION9"><font size="2">9.  Eval.</font></a></td> <td width="280" valign="top"><a href="#SECTION15"><font size="2">15.  SRFI-1 List library.</font></a></td></tr> <tr><td width="280" valign="top"><a href="#SECTION4"><font size="2">4.  Control structures.</font></a></td> <td width="280" valign="top"><a href="#SECTION10"><font size="2">10.  Mutable pairs.</font></a></td> <td width="280" valign="top"><a href="#SECTION16"><font size="2">16.  SRFI-8 Binding to multiple values.</font></a></td></tr> <tr><td width="280" valign="top"><a href="#SECTION5"><font size="2">5.  Exceptions and conditionsI/O.</font></a></td> <td width="280" valign="top"><a href="#SECTION11"><font size="2">11.  Regular expression.</font></a></td> <td width="280" valign="top"><a href="#SECTION17"><font size="2">17.  SRFI-28 Basic format strings.</font></a></td></tr> <tr><td width="280" valign="top"><a href="#SECTION6"><font size="2">6.  I/O.</font></a></td> <td width="280" valign="top"><a href="#SECTION12"><font size="2">12.  System interfaces.</font></a></td> <td width="280" valign="top"><a href="#SECTION18"><font size="2">18.  Pattern matching.</font></a></td></tr></tbody></table></div></div> <p></p> <table class="manual-table"><tr><td width="3000px" colspan="4"></td></tr> <tr class="manual-section"><td class="manual-section" colspan="4"><a name="SECTION1"></a> <span><a href="#MANUAL-TOP"><img src="man-images/small-up.gif" title="Manual top" alt="" border="0" /></a> <img src="man-images/small-prev-blind.gif" title="" alt="" border="0" /> <a href="#SECTION2"><img src="man-images/small-next.gif" title="Next manual section" alt="" border="0" /></a></span> <br /> <span class="manual-section-number">1</span> <span class="manual-section-title">Base library.</span></td></tr> <tr><td colspan="4" class="manual-section-description">R6RS chapter 11.</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="eqv?"></a> eqv?</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(eqv? obj1 obj2)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description"><p>The eqv? procedure defines a useful equivalence relation on objects. <p>Briefly, it returns #t if obj1 and obj2 should normally be regarded as the same object and #f otherwise.</p> <p>The eqv? procedure returns #t if one of the following holds:</p> <p>Obj1 and obj2 are both booleans and are the same according to the boolean=? procedure.</p> <p>Obj1 and obj2 are both symbols and are the same according to the symbol=? procedure.</p> <p>Obj1 and obj2 are both exactnumber objects and are numerically equal.</p> <p>Obj1 and obj2 are both inexactnumber objects, are numerically equal, and yield the same results (in the sense of eqv?) when passed as arguments to any other procedure that can be defined as a finite composition of Scheme&#39;s standard arithmetic procedures.</p> <p>Obj1 and obj2 are both characters and are the same character according to the char=? procedure .</p> <p>Both obj1 and obj2 are the empty list.</p> <p>Obj1 and obj2 are objects such as pairs, vectors, bytevectors , strings, hashtables, records, ports, or hashtables  that refer to the same locations in the store.</p> <p>Obj1 and obj2 are record-type descriptors that are specified to be eqv? in library.</p> <p>The eqv? procedure returns #f if one of the following holds:</p> <p>Obj1 and obj2 are of different types.</p> <p>Obj1 and obj2 are booleans for which the boolean=? procedure returns #f.</p> <p>Obj1 and obj2 are symbols for which the symbol=? procedure returns #f.</p> <p>One of obj1 and obj2 is an exact number object but the other is an inexact number object.</p> <p>Obj1 and obj2 are rational number objects for which the = procedure returns #f.</p> <p>Obj1 and obj2 yield different results (in the sense of eqv?) when passed as arguments to any other procedure that can be defined as a finite composition of Scheme&#39;s standard arithmetic procedures.</p> <p>Obj1 and obj2 are characters for which the char=? procedure returns #f.</p> <p>One of obj1 and obj2 is the empty list, but the other is not.</p> <p>Obj1 and obj2 are objects such as pairs, vectors, bytevectors (library chapter on "Bytevectors"), strings, records (library chapter on "Records"), ports, or hashtables that refer to distinct locations.</p> <p>Obj1 and obj2 are pairs, vectors, strings, or records, or hashtables, where the applying the same accessor (i.e. car, cdr, vector-ref, string-ref, or record accessors) to both yields results for which eqv? returns #f.</p> <p>Obj1 and obj2 are procedures that would behave differently (return different values or have different side effects) for some arguments.</p> (lambda () 2))                    =>  #f </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">#t if equal</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="8">Examples</td> <td class="manual-plain-example" colspan="2">(eqv? &#39;a &#39;a)                             =>  #t</td></tr> <tr><td colspan="4" class="manual-plain-example">(eqv? &#39;a &#39;b)                             =>  #f</td></tr> <tr><td colspan="4" class="manual-plain-example">(eqv? 2 2)                               =>  #t</td></tr> <tr><td colspan="4" class="manual-plain-example">(eqv? &#39;() &#39;())                           =>  #t</td></tr> <tr><td colspan="4" class="manual-plain-example">(eqv? 100000000 100000000)               =>  #t</td></tr> <tr><td colspan="4" class="manual-plain-example">(eqv? (cons 1 2) (cons 1 2))             =>  #f</td></tr> <tr><td colspan="4" class="manual-plain-example">(eqv? (lambda () 1)</td></tr> <tr><td colspan="4" class="manual-plain-example">(eqv? #f &#39;nil)                          =>  #f</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="char>=?"></a> char>=?</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(char>=? char1 char2 char3 ...)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Impose a total ordering on the set of characters according to their Unicode scalar values. </td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="char>?"></a> char>?</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(char>? char1 char2 char3 ...)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Impose a total ordering on the set of characters according to their Unicode scalar values. </td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="char<=?"></a> char<=?</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(char<=? char1 char2 char3 ...)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Impose a total ordering on the set of characters according to their Unicode scalar values. </td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="char<?"></a> char<?</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(char&amp;lt;? char1 char2 char3 ...)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Impose a total ordering on the set of characters according to their Unicode scalar values. </td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="procedure?"></a> procedure?</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(procedure? obj)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns #t if obj is a procedure, otherwise returns #f. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">#t if obj is a procedure, otherwise returns #f.</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="4">Examples</td> <td class="manual-plain-example" colspan="2">(procedure? car)                    =>  #t</td></tr> <tr><td colspan="4" class="manual-plain-example">(procedure? &#39;car)                   =>  #f</td></tr> <tr><td colspan="4" class="manual-plain-example">(procedure? (lambda (x) (* x x)))   =>  #t</td></tr> <tr><td colspan="4" class="manual-plain-example">(procedure? &#39;(lambda (x) (* x x)))  =>  #f</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="lambda"></a> lambda</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(lambda [formals] [body])</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">A lambda expression evaluates to a procedure. <p>The environment in effect when the lambda expression is evaluated is remembered as part of the procedure.</p> <p>When the procedure is later called with some arguments, the environment in which the lambda expression was evaluated is extended by binding the variables in the parameter list to fresh locations, and the resulting argument values are stored in those locations.</p> <p>Then, the expressions in the body of the lambda expression are evaluated sequentially in the extended environment. The results of the last expression in the body are returned as the results of the procedure call.</p> </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">A procedure</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="quasiquote"></a> quasiquote</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(quasiquote [qq template])</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Quasiquote </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="1">See also</td> <td class="manual-plain-reference-role">Quasiquote</td> <td class="manual-plain-reference-anchor" colspan="2"><a class="manual-plain-external-reference" href="http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_768">quasiquote</a></td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="quote"></a> quote</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(quote [datum])</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Evaluates to the datum value represented by [datum]. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">quoted object</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="if"></a> if</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(if [test] [consequent] [alternate]) (if [test] [consequent])</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description"><p>An if expression is evaluated as follows: first, [test] is evaluated.</p> <p>If it yields a true value, then [consequent] is evaluated and its values are returned.Otherwise <alternate> is evaluated and its values are returned.</p> <p>If <test> yields #f and no [alternate] is specified, then the result of the expression is unspecified.</p> </td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="string-ref"></a> string-ref</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(string-ref string k)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns character k of string using zero-origin indexing. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">k of string using zero-origin indexing.</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">character k of string using zero-origin indexing.</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="list?"></a> list?</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(list? obj)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns #t if obj is a list, #f otherwise. By definition, all lists are chains of pairs that have finite length and are terminated by the empty list. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">#t if obj is a list, #f otherwise.</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="3">Examples</td> <td class="manual-plain-example" colspan="2">(list? &#39;(a b c)) => #t</td></tr> <tr><td colspan="4" class="manual-plain-example">(list? &#39;()) => #t</td></tr> <tr><td colspan="4" class="manual-plain-example">(list? &#39;(a . b)) => #f</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="let"></a> let</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(let [bindings] [body])</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description"><p>(let [bindings] [body])</p> <p>Syntax: [Bindings] must have the form</p> <p>  (([variable1] [init1]) ...),</p> <p>where each [init] is an expression.</p> <p>Any variable must not appear more than once in the [variable]s.</p> </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="2">Examples</td> <td class="manual-plain-example" colspan="2">(let ((x 2) (y 3))
           (* x y)) =>  6</td></tr> <tr><td colspan="4" class="manual-plain-example">(let ((x 2) (y 3))
           (let ((x 7)
             (z (+ x y)))
               (* z x)))  => 35</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="let*"></a> let*</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(let* [bindings] [body])</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description"><p>(let* [bindings] [body])</p> <p>Syntax: [Bindings] must have the form</p> <p>(([variable1] [init1]) ...),</p> <p>Semantics: The let* form is similar to let, but the [init]s are evaluated and bindings created sequentially from left to right, with the regionof each binding including the bindings to its right as well as [body].</p> <p>Thus the second [init] is evaluated in an environment in which the first binding is visible and initialized, and so on.</p> </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="1">Examples</td> <td class="manual-plain-example" colspan="2">(let ((x 2) (y 3))
           (let* ((x 7)
                 (z (+ x y)))
                   (* z x))) =>70</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="letrec"></a> letrec</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(letrec [bindings] [body])</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description"><p>(letrec [bindings] [body])</p> <p>Syntax: [Bindings] must have the form</p> <p>(([variable1] [init1]) ...),</p> <p>Any variable must not appear more than once in the [variable]s.</p> <p>Semantics: The [variable]s are bound to fresh locations, the [init]s are evaluated in the resulting environment (in some unspecified order), each [variable] is assigned to the result of the corresponding [init], the [body] is evaluated in the resulting environment, and the values of the last expression in <body> are returned.</p> <p>Each binding of a [variable] has the entire letrec expression as its region, making it possible to define mutually recursive procedures.</p> </td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="not"></a> not</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(not obj)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns #t if obj is #f, and returns #f otherwise. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">#t if obj is #f, and returns #f otherwise.</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="7">Examples</td> <td class="manual-plain-example" colspan="2">(not #t)           =>  #f</td></tr> <tr><td colspan="4" class="manual-plain-example">(not 3)            =>  #f</td></tr> <tr><td colspan="4" class="manual-plain-example">(not (list 3))     =>  #f</td></tr> <tr><td colspan="4" class="manual-plain-example">(not #f)           =>  #t</td></tr> <tr><td colspan="4" class="manual-plain-example">(not &#39;())          =>  #f</td></tr> <tr><td colspan="4" class="manual-plain-example">(not (list))       =>  #f</td></tr> <tr><td colspan="4" class="manual-plain-example">(not &#39;nil)         =>  #f</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="or"></a> or</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(or [test1] ...)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">If there are no [test]s, #f is returned. Otherwise, the [test] expressions are evaluated from left to right until a [test] returns a true value val or the last [test] is reached. <p>In the former case, the or expression returns val without evaluating the remaining expressions. In the latter case, the last expression is evaluated and its values are returned.</p> </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="4">Examples</td> <td class="manual-plain-example" colspan="2">(or (= 2 2) (> 2 1))                    =>  #t</td></tr> <tr><td colspan="4" class="manual-plain-example">(or (= 2 2) (< 2 1))                    =>  #t</td></tr> <tr><td colspan="4" class="manual-plain-example">(or #f #f #f)                           =>  #f</td></tr> <tr><td colspan="4" class="manual-plain-example">(or &#39;(b c) (/ 3 0))                     =>  (b c)</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="set!"></a> set!</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(set! [variable] [expression])</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description"><p>[Expression] is evaluated, and the resulting value is stored in the location to which [variable] is bound. </p><p>[Variable] must be bound either in some regionenclosing the set! expression or at the top level.</p> </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">unspecified</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="symbol?"></a> symbol?</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(symbol? obj)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns #t if obj is a symbol, otherwise returns #f. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">#t if obj is a symbol, otherwise returns #f.</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="vector-length"></a> vector-length</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(vector-length vector)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns the number of elements in vector as an exact integer object. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">The number of elements in vector as an exact integer object.</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="vector-ref"></a> vector-ref</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(vector-ref vector k)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns the contents of elementk of vector. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">K must be a valid index of vector.</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">The contents of elementk of vector.</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="1">Examples</td> <td class="manual-plain-example" colspan="2">(vector-ref &#39;#(1 1 2 3 5 8 13 21) 5) =>  8</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="vector-set!"></a> vector-set!</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(vector-set! vector k obj)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Stores obj in element k of vector, and returns unspecified values. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">K must be a valid index of vector.</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">unspecified</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="1">Examples</td> <td class="manual-plain-example" colspan="2"><pre>(let ((vec (vector 0 &#39;(2 2 2 2) "Anna")))
                   (vector-set! vec 1 &#39;("Sue" "Sue"))
                   vec)
               =>  #(0 ("Sue" "Sue") "Anna")</pre></td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="and"></a> and</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(and [test1] ...)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">If there are no [test]s, #t is returned. Otherwise, the [test] expressions are evaluated from left to right until a [test] returns #f or the last [test] is reached. <p>In the former case, the and expression returns #f without evaluating the remaining expressions. In the latter case, the last expression is evaluated and its values are returned.</p> </td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="apply"></a> apply</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(apply proc arg1 ... rest-args)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">The apply procedure calls proc with the elements of the list (append (list arg1 ...) rest-args) as the actual arguments. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">Rest-args must be a list. Proc should accept n arguments, where n is number of args plus the length of rest-args.</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">The apply procedure calls proc with the elements of the list (append (list arg1 ...) rest-args) as the actual arguments.</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="begin"></a> begin</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(begin [form] ...) (begin [expression] [expression] ...)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description"><p>The [begin] keyword has two different roles, depending on its context:</p> <p>It may appear as a form in a [body] , [library body] , or [top-level body], or directly nested in a begin form that appears in a body. In this case, the begin form must have the shape specified in the first header line.</p> <p>This use of begin acts as a splicing form the forms inside the [body] are spliced into the surrounding body, as if the begin wrapper were not actually present.</p> <p>A begin form in a [body] or [library body] must be non-empty if it appears after the first [expression] within the body. It may appear as an ordinary expression and must have the shape specified in the second header line.</p> <p>In this case, the [expression]s are evaluated sequentially from left to right, and the values of the last [expression] are returned. This expression type is used to sequence side effects such as assignments or input and output.</p> </td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="call-with-current-continuation"></a> call-with-current-continuation</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(call-with-current-continuation proc)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description"><p>The procedure call-with-current-continuation (which is the same as the procedure call/cc) packages the current continuation as an "escape procedure"and passes it as an argument to proc.</p> <p>The escape procedure is a Scheme procedure that, if it is later called, will abandon whatever continuation is in effect at that later time and will instead reinstate the continuation that was in effect when the escape procedure was created.</p> </td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="case"></a> case</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(case [key] [case clause1] [case clause2] ...)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description"><p>case expression is evaluated as follows.</p> <p>[Key] is evaluated and its result is compared using eqv? against the data represented by the [datum]s of each [case clause] in turn, proceeding in order from left to right through the set of clauses.</p> <p>If the result of evaluating [key] is equivalent to a datum of a [case clause], the corresponding [expression]s are evaluated from left to right and the results of the last expression in the [case clause] are returned as the results of the case expression. Otherwise, the comparison process continues.</p> <p>If the result of evaluating [key] is different from every datum in each set, then if there is an else clause its expressions are evaluated and the results of the last are the results of the case expression; otherwise the case expression returns unspecified values.</p> </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="1">Examples</td> <td class="manual-plain-example" colspan="2"><pre>(case (* 2 3)
                 ((2 3 5 7) &#39;prime)
                 ((1 4 6 8 9) &#39;composite))  =>  composite</pre></td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="cond"></a> cond</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(cond [cond clause1] [cond clause2] ...)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description"><p>A cond expression is evaluated by evaluating the [test] expressions of successive [cond clause]s in order until one of them evaluates to a true value.</p> <p>When a [test] evaluates to a true value, then the remaining [expression]s in its [cond clause] are evaluated in order, and the results of the last [expression] in the [cond clause] are returned as the results of the entire cond expression.</p> <p>If the selected [cond clause] contains only the [test] and no [expression]s, then the value of the [test] is returned as the result. If the selected [cond clause] uses the => alternate form, then the [expression] is evaluated. Its value must be a procedure.</p> <p>This procedure should accept one argument; it is called on the value of the [test] and the values returned by this procedure are returned by the cond expression.</p> <p>If all [test]s evaluate to #f, and there is no else clause, then the conditional expression returns unspecified values; if there is an else clause, then its [expression]s are evaluated, and the values of the last one are returned.</p> </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="3">Examples</td> <td class="manual-plain-example" colspan="2"><pre>(cond ((> 3 2) &#39;greater)
                ((< 3 2) &#39;less)) =>  greater</pre></td></tr> <tr><td colspan="4" class="manual-plain-example"><pre>(cond ((> 3 3) &#39;greater)
                ((< 3 3) &#39;less)
                (else &#39;equal))   =>  equal</pre></td></tr> <tr><td colspan="4" class="manual-plain-example"><pre>(cond (&#39;(1 2 3) => cadr)
                (else #f))       =>  2</pre></td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="define"></a> define</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(define [variable] [expression]) (define [variable]) (define ([variable] [formals]) [body]) (define ([variable] . [formal]) [body])</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">The define form is used to create variable bindings and may appear anywhere other definitions may appear. </td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="define-macro"></a> define-macro</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(define-macro (name . args) body)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">The define-macro form is used to create traditional macro. </td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="*"></a> *</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(* z1 ...)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns the product of their arguments. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">The product of their arguments.</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="+"></a> +</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(+ z1 ...)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns the sum of their arguments. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">The sum of their arguments.</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="/"></a> /</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(/ z1 ...)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns the division of their arguments. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">The division of their arguments.</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="mode"></a> mode</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(mod z1 z2)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns the modulo of their arguments. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">The modulo of their arguments.</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="-"></a> -</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(- z1 z2 ...) (- z)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">With two or more arguments, this procedures returns the difference of its arguments, associating to the left. With one argument, however, it returns the additive inverse of its argument. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">With two or more arguments, this procedures returns the difference of its arguments, associating to the left. With one argument, however, it returns the additive inverse of its argument.</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="<"></a> <</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(< x1 x2 x3 ...)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns #t if its arguments are monotonically increasing and #f otherwise. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">#t if its arguments are monotonically increasing and #f otherwise.</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="<="></a> <=</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(<= x1 x2 x3 ...)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns #t if its arguments are monotonically nondecreasing and #f otherwise. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">#t if its arguments are monotonically nondecreasing and #f otherwise.</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="="></a> =</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(= x1 x2 x3 ...)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns #t if its arguments are equal and #f otherwise. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">#t if its arguments are equal and #f otherwise.</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name=">"></a> ></span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(> x1 x2 x3 ...)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns #t if its arguments are monotonically decreasing and #f otherwise. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">#t if its arguments are monotonically decreasing and #f otherwise.</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name=">="></a> >=</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(> x1 x2 x3 ...)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns #t if its arguments are monotonically increasing and #f otherwise. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">#t if its arguments are monotonically increasing and #f otherwise.</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="vector"></a> vector</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(vector obj ...)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns a newly allocated vector whose elements contain the given arguments. Analogous to list. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">A newly allocated vector whose elements contain the given arguments. Analogous to list.</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="pair?"></a> pair?</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(pair? obj)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns #t if obj is a pair, and otherwise returns #f. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">#t if obj is a pair, and otherwise returns #f.</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="values"></a> values</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(values obj ...)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Delivers all of its arguments to its continuation. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">Delivers all of its arguments to its continuation.</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="1">See also</td> <td class="manual-plain-reference-role">Base Library</td> <td class="manual-plain-reference-anchor" colspan="2"><a class="manual-plain-internal-reference" href="#call-with-values">call-with-values</a></td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="error"></a> error</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(error message)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">This error procedure will be replaced with R6RS (error) </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">This error procedure will be replaced with R6RS (error)</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="symbol->string"></a> symbol->string</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(symbol->string symbol)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns the name of symbol as an immutable string. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">Returns the name of symbol as an immutable string.</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="boolean?"></a> boolean?</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(boolean? obj)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns #t if obj is either #t or #f and returns #f otherwise. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">#t if obj is either #t or #f and returns #f otherwise.</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="eq?"></a> eq?</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(eq?)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description"><p>The eq? predicate is similar to eqv? except that in some cases it is capable of discerning distinctions finer than those detectable by eqv?.</p> <p>The eq? and eqv? predicates are guaranteed to have the same behavior on symbols, booleans, the empty list, pairs, procedures, non-empty strings, bytevectors, and vectors, and records.</p> </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">#t if eq?</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="13">Examples</td> <td class="manual-plain-example" colspan="2">(eq? &#39;a &#39;a) =>  #t</td></tr> <tr><td colspan="4" class="manual-plain-example">(eq? &#39;(a) &#39;(a))                         =>  #f (unspecified on R6RS)</td></tr> <tr><td colspan="4" class="manual-plain-example">(eq? (list &#39;a) (list &#39;a))               =>  #f</td></tr> <tr><td colspan="4" class="manual-plain-example">(eq? "a" "a")                           =>  #f (unspecified on R6RS)</td></tr> <tr><td colspan="4" class="manual-plain-example">(eq? "" "")                             =>  #f (unspecified on R6RS)</td></tr> <tr><td colspan="4" class="manual-plain-example">(eq? &#39;() &#39;())                           =>  #t</td></tr> <tr><td colspan="4" class="manual-plain-example">(eq? 2 2)                               =>  #t (unspecified on R6RS)</td></tr> <tr><td colspan="4" class="manual-plain-example">(eq? #\A #\A)                           =>  #t (unspecified on R6RS)</td></tr> <tr><td colspan="4" class="manual-plain-example">(eq? car car)                           =>  #t</td></tr> <tr><td colspan="4" class="manual-plain-example"><pre>(let ((n (+ 2 3)))
                (eq? n n))                       =>  #t (unspecified on R6RS)</pre></td></tr> <tr><td colspan="4" class="manual-plain-example"><pre>(let ((x &#39;(a)))
                (eq? x x))                       =>  #t (unspecified on R6RS)</pre></td></tr> <tr><td colspan="4" class="manual-plain-example"><pre>(let ((x &#39;#()))
                 (eq? x x))                      =>  #t (unspecified on R6RS)</pre></td></tr> <tr><td colspan="4" class="manual-plain-example"><pre>(let ((p (lambda (x) x)))
                (eq? p p))                       =>  #t (unspecified on R6RS)</pre></td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="vector?"></a> vector?</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(vector? obj)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns #t if obj is a vector. Otherwise the procedure returns #f. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">#t if obj is a vector. Otherwise the procedure returns #f.</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="equal?"></a> equal?</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(equal? obj1 obj2)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">The equal? predicate returns #t if and only if the unfoldings of its arguments into regular trees are equal as ordered trees. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">#t if and only if the unfoldings of its arguments into regular trees are equal as ordered trees.</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="6">Examples</td> <td class="manual-plain-example" colspan="2">(equal? &#39;a &#39;a)                                 =>  #t</td></tr> <tr><td colspan="4" class="manual-plain-example">(equal? &#39;(a) &#39;(a))                             =>  #t</td></tr> <tr><td colspan="4" class="manual-plain-example">(equal? &#39;(a (b) c) &#39;(a (b) c))                 =>  #t</td></tr> <tr><td colspan="4" class="manual-plain-example">(equal? "abc" "abc")                           =>  #t</td></tr> <tr><td colspan="4" class="manual-plain-example">(equal? 2 2)                                   =>  #t</td></tr> <tr><td colspan="4" class="manual-plain-example">(equal? (make-vector 5 &#39;a) (make-vector 5 &#39;a)) =>  #t</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="char?"></a> char?</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(char? obj)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns #t if obj is a character, otherwise returns #f. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">#t if obj is a character, otherwise returns #f.</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="char=?"></a> char=?</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(char=? char1 char2 char3 ...)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns #t if all given charctors are same charctor. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">#t if all given charctors are same charctor.</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="char->integer"></a> char->integer</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(char->integer char)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Given a character, char->integer returns its Unicode scalar value as an exact integer object. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">Given a character, char->integer returns its Unicode scalar value as an exact integer object.</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="integer->char"></a> integer->char</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(integer->char sv)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">For a Unicode scalar value sv, integer->char returns its associated character. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">For a Unicode scalar value sv, integer->char returns its associated character.</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="list?"></a> list?</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(list? obj)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">(not implemented yet) Returns #t if obj is a list, #f otherwise. By definition, all lists are chains of pairs that have finite length and are terminated by the empty list. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">#t if obj is a list, #f otherwise. By definition, all lists are chains of pairs that have finite length and are terminated by the empty list.</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="cons"></a> cons</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(cons obj1 obj2)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns a newly allocated pair whose car is obj1 and whose cdr is obj2. The pair is guaranteed to be different (in the sense of eqv?) from every existing object. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">A newly allocated pair whose car is obj1 and whose cdr is obj2.</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="5">Examples</td> <td class="manual-plain-example" colspan="2">(cons &#39;a &#39;())                   =>  (a)</td></tr> <tr><td colspan="4" class="manual-plain-example">(cons &#39;(a) &#39;(b c d))            =>  ((a) b c d)</td></tr> <tr><td colspan="4" class="manual-plain-example">(cons "a" &#39;(b c))               =>  ("a" b c)</td></tr> <tr><td colspan="4" class="manual-plain-example">(cons &#39;a 3)                     =>  (a . 3)</td></tr> <tr><td colspan="4" class="manual-plain-example">(cons &#39;(a b) &#39;c)                =>  ((a b) . c)</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="car"></a> car</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(car pair)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns the contents of the car field of pair. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">The contents of the car field of pair.</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="4">Examples</td> <td class="manual-plain-example" colspan="2">(car &#39;(a b c))                  =>  a</td></tr> <tr><td colspan="4" class="manual-plain-example">(car &#39;((a) b c d))              =>  (a)</td></tr> <tr><td colspan="4" class="manual-plain-example">(car &#39;(1 . 2))                  =>  1</td></tr> <tr><td colspan="4" class="manual-plain-example">(car &#39;())                       &amp;assertion exception (not implemented yet)</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="cdr"></a> cdr</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(cdr pair)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns the contents of the cdr field of pair. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">The contents of the cdr field of pair.</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="3">Examples</td> <td class="manual-plain-example" colspan="2">(cdr &#39;((a) b c d))              =>  (b c d)</td></tr> <tr><td colspan="4" class="manual-plain-example">(cdr &#39;(1 . 2))                  =>  2</td></tr> <tr><td colspan="4" class="manual-plain-example">(cdr &#39;())                       &amp;assertion exception (not implemented yet)</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="null?"></a> null?</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(null? obj)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns #t if obj is the empty list, #f otherwise. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">#t if obj is the empty list, #fotherwise.</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="string=?"></a> string=?</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(string=? string1 string2 string3 ...)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description"><p>Returns #t if the strings are the same length and contain the same characters in the same positions.</p> <p>Otherwise, the string=? procedure returns #f.Returns #t if obj is a string, otherwise returns #f.</p> </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">Returns #t if the strings are the same length and contain the same characters in the same positions.</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="make-string"></a> make-string</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(make-string k &amp;optional char)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns a newly allocated string of length k. If char is given, then all elements of the string are initialized to char, otherwise the contents of the string are unspecified. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">allocated string of length k.</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="string?"></a> string?</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(string? obj)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns #t if obj is a string, otherwise returns #f. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">#t if obj is a string, otherwise returns #f.</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="string-length"></a> string-length</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(string-length string)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns the number of characters in the given string as an exact integer object. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">the number of characters in the given string as an exact integer object.</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="string-ref"></a> string-ref</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(string-ref string k)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Character at index k in string </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">K must be a valid index of string.</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">character at index k in string</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="string-set!"></a> string-set!</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(string-set! string k char)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Stores char in element k of string. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">unspecified</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="string->symbol"></a> string->symbol</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(string->symbol string)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns the symbol whose name is string. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="1">Examples</td> <td class="manual-plain-example" colspan="2">(eq? &#39;JollyWog
    (string->symbol
      (symbol->string &#39;JollyWog))) => #t</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="string->number"></a> string->number</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(string->number string)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns a number by the given string. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">number</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="string-append"></a> string-append</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(string-append string ...)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns a newly allocated string whose characters form the concatenation of the given strings. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">A newly allocated string whose characters form the concatenation of the given strings.</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="string-split"></a> string-split</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(string-split string splitter)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Splits string by splitter and returns a list of strings. splitter can be a character. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">a list of splitted strings.</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="number->string"></a> number->string</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(number->string z)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Takes a number object and returns as a string an external representation of the given number object. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">Takes a number object and returns as a string an external representation of the given number object.</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="number->string"></a> number->string</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(number->string z radix)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Takes a number object and a radix and returns as a string an external representation of the given number object in the given radix. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="1">Parameters</td> <td class="manual-plain-parameter-name">radix</td> <td class="manual-plain-parameter-description" colspan="2">must be 16. (2, 8, 10 is not implemented yet)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">Takes a number object and a radix and returns as a string an external representation of the given number object in the given radix.</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="number?"></a> number?</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(number? obj)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Return #t if obj is number object and #f otherwise. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">#t if obj is number object and #f otherwise</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="caar"></a> caar</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(caar p)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns (car (car p)) </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">p is pair</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">(car (car p))</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="cdar"></a> cdar</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(cdar p)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns (cdr (car p)) </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">p is pair</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">(cdr (car p))</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="cadr"></a> cadr</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(cadr p)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns (car (cdr p)) </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">p is pair</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">(car (cdr p))</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="cddr"></a> cddr</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(cddr p)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns (cdr (cdr p)) </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">p is pair</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">(cdr (cdr p))</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="caaar"></a> caaar</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(caaar p)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns (car (car (car p))) </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">p is pair</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">(car (car (car p)))</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="cdaar"></a> cdaar</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(cdaar p)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns (cdr (car (car p))) </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">p is pair</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">(cdr (car (car p)))</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="cadar"></a> cadar</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(cadar p)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns (car (cdr (car p))) </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">p is pair</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">(car (cdr (car p)))</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="cddar"></a> cddar</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(cddar p)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns (cdr (cdr (car p))) </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">p is pair</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">(cdr (cdr (car p)))</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="caadr"></a> caadr</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(caadr p)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns (car (car (cdr p))) </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">p is pair</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">(car (car (cdr p)))</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="cdadr"></a> cdadr</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(cdadr p)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns (cdr (car (cdr p))) </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">p is pair</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">(cdr (car (cdr p)))</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="caddr"></a> caddr</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(caddr p)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns (car (cdr (cdr p))) </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">p is pair</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">(car (cdr (cdr p)))</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="cdddr"></a> cdddr</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(cdddr p)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns (cdr (cdr (cdr p))) </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">p is pair</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">(cdr (cdr (cdr p)))</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="caaaar"></a> caaaar</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(caaaar p)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns (car (car (car (car p)))) </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">p is pair</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">(car (car (car (car p))))</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="cdaaar"></a> cdaaar</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(cdaaar p)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns (cdr (car (car (car p)))) </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">p is pair</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">(cdr (car (car (car p))))</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="cadaar"></a> cadaar</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(cadaar p)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns (car (cdr (car (car p)))) </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">p is pair</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">(car (cdr (car (car p))))</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="cddaar"></a> cddaar</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(cddaar p)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns (cdr (cdr (car (car p)))) </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">p is pair</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">(cdr (cdr (car (car p))))</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="caadar"></a> caadar</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(caadar p)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns (car (car (cdr (car p)))) </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">p is pair</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">(car (car (cdr (car p))))</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="cdadar"></a> cdadar</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(cdadar p)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns (cdr (car (cdr (car p)))) </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">p is pair</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">(cdr (car (cdr (car p))))</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="caddar"></a> caddar</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(caddar p)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns (car (cdr (cdr (car p)))) </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">p is pair</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">(car (cdr (cdr (car p))))</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="cdddar"></a> cdddar</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(cdddar p)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns (cdr (cdr (cdr (car p)))) </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">p is pair</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">(cdr (cdr (cdr (car p))))</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="caaadr"></a> caaadr</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(caaadr p)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns (car (car (car (cdr p)))) </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">p is pair</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">(car (car (car (cdr p))))</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="cdaadr"></a> cdaadr</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(cdaadr p)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns (cdr (car (car (cdr p)))) </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">p is pair</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">(cdr (car (car (cdr p))))</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="cadadr"></a> cadadr</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(cadadr p)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns (car (cdr (car (cdr p)))) </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">p is pair</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">(car (cdr (car (cdr p))))</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="cddadr"></a> cddadr</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(cddadr p)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns (cdr (cdr (car (cdr p)))) </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">p is pair</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">(cdr (cdr (car (cdr p))))</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="caaddr"></a> caaddr</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(caaddr p)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns (car (car (cdr (cdr p)))) </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">p is pair</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">(car (car (cdr (cdr p))))</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="cdaddr"></a> cdaddr</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(cdaddr p)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns (cdr (car (cdr (cdr p)))) </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">p is pair</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">(cdr (car (cdr (cdr p))))</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="cadddr"></a> cadddr</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(cadddr p)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns (car (cdr (cdr (cdr p)))) </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">p is pair</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">(car (cdr (cdr (cdr p))))</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="cddddr"></a> cddddr</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(cddddr p)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns (cdr (cdr (cdr (cdr p)))) </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">p is pair</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">(cdr (cdr (cdr (cdr p))))</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="caaaaar"></a> caaaaar</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(caaaaar p)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns (car (car (car (car (car p))))) </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">p is pair</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">(car (car (car (car (car p)))))</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="cdaaaar"></a> cdaaaar</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(cdaaaar p)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns (cdr (car (car (car (car p))))) </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">p is pair</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">(cdr (car (car (car (car p)))))</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="cadaaar"></a> cadaaar</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(cadaaar p)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns (car (cdr (car (car (car p))))) </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">p is pair</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">(car (cdr (car (car (car p)))))</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="cddaaar"></a> cddaaar</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(cddaaar p)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns (cdr (cdr (car (car (car p))))) </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">p is pair</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">(cdr (cdr (car (car (car p)))))</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="caadaar"></a> caadaar</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(caadaar p)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns (car (car (cdr (car (car p))))) </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">p is pair</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">(car (car (cdr (car (car p)))))</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="cdadaar"></a> cdadaar</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(cdadaar p)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns (cdr (car (cdr (car (car p))))) </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">p is pair</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">(cdr (car (cdr (car (car p)))))</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="caddaar"></a> caddaar</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(caddaar p)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns (car (cdr (cdr (car (car p))))) </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">p is pair</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">(car (cdr (cdr (car (car p)))))</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="cdddaar"></a> cdddaar</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(cdddaar p)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns (cdr (cdr (cdr (car (car p))))) </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">p is pair</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">(cdr (cdr (cdr (car (car p)))))</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="caaadar"></a> caaadar</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(caaadar p)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns (car (car (car (cdr (car p))))) </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">p is pair</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">(car (car (car (cdr (car p)))))</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="cdaadar"></a> cdaadar</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(cdaadar p)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns (cdr (car (car (cdr (car p))))) </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">p is pair</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">(cdr (car (car (cdr (car p)))))</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="cadadar"></a> cadadar</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(cadadar p)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns (car (cdr (car (cdr (car p))))) </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">p is pair</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">(car (cdr (car (cdr (car p)))))</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="cddadar"></a> cddadar</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(cddadar p)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns (cdr (cdr (car (cdr (car p))))) </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">p is pair</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">(cdr (cdr (car (cdr (car p)))))</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="caaddar"></a> caaddar</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(caaddar p)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns (car (car (cdr (cdr (car p))))) </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">p is pair</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">(car (car (cdr (cdr (car p)))))</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="cdaddar"></a> cdaddar</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(cdaddar p)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns (cdr (car (cdr (cdr (car p))))) </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">p is pair</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">(cdr (car (cdr (cdr (car p)))))</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="cadddar"></a> cadddar</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(cadddar p)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns (car (cdr (cdr (cdr (car p))))) </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">p is pair</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">(car (cdr (cdr (cdr (car p)))))</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="cddddar"></a> cddddar</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(cddddar p)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns (cdr (cdr (cdr (cdr (car p))))) </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">p is pair</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">(cdr (cdr (cdr (cdr (car p)))))</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="caaaadr"></a> caaaadr</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(caaaadr p)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns (car (car (car (car (cdr p))))) </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">p is pair</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">(car (car (car (car (cdr p)))))</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="cdaaadr"></a> cdaaadr</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(cdaaadr p)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns (cdr (car (car (car (cdr p))))) </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">p is pair</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">(cdr (car (car (car (cdr p)))))</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="cadaadr"></a> cadaadr</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(cadaadr p)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns (car (cdr (car (car (cdr p))))) </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">p is pair</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">(car (cdr (car (car (cdr p)))))</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="cddaadr"></a> cddaadr</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(cddaadr p)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns (cdr (cdr (car (car (cdr p))))) </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">p is pair</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">(cdr (cdr (car (car (cdr p)))))</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="caadadr"></a> caadadr</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(caadadr p)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns (car (car (cdr (car (cdr p))))) </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">p is pair</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">(car (car (cdr (car (cdr p)))))</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="cdadadr"></a> cdadadr</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(cdadadr p)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns (cdr (car (cdr (car (cdr p))))) </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">p is pair</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">(cdr (car (cdr (car (cdr p)))))</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="caddadr"></a> caddadr</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(caddadr p)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns (car (cdr (cdr (car (cdr p))))) </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">p is pair</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">(car (cdr (cdr (car (cdr p)))))</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="cdddadr"></a> cdddadr</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(cdddadr p)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns (cdr (cdr (cdr (car (cdr p))))) </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">p is pair</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">(cdr (cdr (cdr (car (cdr p)))))</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="caaaddr"></a> caaaddr</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(caaaddr p)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns (car (car (car (cdr (cdr p))))) </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">p is pair</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">(car (car (car (cdr (cdr p)))))</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="cdaaddr"></a> cdaaddr</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(cdaaddr p)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns (cdr (car (car (cdr (cdr p))))) </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">p is pair</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">(cdr (car (car (cdr (cdr p)))))</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="cadaddr"></a> cadaddr</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(cadaddr p)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns (car (cdr (car (cdr (cdr p))))) </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">p is pair</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">(car (cdr (car (cdr (cdr p)))))</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="cddaddr"></a> cddaddr</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(cddaddr p)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns (cdr (cdr (car (cdr (cdr p))))) </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">p is pair</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">(cdr (cdr (car (cdr (cdr p)))))</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="caadddr"></a> caadddr</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(caadddr p)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns (car (car (cdr (cdr (cdr p))))) </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">p is pair</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">(car (car (cdr (cdr (cdr p)))))</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="cdadddr"></a> cdadddr</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(cdadddr p)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns (cdr (car (cdr (cdr (cdr p))))) </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">p is pair</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">(cdr (car (cdr (cdr (cdr p)))))</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="caddddr"></a> caddddr</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(caddddr p)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns (car (cdr (cdr (cdr (cdr p))))) </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">p is pair</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">(car (cdr (cdr (cdr (cdr p)))))</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="cdddddr"></a> cdddddr</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(cdddddr p)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns (cdr (cdr (cdr (cdr (cdr p))))) </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">p is pair</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">(cdr (cdr (cdr (cdr (cdr p)))))</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="even?"></a> even?</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(even? x)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns whether x is even. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">whether x is even</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="call-with-values"></a> call-with-values</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(call-with-values producer consumer)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Calls producer with no arguments and a continuation that, when passed some values, calls the consumer procedure with those values as arguments. The continuation for the call to consumer is the continuation of the call to call-with-values. (define (call-with-values producer consumer) (apply consumer (producer))) </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="2">Parameters</td> <td class="manual-plain-parameter-name">producer</td> <td class="manual-plain-parameter-description" colspan="2">must be a procedure and should accept zero arguments</td></tr> <tr class="manual-row"><td class="manual-plain-parameter-name">consumer</td> <td colspan="3" class="manual-plain-parameter-description">must be a procedure and should accept as many values as producer returns</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">result of consumer</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="1">See also</td> <td class="manual-plain-reference-role">SRFI-8 Binding to multiple values.</td> <td class="manual-plain-reference-anchor" colspan="2"><a class="manual-plain-internal-reference" href="#receive">receive</a></td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="list-tail"></a> list-tail</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(list-tail l k)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns the subchain of pairs of list obtained by omitting the first k elements </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">l should be a list of size at least k.</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">the subchain of pairs of list obtained by omitting the first k elements</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="1">Examples</td> <td class="manual-plain-example" colspan="2">(list-tail &#39;(a b c d) 2) => (c d)</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="list-ref"></a> list-ref</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(list-ref l k)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns the kth element of list. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">l must be a list whose length is at least k + 1.</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">returns the kth element of list.</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="1">Examples</td> <td class="manual-plain-example" colspan="2">(list-ref &#39;(a b c d) 2) => c</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="vector->list"></a> vector->list</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(vector->list v)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns a newly allocated list of the objects contained in the elements of vector </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">returns a newly allocated list of the objects contained in the elements of vector</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="1">Examples</td> <td class="manual-plain-example" colspan="2">(vector->list &#39;#(dah dah didah)) => (dah dah didah)</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="zero?"></a> zero?</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(zero? n)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Tests if the number object is = to zero </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">#t is (= n 0)</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="list"></a> list</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(list obj ...)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns a newly allocated list of its arguments. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">a newly allocated list of its arguments.</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="2">Examples</td> <td class="manual-plain-example" colspan="2">(list &#39;a (+ 3 4) &#39;c) => (a 7 c)</td></tr> <tr><td colspan="4" class="manual-plain-example">(list) => ()</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="abs"></a> abs</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(abs n)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns the absolute value of its argument. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">Returns the absolute value of its argument.</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="1">Examples</td> <td class="manual-plain-example" colspan="2">(abs -7) => 7</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="map"></a> map</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(map proc list1 list2 ...)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">The map procedure applies proc element-wise to the elements of the lists and returns a list of the results, in order. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="2">Parameters</td> <td class="manual-plain-parameter-name">ll</td> <td class="manual-plain-parameter-description" colspan="2">should all have the same length.</td></tr> <tr class="manual-row"><td class="manual-plain-parameter-name">proc</td> <td colspan="3" class="manual-plain-parameter-description">should accept as many arguments as there are lists and return a single value. should not mutate any of the lists.</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">a list of the results</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="3">Examples</td> <td class="manual-plain-example" colspan="2">(map cadr &#39;((a b) (d e) (g h))) => (b e h)</td></tr> <tr><td colspan="4" class="manual-plain-example">(map (lambda (n) (expt n n)) &#39;(1 2 3 4 5)) => (1 4 27 256 3125)</td></tr> <tr><td colspan="4" class="manual-plain-example">(map + &#39;(1 2 3) &#39;(4 5 6)) => (5 7 9)</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="length"></a> length</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(length l)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns the length of list. (length &#39;(a b c)) => 3 (length &#39;(a (b) (c d e))) => 3 (length &#39;()) => 0 </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">the length of list.</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="reverse"></a> reverse</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(reverse l)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns a newly allocated list consisting of the elements of list in reverse order. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">a newly allocated list consisting of the elements of list in reverse order.</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="2">Examples</td> <td class="manual-plain-example" colspan="2">(reverse &#39;(a b c)) => (c b a)</td></tr> <tr><td colspan="4" class="manual-plain-example">(reverse &#39;(a (b c) d (e (f)))) => ((e (f)) d (b c) a)</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="list->string"></a> list->string</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(list->string l)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">The list->string procedure returns a newly allocated string formed from the characters in list. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">The list->string procedure returns a newly allocated string formed from the characters in list.</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="for-each"></a> for-each</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(for-each proc list1 list2 ...)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">The for-each procedure applies proc element-wise to the elements of the lists for its side effects, in order from the first elements to the last. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">The lists should all have the same length. Proc should accept as many arguments as there are lists. Proc should not mutate any of the lists.</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">The return values of for-each are unspecified.</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="3">Examples</td> <td class="manual-plain-example" colspan="2">(let ((v (make-vector 5)))
 (for-each (lambda (i)
             (vector-set! v i (* i i)))
           &#39;(0 1 2 3 4))
 v)  => #(0 1 4 9 16)</td></tr> <tr><td colspan="4" class="manual-plain-example">(for-each (lambda (x) x) &#39;(1 2 3 4)) => unspecified</td></tr> <tr><td colspan="4" class="manual-plain-example">(for-each even? ’()) => unspecified</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="list->vector"></a> list->vector</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(list->vector l)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">The list->vector procedure returns a newly created vector initialized to the elements of the list list. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">The list->vector procedure returns a newly created vector initialized to the elements of the list list.</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="1">Examples</td> <td class="manual-plain-example" colspan="2">(list->vector &#39;(dididit dah)) => #(dididit dah)</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="append"></a> append</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(append  . ll)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns a possibly improper list consisting of the elements of the first list followed by the elements of the other lists, with obj as the cdr of the final pair. An improper list results if obj is not a list. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">Returns a possibly improper list consisting of the elements of the first list followed by the elements of the other lists, with obj as the cdr of the final pair. An improper list results if obj is not a list.</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Postcondition</td> <td colspan="3" class="manual-plain-condition">If append constructs a nonempty chain of pairs, it is always newly allocated. If no pairs are allocated, obj is returned.</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="5">Examples</td> <td class="manual-plain-example" colspan="2">(append &#39;(x) &#39;(y))                      =>  (x y)</td></tr> <tr><td colspan="4" class="manual-plain-example">(append &#39;(a) &#39;(b c d))                  =>  (a b c d)</td></tr> <tr><td colspan="4" class="manual-plain-example">(append &#39;(a (b)) &#39;((c)))                =>  (a (b) (c))</td></tr> <tr><td colspan="4" class="manual-plain-example">(append &#39;(a b) &#39;(c . d))                =>  (a b c . d)</td></tr> <tr><td colspan="4" class="manual-plain-example">(append &#39;() &#39;a)                         =>  a</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="vector-for-each"></a> vector-for-each</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(vector-for-each proc vector1 vector2 ...)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Applies proc element-wise to the elements of the vectors for its side effects, in order from the first elements to the last. Proc is always called in the same dynamic environment as vector-for-each itself.(todo vector2 ...) </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">The vectors must all have the same length. Proc should accept as many arguments as there are vectors.</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">unspecified.</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="vector-map"></a> vector-map</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(vector-map proc vector1 vector2 ...)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Applies proc element-wise to the elements of the vectors and returns a vector of the results, in order. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">The vectors must all have the same length. Proc should accept as many arguments as there are vectors and return a single value.</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">a vectors</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr class="manual-section"><td class="manual-section" colspan="4"><a name="SECTION2"></a> <span><a href="#MANUAL-TOP"><img src="man-images/small-up.gif" title="Manual top" alt="" border="0" /></a> <a href="#SECTION1"><img src="man-images/small-prev.gif" title="Previous manual section" alt="" border="0" /></a> <a href="#SECTION3"><img src="man-images/small-next.gif" title="Next manual section" alt="" border="0" /></a></span> <br /> <span class="manual-section-number">2</span> <span class="manual-section-title">Bytevectors.</span></td></tr> <tr><td colspan="4" class="manual-section-description">R6RS library Chapter 2. </td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="bytevector-u8-set!"></a> bytevector-u8-set!</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(bytevector-u8-set! bytevector k octet)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Stores octet in element k of bytevector. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">K must be a valid index of bytevector.</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">unspecified</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="bytevector-length"></a> bytevector-length</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(bytevector-length bytevector)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns, as an exact integer object, the number of bytes in bytevector. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">As an exact integer object, the number of bytes in bytevector.</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="bytevector-u8-ref"></a> bytevector-u8-ref</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(bytevector-u8-ref bytevector k)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns the byte at index k of bytevector, as an octet. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">K must be a valid index of bytevector.</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">the byte at index k of bytevector, as an octet.</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="utf8->string"></a> utf8->string</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(utf8->string bytevector)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns a newly allocated (unless empty) string whose character sequence is encoded by the given bytevector. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">A newly allocated (unless empty) string whose character sequence is encoded by the given bytevector.</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr class="manual-section"><td class="manual-section" colspan="4"><a name="SECTION3"></a> <span><a href="#MANUAL-TOP"><img src="man-images/small-up.gif" title="Manual top" alt="" border="0" /></a> <a href="#SECTION2"><img src="man-images/small-prev.gif" title="Previous manual section" alt="" border="0" /></a> <a href="#SECTION4"><img src="man-images/small-next.gif" title="Next manual section" alt="" border="0" /></a></span> <br /> <span class="manual-section-number">3</span> <span class="manual-section-title">List utilities.</span></td></tr> <tr><td colspan="4" class="manual-section-description">R6RS library Chapter 3.</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="memq"></a> memq</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(memq obj list)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Return the first sublist of list whose car satisfies a given condition with eq?, where the sublists of lists are the lists returned by (list-tail list k) for k less than the length of list. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">Proc should accept one argument and return a single value. Proc should not mutate list.</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">The first sublist of list whose car satisfies a given condition, where the sublists of lists are the lists returned by (list-tail list k) for k less than the length of list.</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="fold-left"></a> fold-left</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(fold-left combine nil list1 list2 ...listn)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description"><p>The fold-left procedure iterates the combine procedure over an accumulator value and the elements of the lists from left to right, starting with an accumulator value of nil.</p> <p>More specifically, fold-left returns nil if the lists are empty. If they are not empty, combine is first applied to nil and the respective first elements of the lists in order.</p> <p>The result becomes the new accumulator value, and combine is applied to the new accumulator value and the respective next elements of the list.</p> <p>This step is repeated until the end of the list is reached; then the accumulator value is returned. Combine is always called in the same dynamic environment as fold-left itself.</p> </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">The lists should all have the same length. Combine must be a procedure. It should accept one more argument than there are lists and return a single value. It should not mutate the list arguments.</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">accumlated pair</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="6">Examples</td> <td class="manual-plain-example" colspan="2">(fold-left + 0 &#39;(1 2 3 4 5)) => 15</td></tr> <tr><td colspan="4" class="manual-plain-example">(fold-left (lambda (a e) (cons e a)) &#39;()
          &#39;(1 2 3 4 5)) => (5 4 3 2 1)</td></tr> <tr><td colspan="4" class="manual-plain-example">(fold-left (lambda (count x) 
            (if (odd? x) (+ count 1) count)) 
            0 
            &#39;(3 1 4 1 5 9 2 6 5 3)) 
          => 7</td></tr> <tr><td colspan="4" class="manual-plain-example">(fold-left (lambda (max-len s) 
            (max max-len (string-length s))) 
            0 
            &#39;("longest" "long" "longer")) 
          => 7</td></tr> <tr><td colspan="4" class="manual-plain-example">(fold-left + 0 &#39;(1 2 3) &#39;(4 5 6)) 
          => 21</td></tr> <tr><td colspan="4" class="manual-plain-example">(fold-left cons &#39;(q) &#39;(a b c)) 
           => ((((q) . a) . b) . c)</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="fold-right"></a> fold-right</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(fold-right combine nil list1 list2 ...listn)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description"><p>The fold-right procedure iterates the combine procedure over the elements of the lists from right to left and an accumulator value, starting with an accumulator value of nil.</p> <p>More specifically, fold-right returns nil if the lists are empty. If they are not empty, combine is first applied to the respective last elements of the lists in order and nil.</p> <p>The result becomes the new accumulator value, and combine is applied to the respective previous elements of the lists and the new accumulator value.</p> <p>This step is repeated until the beginning of the list is reached; then the accumulator value is returned.</p> <p>Proc is always called in the same dynamic environment as fold-right itself.</p> </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">The lists should all have the same length. Combine must be a procedure. It should accept one more argument than there are lists and return a single value. Combine should not mutate the list arguments.</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">accumulated pair</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="5">Examples</td> <td class="manual-plain-example" colspan="2">(fold-right + 0 &#39;(1 2 3 4 5))
          => 15</td></tr> <tr><td colspan="4" class="manual-plain-example">(fold-right cons &#39;() &#39;(1 2 3 4 5))
         => (1 2 3 4 5)</td></tr> <tr><td colspan="4" class="manual-plain-example">(fold-right (lambda (x l)
           (if (odd? x) (cons x l) l))
           &#39;()
           &#39;(3 1 4 1 5 9 2 6 5))
          => (3 1 1 5 9 5)</td></tr> <tr><td colspan="4" class="manual-plain-example">(fold-right cons &#39;(q) &#39;(a b c))
         => (a b c q)</td></tr> <tr><td colspan="4" class="manual-plain-example">(fold-right + 0 &#39;(1 2 3) &#39;(4 5 6))
         => 21</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="remp"></a> remp</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(remp pred l)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">The remp procedure applies proc to each element of list and returns a list of the elements of list for which proc returned #f. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">Proc should accept one argument and return a single value. Proc should not mutate list.</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">The remp procedure applies proc to each element of list and returns a list of the elements of list for which proc returned #f.</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="1">Examples</td> <td class="manual-plain-example" colspan="2">(remp even? &#39;(3 1 4 1 5 9 2 6 5)) => (3 1 1 5 9 5)</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="filter"></a> filter</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(filter proc list)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description"><p>The filter procedure applies proc to each element of list and returns a list of the elements of list for which proc returned a true value.</p> <p>The elements of the result list(s) are in the same order as they appear in the input list.</p> </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="1">Parameters</td> <td class="manual-plain-parameter-name">proc</td> <td class="manual-plain-parameter-description" colspan="2">Proc should accept one argument and return a single value. Proc should not mutate list.</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">returns a list of the elements of list for which proc returned a true value.</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="1">Examples</td> <td class="manual-plain-example" colspan="2">(filter even? &#39;(3 1 4 1 5 9 2 6)) => (4 2 6)</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="find"></a> find</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(find pred lst)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description"><p>The find procedure applies proc to the elements of list in order. If proc returns a true value for an element, find immediately returns that element. If proc returns #f for all elements of the list, find returns #f.</p> </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">Proc should accept one argument and return a single value. Proc should not mutate list.</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">The find procedure applies proc to the elements of list in order. If proc returns a true value for an element, find immediately returns that element. If proc returns #f for all elements of the list, find returns #f.</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="2">Examples</td> <td class="manual-plain-example" colspan="2">(find even? &#39;(3 1 4 1 5 9)) => 4</td></tr> <tr><td colspan="4" class="manual-plain-example">(find even? &#39;(3 1 5 1 5 9)) => #f</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="assv"></a> assv</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(assv obj alist)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description"><p>Find the first pair in alist whose car field satisfies a given condition, and returns that pair without traversing alist further. If no pair in alist satisfies the condition, then #f is returned.</p> <p>The assoc procedure uses equal? to compare obj with the car fields of the pairs in alist, while assv uses eqv? and assq uses eq?.</p> </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">Alist (for "association list") should be a list of pairs. Proc should accept one argument and return a single value. Proc should not mutate alist.</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="1">Examples</td> <td class="manual-plain-example" colspan="2">(assv 5 &#39;((2 3) (5 7) (11 13))) => (5 7)</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="assoc"></a> assoc</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(assoc obj alist)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description"><p>Find the first pair in alist whose car field satisfies a given condition, and returns that pair without traversing alist further. If no pair in alist satisfies the condition, then #f is returned.</p> <p>The assoc procedure uses equal? to compare obj with the car fields of the pairs in alist, while assv uses eqv? and assq uses eq?.</p> </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">Alist (for "association list") should be a list of pairs. Proc should accept one argument and return a single value. Proc should not mutate alist.</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="1">Examples</td> <td class="manual-plain-example" colspan="2">(assoc (list &#39;a) &#39;(((a)) ((b)) ((c)))) => ((a))</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr class="manual-section"><td class="manual-section" colspan="4"><a name="SECTION4"></a> <span><a href="#MANUAL-TOP"><img src="man-images/small-up.gif" title="Manual top" alt="" border="0" /></a> <a href="#SECTION3"><img src="man-images/small-prev.gif" title="Previous manual section" alt="" border="0" /></a> <a href="#SECTION5"><img src="man-images/small-next.gif" title="Next manual section" alt="" border="0" /></a></span> <br /> <span class="manual-section-number">4</span> <span class="manual-section-title">Control structures.</span></td></tr> <tr><td colspan="4" class="manual-section-description">R6RS library Chapter 5.</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="do"></a> do</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(do (([variable1] [init1] [step1]) ...) ([test] [expression] ...) [command] ...)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description"><p>The [init] expressions are evaluated (in some unspecified order), the [variable]s are bound to fresh locations, the results of the [init] expressions are stored in the bindings of the [variable]s, and then the iteration phase begins.</p> <p>Each iteration begins by evaluating [test]; if the result is #f, then the [command]s are evaluated in order for effect, the [step] expressions are evaluated in some unspecified order, the [variable]s are bound to fresh locations holding the results, and the next iteration begins.</p> <p>If [test] evaluates to a true value, the [expression]s are evaluated from left to right and the values of the last [expression] are returned.</p> <p>If no [expression]s are present, then the do expression returns unspecified values.</p> <p>The regionof the binding of a [variable] consists of the entire do expression except for the [init]s.</p> <p>A [step] may be omitted, in which case the effect is the same as if ([variable] [init] [variable]) had been written instead of ([variable] [init]).</p> </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="2">Examples</td> <td class="manual-plain-example" colspan="2"><pre>(do ((vec (make-vector 5))
           (i 0 (+ i 1)))
           ((= i 5) vec)
             (vector-set! vec i i)) =>  #(0 1 2 3 4)</pre></td></tr> <tr><td colspan="4" class="manual-plain-example"><pre>(let ((x &#39;(1 3 5 7 9)))
           (do ((x x (cdr x))
             (sum 0 (+ sum (car x))))
             ((null? x) sum)))</pre></td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="unless"></a> unless</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(unless test body ...)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Evaluates test. If it yields false value, body … are evaluated sequentially, and the result(s) of the last evaluation is(are) returned. Otherwise, unspecified value is returned. </td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="when"></a> when</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(when test body ...)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Evaluates test. If it yields true value, body … are evaluated sequentially, and the result(s) of the last evaluation is(are) returned. Otherwise, unspecified value is returned. </td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr class="manual-section"><td class="manual-section" colspan="4"><a name="SECTION5"></a> <span><a href="#MANUAL-TOP"><img src="man-images/small-up.gif" title="Manual top" alt="" border="0" /></a> <a href="#SECTION4"><img src="man-images/small-prev.gif" title="Previous manual section" alt="" border="0" /></a> <a href="#SECTION6"><img src="man-images/small-next.gif" title="Next manual section" alt="" border="0" /></a></span> <br /> <span class="manual-section-number">5</span> <span class="manual-section-title">Exceptions and conditionsI/O.</span></td></tr> <tr><td colspan="4" class="manual-section-description">R6RS library Chapter 7.</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="with-input-from-file"></a> with-input-from-file</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(with-input-from-file filename thunk)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description"></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">Thunk must be a procedure and must accept zero arguments. The file is opened for input or output using empty file options, and thunk is called with no arguments.</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="raise"></a> raise</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(raise obj)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Raises a non-continuable exception by invoking the current exception handler on obj. </td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="with-exception-handler"></a> with-exception-handler</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(with-exception-handler handler thunk)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns the results of invoking thunk. Handler is installed as the current exception handler for the dynamic extent (as determined by dynamic-wind) of the invocation of thunk. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">Handler must be a procedure and should accept one argument. Thunk must be a procedure that accepts zero arguments.</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">the results of invoking thunk.</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="guard"></a> guard</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(guard ([variable] [cond clause1] [cond clause2] ...)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description"><p>(guard ([variable]    syntax</p> <p>[cond clause1] [cond clause2] ...)</p> <p>[body])</p> <p>=>    auxiliary syntax</p> <p>else    auxiliary syntax</p> <p>Semantics: Evaluating a guard form evaluates [body] with an exception handler that binds the raised object to [variable] and within the scope of that binding evaluates the clauses as if they were the clauses of a cond expression. </p> <p>That implicit cond expression is evaluated with the continuation and dynamic environment of the guard expression. </p> <p>If every [cond clause]&#39;s [test] evaluates to #f and there is no else clause, then raise is re-invoked on the raised object within the dynamic environment of the original call to raise except that the current exception handler is that of the guard expression.</p> </td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="raise-continuable"></a> raise-continuable</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(raise-continuable obj)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description"><p>Raises a continuable exception by invoking the current exception handler on obj.</p> <p>The handler is called with a continuation that is equivalent to the continuation of the call to raise-continuable, with these two exceptions:</p> <p>(1) the current exception handler is the one that was in place when the handler being called was installed, and (2) if the handler being called returns, then it will again become the current exception handler. </p> <p>If the handler returns, the values it returns become the values returned by the call to raise-continuable.</p> </td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr class="manual-section"><td class="manual-section" colspan="4"><a name="SECTION6"></a> <span><a href="#MANUAL-TOP"><img src="man-images/small-up.gif" title="Manual top" alt="" border="0" /></a> <a href="#SECTION5"><img src="man-images/small-prev.gif" title="Previous manual section" alt="" border="0" /></a> <a href="#SECTION7"><img src="man-images/small-next.gif" title="Next manual section" alt="" border="0" /></a></span> <br /> <span class="manual-section-number">6</span> <span class="manual-section-title">I/O.</span></td></tr> <tr><td colspan="4" class="manual-section-description">R6RS library Chapter 8.</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="read"></a> read</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(read) (read textual-input-port)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Reads an external representation from textual-input-port and returns the datum it represents. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">datum</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="open-file-output-port"></a> open-file-output-port</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(open-file-output-port filename)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns an output port for the named file. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">An output port for the named file.</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="open-file-input-port"></a> open-file-input-port</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(open-file-input-port filename)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns an input port for the named file. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">An input port for the named file.</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="close-input-port"></a> close-input-port</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(close-input-port input-port)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Closes input-port or output-port, respectively. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">unspecified</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="standard-input-port"></a> standard-input-port</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(standard-input-port)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns a fresh binary input port connected to standard input. Whether the port supports the port-position and set-port-position! operations is implementation-dependent. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">A fresh binary input port connected to standard input. Whether the port supports the port-position and set-port-position! operations is implementation-dependent.</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="get-bytevector-n"></a> get-bytevector-n</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(get-bytevector-n binary-input-port count)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description"><p>Reads from binary-input-port, blocking as necessary, until count bytes are available from binary-input-port or until an end of file is reached.</p> <p>If count bytes are available before an end of file, get-bytevector-n returns a bytevector of size count. If fewer bytes are available before an end of file, get-bytevector-n returns a bytevector containing those bytes.</p> <p>In either case, the input port is updated to point just past the bytes read.</p> <p>If an end of file is reached before any bytes are available, get-bytevector-n returns the end-of-file object. </p> </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">Count must be an exact, non-negative integer object representing the number of bytes to be read.</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">bytevector</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="eof-object"></a> eof-object</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(eof-object)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns the end-of-file object. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">the end-of-file object.</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="transcoded-port"></a> transcoded-port</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(transcoded-port binary-port transcoder)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description"><p>Returns a new textual port with the specified transcoder.</p> <p>Otherwise the new textual port&#39;s state is largely the same as that of binary-port.</p> <p>If binary-port is an input port, the new textual port will be an input port and will transcode the bytes that have not yet been read from binary-port. If binary-port is an output port, the new textual port will be an output port and will transcode output characters into bytes that are written to the byte sink represented by binary-port.</p> </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">A new textual port with the specified transcoder.</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="utf-8-codec"></a> utf-8-codec</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(utf-8-codec)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Predefined codecs for the UTF-8 encoding schemes. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">Predefined codecs for the UTF-8 encoding schemes.</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="make-transcoder"></a> make-transcoder</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(make-transcoder codec)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns transcoder with the behavior specified by its arguments. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">transcoder with the behavior specified by its arguments.</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="get-u8"></a> get-u8</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(get-u8 binary-input-port)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description"><p>Reads from binary-input-port, blocking as necessary, until a byte is available from binary-input-port or until an end of file is reached.</p> <p>If a byte becomes available, get-u8 returns the byte as an octet and updates binary-input-port to point just past that byte. If no input byte is seen before an end of file is reached, the end-of-file object is returned.</p> </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">a byte</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="make-custom-binary-input-port"></a> make-custom-binary-input-port</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(make-custom-binary-input-port id read! procedure get-position set-position! close)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description"><p>Note. This procedure is not implementednot all specification.</p> <p>Returns a newly created binary input port whose byte source is an arbitrary algorithm represented by the read! procedure.</p> <p>Id must be a string naming the new port, provided for informational purposes only. Read! must be a procedure and should behave as specified below; it will be called by operations that perform binary input.</p> <p>Each of the remaining arguments may be #f; if any of those arguments is not #f, it must be a procedure and should behave as specified below.</p> <p>(read! bytevector start count)</p> <p>Start will be a non-negative exact integer object, count will be a positive exact integer object, and bytevector will be a bytevector whose length is at least start + count.</p> <p>The read! procedure should obtain up to count bytes from the byte source, and should write those bytes into bytevector starting at index start.</p> <p>The read! procedure should return an exact integer object.</p> <p>This integer object should represent the number of bytes that it has read. To indicate an end of file, the read! procedure should write no bytes and return 0.</p> <p>(get-position)</p> <p>The get-position procedure (if supplied) should return an exact integer object representing the current position of the input port.</p> <p>If not supplied, the custom port will not support the port-position operation.</p> <p>(set-position! pos)</p> <p>Pos will be a non-negative exact integer object. The set-position! procedure (if supplied) should set the position of the input port to pos.</p> <p>If not supplied, the custom port will not support the set-port-position! operation.</p> <p>(close)</p> <p>The close procedure (if supplied) should perform any actions that are necessary when the input port is closed.</p> </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">A newly created binary input port whose byte source is an arbitrary algorithm represented by the read! procedure.</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="current-error-port"></a> current-error-port</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(current-error-port)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns default textual ports for regular error output. Normally, this port is associated with standard error. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">Default textual ports for regular error output. Normally, this port is associated with standard error.</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="write"></a> write</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(write obj &amp;optional textual-output-port)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Writes the external representation of obj to textual-output-port. The write procedure operates in the same way as put-datum. If textual-output-port is omitted, it defaults to the value returned by current-output-port. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">unspecified</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="eof-object?"></a> eof-object?</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(eof-object? obj)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns #t if obj is the end-of-file object, #f otherwise. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">#t if obj is the end-of-file object, #f otherwise.</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="read-char"></a> read-char</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(read-char &amp;optional textual-input-port)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description"><p>Reads from textual-input-port, blocking as necessary until a character is available from textual-input-port, or the data that are available cannot be the prefix of any valid encoding, or an end of file is reached.</p> <p>If a complete character is available before the next end of file, read-char returns that character, and updates the input port to point past that character. If an end of file is reached before any data are read, read-char returns the end-of-file object. If textual-input-port is omitted, it defaults to the value returned by current-input-port.</p> </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">character</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="open-string-input-port"></a> open-string-input-port</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(open-string-input-port string)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns a textual input port whose characters are drawn from string. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">A textual input port whose characters are drawn from string.</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="set-current-input-port!"></a> set-current-input-port!</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(set-current-input-port!)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Used internal </td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="set-current-output-port!"></a> set-current-output-port!</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(set-current-output-port!)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Used internal </td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="open-output-file"></a> open-output-file</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(open-output-file filename)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Opens filename for output, with empty file options, and returns the obtained port. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">Opens filename for output, with empty file options, and returns the obtained port.</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="current-input-port"></a> current-input-port</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(current-input-port)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns a default textual port for input. Normally, this default port is associated with standard input, but can be dynamically re-assigned using the with-input-from-file procedure </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">A default textual port for input. Normally, this default port is associated with standard input, but can be dynamically re-assigned using the with-input-from-file procedure</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="current-output-port"></a> current-output-port</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(current-output-port)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns a default textual port for output. Normally, this default port is associated with standard output, but can be dynamically re-assigned using the with-output-from-file procedure </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">A default textual port for output. Normally, this default port is associated with standard output, but can be dynamically re-assigned using the with-output-from-file procedure</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="close-output-port"></a> close-output-port</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(close-output-port output-port)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Closes output-port. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">unspecified</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="call-with-output-file"></a> call-with-output-file</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(call-with-output-file filename proc)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description"><p>Open the file named by filename for output, with no specified file options, and call proc with the obtained port as an argument.</p> <p>If proc returns, the port is closed automatically and the values returned by proc are returned. If proc does not return, the port is not closed automatically, unless it is possible to prove that the port will never again be used for an I/O operation.</p> </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">Proc should accept one argument.</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">the values returned by proc.</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="call-with-input-file"></a> call-with-input-file</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(call-with-input-file filename proc)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description"><p>Open the file named by filename for input, with no specified file options, and call proc with the obtained port as an argument.</p> <p>If proc returns, the port is closed automatically and the values returned by proc are returned. If proc does not return, the port is not closed automatically, unless it is possible to prove that the port will never again be used for an I/O operation.</p> </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Precondition</td> <td colspan="3" class="manual-plain-condition">Proc should accept one argument.</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">the values returned by proc.</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="open-string-output-port"></a> open-string-output-port</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(open-string-output-port)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description"><p>Returns two values: a textual output port and an extraction procedure.</p> <p>The output port accumulates the characters written to it for later extraction by the procedure.</p> <p>The extraction procedure takes no arguments.</p> <p>When called, it returns a string consisting of all of the port&#39;s accumulated characters (regardless of the current position),removes the accumulated characters from the port, and resetsthe port&#39;s position</p> </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">string-output-port, extraction procedure</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="call-with-string-output-port"></a> call-with-string-output-port</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(call-with-string-output-port proc)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description"><p>Creates a textual output port that accumulates the characters written to it and calls proc with that output port as an argument.</p> <p>Whenever proc returns, a string consisting of all of the port&#39;s accumulated characters (regardless of the port&#39;s current position) is returned and the port is closed.</p> </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="1">Parameters</td> <td class="manual-plain-parameter-name">proc</td> <td class="manual-plain-parameter-description" colspan="2">proc must accept one argument</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">accumulated characters as string</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="call-with-bytevector-output-port"></a> call-with-bytevector-output-port</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(call-with-bytevector-output-port proc transcoder)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description"><p>Creates an output port that accumulates the bytes written to it and calls proc with that output port as an argument.</p> <p>Whenever proc returns, a bytevector consisting of all of the port&#39;s accumulated bytes (regardless of the port’s currentposition) is returned and the port is closed.</p> </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="1">Parameters</td> <td class="manual-plain-parameter-name">proc</td> <td class="manual-plain-parameter-description" colspan="2">proc must accept one argument</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">accumulated bytes as bytevector</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="open-bytevector-output-port"></a> open-bytevector-output-port</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(open-bytevector-output-port transcoder)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description"><p>Returns two values: an output port and an extraction procedure.</p> <p>The output port accumulates the bytes written to it for later extraction by the procedure.</p> <p>If transcoder is a transcoder, it becomes the transcoder associated with the port. If maybe-transcoder is #f or absent, the port will be a binary port and will support the port-position and set-port-position! operations.</p> <p>The extraction procedure takes no arguments. When called, it returns a bytevector consisting of all the port&#39;s accumulated bytes (regardless of the port’s current position), removes the accumulated bytes from the port, and resets the port&#39;s position.</p> </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="1">Parameters</td> <td class="manual-plain-parameter-name">transcoder</td> <td class="manual-plain-parameter-description" colspan="2">transcoder</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">bytevector-output-port and extraction procedure</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="bytevector-for-each"></a> bytevector-for-each</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(bytevector-for-each bv proc)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Applies proc element-wise to the elements of the bytevector for its side effects, in order from the first elements to the last. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="2">Parameters</td> <td class="manual-plain-parameter-name">bv</td> <td class="manual-plain-parameter-description" colspan="2">bytevector</td></tr> <tr class="manual-row"><td class="manual-plain-parameter-name">proc</td> <td colspan="3" class="manual-plain-parameter-description">proc must accept one argument</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">unspecified</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="display"></a> display</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(display obj) or (display obj textual-output-port)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description"><p><p>Writes a representation of obj to the given textual-output-port.</p></p> <p>Strings that appear in the written representation are not enclosed in doublequotes, and no characters are escaped within those strings.</p> <p>Character objects appear in the representation as if written by write-char instead of by write.</p> <p>The textual-output-port argument may be omitted, in which case it defaults to the value returned by current-output-port.</p> </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="2">Parameters</td> <td class="manual-plain-parameter-name">obj</td> <td class="manual-plain-parameter-description" colspan="2">object to write.</td></tr> <tr class="manual-row"><td class="manual-plain-parameter-name">textual-output-port</td> <td colspan="3" class="manual-plain-parameter-description">writes obj to textual-output-port</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">unspecified</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="newline"></a> newline</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(newline)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description"><p>This is equivalent to using write-char to write #\linefeed to textual-output-port. If textual-output-port is omitted, it defaults to the value returned by current-output-port.</p> </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="1">Parameters</td> <td class="manual-plain-parameter-name">textual-output-port</td> <td class="manual-plain-parameter-description" colspan="2">port to write</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">unspecified</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr class="manual-section"><td class="manual-section" colspan="4"><a name="SECTION7"></a> <span><a href="#MANUAL-TOP"><img src="man-images/small-up.gif" title="Manual top" alt="" border="0" /></a> <a href="#SECTION6"><img src="man-images/small-prev.gif" title="Previous manual section" alt="" border="0" /></a> <a href="#SECTION8"><img src="man-images/small-next.gif" title="Next manual section" alt="" border="0" /></a></span> <br /> <span class="manual-section-number">7</span> <span class="manual-section-title">File system.</span></td></tr> <tr><td colspan="4" class="manual-section-description">R6RS library Chapter 9. </td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="file-exists?"></a> file-exists?</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(file-exists? filename)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns #t if the named file exists at the time the procedure is called, #f otherwise. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">Returns #t if the named file exists at the time the procedure is called, #f otherwise.</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr class="manual-section"><td class="manual-section" colspan="4"><a name="SECTION8"></a> <span><a href="#MANUAL-TOP"><img src="man-images/small-up.gif" title="Manual top" alt="" border="0" /></a> <a href="#SECTION7"><img src="man-images/small-prev.gif" title="Previous manual section" alt="" border="0" /></a> <a href="#SECTION9"><img src="man-images/small-next.gif" title="Next manual section" alt="" border="0" /></a></span> <br /> <span class="manual-section-number">8</span> <span class="manual-section-title">Hashtables.</span></td></tr> <tr><td colspan="4" class="manual-section-description">R6RS library Chapter 13. </td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="make-eq-hashtable"></a> make-eq-hashtable</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(make-eq-hashtable) (make-eq-hashtable k)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description"><p>Returns a newly allocated mutable hashtable that accepts arbitrary objects as keys, and compares those keys with eq?. If an argument is given, the initial capacity of the hashtable is set to approximately k elements.</p> </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">A newly allocated mutable hashtable that accepts arbitrary objects as keys, and compares those keys with eq?. If an argument is given, the initial capacity of the hashtable is set to approximately k elements.</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="hashtable-set!"></a> hashtable-set!</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(hashtable-set! hashtable key obj)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Changes hashtable to associate key with obj, adding a new association or replacing any existing association for key. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">unspecified</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="hashtable-ref"></a> hashtable-ref</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(hashtable-ref hashtable key default)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns the value in hashtable associated with key. If hashtable does not contain an association for key, default is returned. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">the value in hashtable associated with key. If hashtable does not contain an association for key, default is returned.</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="hashtable-keys"></a> hashtable-keys</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(hashtable-keys hashtable)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">(not implmented) Returns a vector of all keys in hashtable. The order of the vector is unspecified. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">A vector of all keys in hashtable. The order of the vector is unspecified.</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr class="manual-section"><td class="manual-section" colspan="4"><a name="SECTION9"></a> <span><a href="#MANUAL-TOP"><img src="man-images/small-up.gif" title="Manual top" alt="" border="0" /></a> <a href="#SECTION8"><img src="man-images/small-prev.gif" title="Previous manual section" alt="" border="0" /></a> <a href="#SECTION10"><img src="man-images/small-next.gif" title="Next manual section" alt="" border="0" /></a></span> <br /> <span class="manual-section-number">9</span> <span class="manual-section-title">Eval.</span></td></tr> <tr><td colspan="4" class="manual-section-description">R6RS library Chapter 16. </td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="eval"></a> eval</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(eval expression environment)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description"><p>Evaluates expression in the specified environment and returns its value.</p> <p>Note that currently the environment argument is ignored.</p> </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">result</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr class="manual-section"><td class="manual-section" colspan="4"><a name="SECTION10"></a> <span><a href="#MANUAL-TOP"><img src="man-images/small-up.gif" title="Manual top" alt="" border="0" /></a> <a href="#SECTION9"><img src="man-images/small-prev.gif" title="Previous manual section" alt="" border="0" /></a> <a href="#SECTION11"><img src="man-images/small-next.gif" title="Next manual section" alt="" border="0" /></a></span> <br /> <span class="manual-section-number">10</span> <span class="manual-section-title">Mutable pairs.</span></td></tr> <tr><td colspan="4" class="manual-section-description">R6RS library Chapter 17. </td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="set-car!"></a> set-car!</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(set-car! pair obj)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Stores obj in the car field of pair. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">unspecified</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="set-cdr!"></a> set-cdr!</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(set-cdr! pair obj)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Stores obj in the cdr field of pair. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">unspecified</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr class="manual-section"><td class="manual-section" colspan="4"><a name="SECTION11"></a> <span><a href="#MANUAL-TOP"><img src="man-images/small-up.gif" title="Manual top" alt="" border="0" /></a> <a href="#SECTION10"><img src="man-images/small-prev.gif" title="Previous manual section" alt="" border="0" /></a> <a href="#SECTION12"><img src="man-images/small-next.gif" title="Next manual section" alt="" border="0" /></a></span> <br /> <span class="manual-section-number">11</span> <span class="manual-section-title">Regular expression.</span></td></tr> <tr><td colspan="4" class="manual-section-description">Regular expression is implmented with Oniguruma library.<br></td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="rxmatch"></a> rxmatch</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(rxmatch regexp string)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description"><p>Regexp is a regular expression object. A string string is matched by regexp. If it matches, the function returns a [regmatch] object. Otherwise it returns #f.</p> <p>You can use (#/regexp/ string) style instead of (rxmatch #/regexp/ string).</p> </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="2">Parameters</td> <td class="manual-plain-parameter-name">regexp</td> <td class="manual-plain-parameter-description" colspan="2">A regular expression object.</td></tr> <tr class="manual-row"><td class="manual-plain-parameter-name">string</td> <td colspan="3" class="manual-plain-parameter-description">String matched by regexp.</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">If it matches, the function returns a [regmatch] object. Otherwise it returns #f.</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="2">Examples</td> <td class="manual-plain-example" colspan="2">(rxmatch #/123/ "12") => #f</td></tr> <tr><td colspan="4" class="manual-plain-example">(rxmatch #/\d+/ "a345a") => [regmatch]</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="1">See also</td> <td class="manual-plain-reference-role">Regular expression.</td> <td class="manual-plain-reference-anchor" colspan="2"><a class="manual-plain-internal-reference" href="#regexp">regexp</a></td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="regexp"></a> regexp</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(regexp string)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Regexp is a regular expression object. A string string is matched by regexp. If it matches, the function returns a [regmatch] object. Otherwise it returns #f. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="2">Parameters</td> <td class="manual-plain-parameter-name">regexp</td> <td class="manual-plain-parameter-description" colspan="2">A regular expression object.</td></tr> <tr class="manual-row"><td class="manual-plain-parameter-name">string</td> <td colspan="3" class="manual-plain-parameter-description">String matched by regexp.</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">If it matches, the function returns a [regmatch] object. Otherwise it returns #f.</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="2">Examples</td> <td class="manual-plain-example" colspan="2">(#/123/ "12") => #f</td></tr> <tr><td colspan="4" class="manual-plain-example">(#/\d+/ "a345a") => [regmatch]</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="1">See also</td> <td class="manual-plain-reference-role">Regular expression.</td> <td class="manual-plain-reference-anchor" colspan="2"><a class="manual-plain-internal-reference" href="#rxmatch">rxmatch</a></td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="regexp?"></a> regexp?</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(regexp? obj)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns #t if obj is a regexp object. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">#t if obj is a regexp object.</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="2">Examples</td> <td class="manual-plain-example" colspan="2">(regexp? #/abc/) => #t</td></tr> <tr><td colspan="4" class="manual-plain-example">(regexp? "abc")  => #f</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="regexp->string"></a> regexp->string</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(regexp->string regexp)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns a source string describing the regexp regexp. The returned string is immutable. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">S source string describing the regexp regexp. The returned string is immutable.</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="1">Examples</td> <td class="manual-plain-example" colspan="2">(regexp->string #/abc/) => "abc"</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="rxmatch-start"></a> rxmatch-start</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(rxmatch-start match &amp;optional (i 0))</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description"><p>If i equals to zero, the functions return start of entire match. With positive integer I, it returns those of I-th submatches.</p> <p>It is an error to pass other values to I. It is allowed to pass #f to match for convenience. The functions return #f in such case.</p> </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="2">Parameters</td> <td class="manual-plain-parameter-name">match</td> <td class="manual-plain-parameter-description" colspan="2">[regmatch] object returned by rxmatch</td></tr> <tr class="manual-row"><td class="manual-plain-parameter-name">i</td> <td colspan="3" class="manual-plain-parameter-description">index</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">I-th submatches.</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="2">Examples</td> <td class="manual-plain-example" colspan="2">(rxmatch-start (#/\d+/ "aaaa")) => #f</td></tr> <tr><td colspan="4" class="manual-plain-example">(rxmatch-start (rxmatch #/(\d+)(a)/ "a345a") 2) => 4</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="rxmatch-end"></a> rxmatch-end</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(rxmatch-end match &amp;optional (i 0))</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description"><p>If i equals to zero, the functions return end of entire match. With positive integer I, it returns those of I-th submatches.</p> <p>It is an error to pass other values to I. It is allowed to pass #f to match for convenience. The functions return #f in such case.</p> </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="2">Parameters</td> <td class="manual-plain-parameter-name">match</td> <td class="manual-plain-parameter-description" colspan="2">[regmatch] object returned by rxmatch</td></tr> <tr class="manual-row"><td class="manual-plain-parameter-name">i</td> <td colspan="3" class="manual-plain-parameter-description">index</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">I-th submatches.</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="1">Examples</td> <td class="manual-plain-example" colspan="2">(rxmatch #/\d+/ "a345a") => 4</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="rxmatch-substring"></a> rxmatch-substring</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(rxmatch-substring match &amp;optional (i 0))</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description"><p>If i equals to zero, the functions return substring of entire match. With positive integer I, it returns those of I-th submatches.</p> <p>It is an error to pass other values to I. It is allowed to pass #f to match for convenience. The functions return #f in such case.</p> </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="2">Parameters</td> <td class="manual-plain-parameter-name">match</td> <td class="manual-plain-parameter-description" colspan="2">[regmatch] object returned by rxmatch</td></tr> <tr class="manual-row"><td class="manual-plain-parameter-name">i</td> <td colspan="3" class="manual-plain-parameter-description">index</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">I-th submatches.</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="1">Examples</td> <td class="manual-plain-example" colspan="2">(rxmatch-substring (#/\d+/ "a345a")) => "345"</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="rxmatch-after"></a> rxmatch-after</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(rxmatch-after match &amp;optional (i 0))</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns substring of the input string after match. If optional argument is given, the i-th submatch is used (0-th submatch is the entire match). </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">Substring of the input string after match.</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="1">Examples</td> <td class="manual-plain-example" colspan="2">(rxmatch-after (#/abc/ "123abcdef")) => "def"</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="rxmatch-before"></a> rxmatch-before</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(rxmatch-before match &amp;optional (i 0))</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns substring of the input string before match. If optional argument is given, the i-th submatch is used (0-th submatch is the entire match). </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">Substring of the input string before match.</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="1">Examples</td> <td class="manual-plain-example" colspan="2">(rxmatch-before (#/abc/ "123abcdef")) => "123"</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="regmatch"></a> regmatch</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(regmatch &amp;optional index)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Works same as (rxmatch-substring regmatch index), </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="1">Examples</td> <td class="manual-plain-example" colspan="2">((#/abc/ "123abcdef") 0) => "abc"</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="1">See also</td> <td class="manual-plain-reference-role">Regular expression.</td> <td class="manual-plain-reference-anchor" colspan="2"><a class="manual-plain-internal-reference" href="#rxmatch-substring">rxmatch-substring</a></td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="regmatch"></a> regmatch</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(regmatch &#39;before &amp;optional index)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Works same as (rxmatch-before regmatch) </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="1">Examples</td> <td class="manual-plain-example" colspan="2">((#/abc/ "123abcdef") &#39;before) => "123"</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="1">See also</td> <td class="manual-plain-reference-role">Regular expression.</td> <td class="manual-plain-reference-anchor" colspan="2"><a class="manual-plain-internal-reference" href="#rxmatch-before">rxmatch-before</a></td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="regmatch"></a> regmatch</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(regmatch &#39;after &amp;optional index)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Works same as (rxmatch-after regmatch) </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="1">Examples</td> <td class="manual-plain-example" colspan="2">((#/abc/ "123abcdef") &#39;after) => "def"</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="1">See also</td> <td class="manual-plain-reference-role">Regular expression.</td> <td class="manual-plain-reference-anchor" colspan="2"><a class="manual-plain-internal-reference" href="#rxmatch-after">rxmatch-after</a></td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="regexp-replace"></a> regexp-replace</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(regexp-replace regexp string substitution)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Replaces the part of string that matched to regexp for substitution. Just replaces the first match of regexp. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">replaced string</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="1">Examples</td> <td class="manual-plain-example" colspan="2">(regexp-replace #/abc/ "123abc456" "ABC") => "123ABC456"</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="regexp-replace-all"></a> regexp-replace-all</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(regexp-replace-all regexp string substitution)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Replaces the part of string that matched to regexp for substitution. Repeats the replacing throughout entire string. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">replaced string</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="string->regexp"></a> string->regexp</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(string->regexp string)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Takes string as a regexp specification, and constructs [regexp] object. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">[regexp] object</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="1">Examples</td> <td class="manual-plain-example" colspan="2">(string->regexp "abc") #/abc</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr class="manual-section"><td class="manual-section" colspan="4"><a name="SECTION12"></a> <span><a href="#MANUAL-TOP"><img src="man-images/small-up.gif" title="Manual top" alt="" border="0" /></a> <a href="#SECTION11"><img src="man-images/small-prev.gif" title="Previous manual section" alt="" border="0" /></a> <a href="#SECTION13"><img src="man-images/small-next.gif" title="Next manual section" alt="" border="0" /></a></span> <br /> <span class="manual-section-number">12</span> <span class="manual-section-title">System interfaces.</span></td></tr> <tr><td colspan="4" class="manual-section-description"></td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="sys-getenv"></a> sys-getenv</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(sys-getenv name)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns the value of the environment variable name as a string, or #f if the environment variable is not defined. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">The value of the environment variable name as a string, or #f if the environment variable is not defined.</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="1">Examples</td> <td class="manual-plain-example" colspan="2">(sys-getenv "QUERY_STRING")</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="sys-readdir"></a> sys-readdir</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(sys-readdir path)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns a list of strings of the directory entries. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">A list of strings of the directory entries.</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="get-timeofday"></a> get-timeofday</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(get-timeofday)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Get-timeofday </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">(get-timeofday)</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr class="manual-section"><td class="manual-section" colspan="4"><a name="SECTION13"></a> <span><a href="#MANUAL-TOP"><img src="man-images/small-up.gif" title="Manual top" alt="" border="0" /></a> <a href="#SECTION12"><img src="man-images/small-prev.gif" title="Previous manual section" alt="" border="0" /></a> <a href="#SECTION14"><img src="man-images/small-next.gif" title="Next manual section" alt="" border="0" /></a></span> <br /> <span class="manual-section-number">13</span> <span class="manual-section-title">Generic.</span></td></tr> <tr><td colspan="4" class="manual-section-description"></td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="let1"></a> let1</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(let1 var val body ...)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Same as (let ((var val)) body ...) </td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="macroexpand-1"></a> macroexpand-1</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(macroexpand-1 form)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Expand macro </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">expanded only once macro form.(Now you can expand only top-level defined macro)</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="macroexpand"></a> macroexpand</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(macroexpand form)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Expand macro </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">expanded macro form.(Now you can expand only top-level defined macro)</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="gensym"></a> gensym</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(gensym)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns a new symbol. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">A new symbol.</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="1">Examples</td> <td class="manual-plain-example" colspan="2">(gensym) => G100</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="digit->integer"></a> digit->integer</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(digit->integer char &amp;optional (radix 10))</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">If given character char is a valid digit character in radix radix number, the corresponding integer is returned. Otherwise #f is returned. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">If given character char is a valid digit character in radix radix number, the corresponding integer is returned. Otherwise #f is returned.</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="3">Examples</td> <td class="manual-plain-example" colspan="2">(digit->integer #\4) => 4</td></tr> <tr><td colspan="4" class="manual-plain-example">(digit->integer #\e 16) => 14</td></tr> <tr><td colspan="4" class="manual-plain-example">(digit->integer #\9 8) => #f</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="print"></a> print</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(print obj)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Writes a representation of obj to the current output port and (newline) Strings that appear in the written representation are not enclosed in doublequotes, and no characters are escaped within those strings. Character objects appear in the representation as if written by write-char instead of by write. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">unspecified values</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="map1"></a> map1</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(map1 proc l)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">The map1 procedure applies proc element-wise to the elements of the list and returns a list of the results, in order. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="2">Parameters</td> <td class="manual-plain-parameter-name">l</td> <td class="manual-plain-parameter-description" colspan="2">list</td></tr> <tr class="manual-row"><td class="manual-plain-parameter-name">proc</td> <td colspan="3" class="manual-plain-parameter-description">should accept as many arguments as there are lists and return a single value.</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">a list of the results</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="assoc-ref"></a> assoc-ref</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(assoc-ref lst key)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Returns the cdr of first pair whose car fields satisfies a given key. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">Returns the cdr of first pair whose car fields satisfies a given key.</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="read-line"></a> read-line</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(read-line  . port)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Reads one line (a sequence of characters terminated by newline or EOF) from port and returns a string. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">line as a string</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="write-to-file"></a> write-to-file</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(write-to-file path content)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Same as (call-with-output-file path (lambda (port) (display content obj))) </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">unspecified.</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="1">See also</td> <td class="manual-plain-reference-role">R6RS</td> <td class="manual-plain-reference-anchor" colspan="2"><a class="manual-plain-internal-reference" href="#call-with-output-file">call-with-output-file</a></td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="file->string"></a> file->string</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(file->string filename)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Read string from a file filename. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">whole file content as string</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="call-with-string-io"></a> call-with-string-io</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(call-with-string-io str proc)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description"><p>Convenient string I/O procedure.</p> <pre>(define (call-with-string-io str proc)<br> (receive (out get-string) (open-string-output-port)<br> (let1 in (open-string-input-port str)<br> (proc in out)<br> (get-string))))</pre> </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">output-string</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="call-with-string-input-port"></a> call-with-string-input-port</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(call-with-string-input-port str proc)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Creates a textual input port from string str and calls proc with that input port as an argument. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="1">Parameters</td> <td class="manual-plain-parameter-name">proc</td> <td class="manual-plain-parameter-description" colspan="2">proc must accept one argument</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">values proc returns</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr class="manual-section"><td class="manual-section" colspan="4"><a name="SECTION14"></a> <span><a href="#MANUAL-TOP"><img src="man-images/small-up.gif" title="Manual top" alt="" border="0" /></a> <a href="#SECTION13"><img src="man-images/small-prev.gif" title="Previous manual section" alt="" border="0" /></a> <a href="#SECTION15"><img src="man-images/small-next.gif" title="Next manual section" alt="" border="0" /></a></span> <br /> <span class="manual-section-number">14</span> <span class="manual-section-title">CGI.</span></td></tr> <tr><td colspan="4" class="manual-section-description">Note this library will go away once it is switched to the new CGI library.</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="cgi-escape"></a> cgi-escape</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(cgi-escape text)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Escape some not safe characters. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">escaped string</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="cgi-encode"></a> cgi-encode</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(cgi-encode text)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Apply "% encode" to string and return the result. Assumes input is UTF-8. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">encoded string</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="cgi-init"></a> cgi-init</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(cgi-init)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Initialize CGI library and returns get-parameter and get-request-method procedures. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">get-parameter and get-request-method procedures as multiple values.</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="1">Examples</td> <td class="manual-plain-example" colspan="2">(receive (get-parameter get-request-method) (cgi-init) ...)</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="cgi-header"></a> cgi-header</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(cgi-header)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Outputs HTTP header "Status: 200 OK\nContent-type: text/html; charset=utf-8\n" </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">unspecified</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="cgi-moved-header"></a> cgi-moved-header</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(cgi-moved-header url)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Outputs HTTP header "Status: 302 Moved Temporarily\nLocation: [url]\n\n" </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="1">Parameters</td> <td class="manual-plain-parameter-name">url</td> <td class="manual-plain-parameter-description" colspan="2">redirect URL</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">unspecified</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="cgi-parse-query-string"></a> cgi-parse-query-string</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(cgi-parse-query-string input)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Used internal </td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="cgi-decode"></a> cgi-decode</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(cgi-decode s)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Apply "% decode" to string and return the result.  Assumes input is UTF-8. </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">decoded string</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr class="manual-section"><td class="manual-section" colspan="4"><a name="srfi-1"></a> <a name="SECTION15"></a> <span><a href="#MANUAL-TOP"><img src="man-images/small-up.gif" title="Manual top" alt="" border="0" /></a> <a href="#SECTION14"><img src="man-images/small-prev.gif" title="Previous manual section" alt="" border="0" /></a> <a href="#SECTION16"><img src="man-images/small-next.gif" title="Next manual section" alt="" border="0" /></a></span> <br /> <span class="manual-section-number">15</span> <span class="manual-section-title">SRFI-1 List library.</span></td></tr> <tr><td colspan="4" class="manual-section-description"></td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="first"></a> first</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(first pair)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Synonym for car </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">(car pair)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="1">See also</td> <td class="manual-plain-reference-role">SRFI-1</td> <td class="manual-plain-reference-anchor" colspan="2"><a class="manual-plain-external-reference" href="http://srfi.schemers.org/srfi-1/srfi-1.html">SRFI-1 List Library</a></td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="second"></a> second</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(second pair)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Synonym for cadr </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">(cadr pair)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="1">See also</td> <td class="manual-plain-reference-role">SRFI-1</td> <td class="manual-plain-reference-anchor" colspan="2"><a class="manual-plain-external-reference" href="http://srfi.schemers.org/srfi-1/srfi-1.html">SRFI-1 List Library</a></td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="third"></a> third</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(third pair)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Synonym for caddr </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">(caddr pair)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="1">See also</td> <td class="manual-plain-reference-role">SRFI-1</td> <td class="manual-plain-reference-anchor" colspan="2"><a class="manual-plain-external-reference" href="http://srfi.schemers.org/srfi-1/srfi-1.html">SRFI-1 List Library</a></td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="fourth"></a> fourth</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(fourth pair)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Synonym for cadddr </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">(cadddr pair)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="1">See also</td> <td class="manual-plain-reference-role">SRFI-1</td> <td class="manual-plain-reference-anchor" colspan="2"><a class="manual-plain-external-reference" href="http://srfi.schemers.org/srfi-1/srfi-1.html">SRFI-1 List Library</a></td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="cons*"></a> cons*</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(cons* elt1 elt2 ...)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description"></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">(cons elt1 (cons elt2 (cons ... eltn)))</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="2">Examples</td> <td class="manual-plain-example" colspan="2">(cons* 1 2 3 4) => (1 2 3 . 4)</td></tr> <tr><td colspan="4" class="manual-plain-example">(cons* 1) => 1</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="1">See also</td> <td class="manual-plain-reference-role">SRFI-1</td> <td class="manual-plain-reference-anchor" colspan="2"><a class="manual-plain-external-reference" href="http://srfi.schemers.org/srfi-1/srfi-1.html">SRFI-1 List Library</a></td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr class="manual-section"><td class="manual-section" colspan="4"><a name="SECTION16"></a> <span><a href="#MANUAL-TOP"><img src="man-images/small-up.gif" title="Manual top" alt="" border="0" /></a> <a href="#SECTION15"><img src="man-images/small-prev.gif" title="Previous manual section" alt="" border="0" /></a> <a href="#SECTION17"><img src="man-images/small-next.gif" title="Next manual section" alt="" border="0" /></a></span> <br /> <span class="manual-section-number">16</span> <span class="manual-section-title">SRFI-8 Binding to multiple values.</span></td></tr> <tr><td colspan="4" class="manual-section-description"></td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="receive"></a> receive</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(receive formals expression body ...)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description"><p>This is the way to receive multiple values.</p> <p>Formals can be a (maybe-improper) list of symbols.</p> <p>Expression is evaluated, and the returned value(s) are bound to formals like the binding of lambda formals, then body ... are evaluated.</p> </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">The results of the last expression in the body are the values of the receive-expression.</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="1">Examples</td> <td class="manual-plain-example" colspan="2">(receive (a b c) (values 1 2 3) (+ a b c)) => 6</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr class="manual-section"><td class="manual-section" colspan="4"><a name="SECTION17"></a> <span><a href="#MANUAL-TOP"><img src="man-images/small-up.gif" title="Manual top" alt="" border="0" /></a> <a href="#SECTION16"><img src="man-images/small-prev.gif" title="Previous manual section" alt="" border="0" /></a> <a href="#SECTION18"><img src="man-images/small-next.gif" title="Next manual section" alt="" border="0" /></a></span> <br /> <span class="manual-section-number">17</span> <span class="manual-section-title">SRFI-28 Basic format strings.</span></td></tr> <tr><td colspan="4" class="manual-section-description"></td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="format"></a> format</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(format string arg ...) (format port string arg ...)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description"><p>Format arg ... according to string.</p> <p>port specifies the destination;</p> <p>if it is an output port, the formatted result is written to it;</p> <p>if it is #t, the result is written to the current output port;</p> <p>if it is #f, the formatted result is returned as a string.</p> <p>Port can be omitted, as SRFI-28 format; it has the same effects as giving #f to the port.</p> <p>string is a string that contains format directives.</p> <p>A format directive is a character sequence begins with tilda, `~&#39;, and ends with some specific characters.</p> <p>The rest of string is copied to the output as is.</p> <p>Currently supported directive is ~a/~A (The corresponding argument is printed by display.), ~s/~S (The corresponding argument is printed by write.)</p> </td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Returns</td> <td colspan="3" class="manual-plain-returns">unspecified or string</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="2">Examples</td> <td class="manual-plain-example" colspan="2">(format #f "apple is ~a" "sweet") => "apple is sweet"</td></tr> <tr><td colspan="4" class="manual-plain-example">(call-with-output-string (lambda (out) (format out "apple is ~a" "sweet"))) => "apple is sweet"</td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="hashtable-for-each"></a> hashtable-for-each</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(hashtable-for-each proc ht)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description">Todo document </td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr class="manual-section"><td class="manual-section" colspan="4"><a name="SECTION18"></a> <span><a href="#MANUAL-TOP"><img src="man-images/small-up.gif" title="Manual top" alt="" border="0" /></a> <a href="#SECTION17"><img src="man-images/small-prev.gif" title="Previous manual section" alt="" border="0" /></a> <img src="man-images/small-next-blind.gif" title="" alt="" border="0" /></span> <br /> <span class="manual-section-number">18</span> <span class="manual-section-title">Pattern matching.</span></td></tr> <tr><td colspan="4" class="manual-section-description">A port of Andrew Wright&#39;s pattern matching macro library. See the Gauche&#39;s pattern match document </td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr> <tr><td colspan="4" class="manual-plain-title"><span><a name="match"></a> match</span></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Form</td> <td colspan="3" class="manual-plain-form">(match)</td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind">Description</td> <td colspan="3" class="manual-plain-description"></td></tr> <tr class="manual-row"><td class="manual-plain-entry-kind" rowspan="1">See also</td> <td class="manual-plain-reference-role">Gauche&#39;s manual</td> <td class="manual-plain-reference-anchor" colspan="2"><a class="manual-plain-external-reference" href="http://practical-scheme.net/gauche/man/gauche-refe_163.html#SEC439">match</a></td></tr> <tr class="manual-plain-end-of-entry"><td class="manual-plain-end-of-entry" colspan="4"><hr class="manual-plain-end-of-entry" /></td></tr></table> <a name="MANUAL-INDEX"></a> <div class="manual-alphabetic-index-header">Alphabetic index:</div> <div style="margin-left:12px;"><table border="3" class="manual-alphabetic-index"><tr><td class="manual-header-title"><a href="#*">*</a></td> <td class="manual-header-form">(* z1 ...)</td> <td class="manual-header-description">Returns the product of their arguments.</td></tr> <tr><td class="manual-header-title"><a href="#+">+</a></td> <td class="manual-header-form">(+ z1 ...)</td> <td class="manual-header-description">Returns the sum of their arguments.</td></tr> <tr><td class="manual-header-title"><a href="#-">-</a></td> <td class="manual-header-form">(- z1 z2 ...) (- z)</td> <td class="manual-header-description">With two or more arguments, this procedures returns the difference of its arguments, associating to the left.</td></tr> <tr><td class="manual-header-title"><a href="#/">/</a></td> <td class="manual-header-form">(/ z1 ...)</td> <td class="manual-header-description">Returns the division of their arguments.</td></tr> <tr><td class="manual-header-title"><a href="#<"><</a></td> <td class="manual-header-form">(< x1 x2 x3 ...)</td> <td class="manual-header-description">Returns #t if its arguments are monotonically increasing and #f otherwise.</td></tr> <tr><td class="manual-header-title"><a href="#<="><=</a></td> <td class="manual-header-form">(<= x1 x2 x3 ...)</td> <td class="manual-header-description">Returns #t if its arguments are monotonically nondecreasing and #f otherwise.</td></tr> <tr><td class="manual-header-title"><a href="#=">=</a></td> <td class="manual-header-form">(= x1 x2 x3 ...)</td> <td class="manual-header-description">Returns #t if its arguments are equal and #f otherwise.</td></tr> <tr><td class="manual-header-title"><a href="#>">></a></td> <td class="manual-header-form">(> x1 x2 x3 ...)</td> <td class="manual-header-description">Returns #t if its arguments are monotonically decreasing and #f otherwise.</td></tr> <tr><td class="manual-header-title"><a href="#>=">>=</a></td> <td class="manual-header-form">(> x1 x2 x3 ...)</td> <td class="manual-header-description">Returns #t if its arguments are monotonically increasing and #f otherwise.</td></tr> <tr><td class="manual-header-title"><a href="#abs">abs</a></td> <td class="manual-header-form">(abs n)</td> <td class="manual-header-description">Returns the absolute value of its argument.</td></tr> <tr><td class="manual-header-title"><a href="#and">and</a></td> <td class="manual-header-form">(and [test1] ...)</td> <td class="manual-header-description">If there are no [test]s, #t is returned.</td></tr> <tr><td class="manual-header-title"><a href="#append">append</a></td> <td class="manual-header-form">(append  . ll)</td> <td class="manual-header-description">Returns a possibly improper list consisting of the elements of the first list followed by the elements of the other lists, with obj as the cdr of the final pair.</td></tr> <tr><td class="manual-header-title"><a href="#apply">apply</a></td> <td class="manual-header-form">(apply proc arg1 ... rest-args)</td> <td class="manual-header-description">The apply procedure calls proc with the elements of the list (append (list arg1 ...) rest-args) as the actual arguments.</td></tr> <tr><td class="manual-header-title"><a href="#assoc">assoc</a></td> <td class="manual-header-form">(assoc obj alist)</td> <td class="manual-header-description"><p>Find the first pair in alist whose car field satisfies a given condition, and returns that pair without traversing alist further.</td></tr> <tr><td class="manual-header-title"><a href="#assoc-ref">assoc-ref</a></td> <td class="manual-header-form">(assoc-ref lst key)</td> <td class="manual-header-description">Returns the cdr of first pair whose car fields satisfies a given key.</td></tr> <tr><td class="manual-header-title"><a href="#assv">assv</a></td> <td class="manual-header-form">(assv obj alist)</td> <td class="manual-header-description"><p>Find the first pair in alist whose car field satisfies a given condition, and returns that pair without traversing alist further.</td></tr> <tr><td class="manual-header-title"><a href="#begin">begin</a></td> <td class="manual-header-form">(begin [form] ...) (begin [expression] [expression] ...)</td> <td class="manual-header-description"><p>The [begin] keyword has two different roles, depending on its context:</p> <p>It may appear as a form in a [body] , [library body] , or [top-level body], or directly nested in a begin form that appears in a body.</td></tr> <tr><td class="manual-header-title"><a href="#boolean?">boolean?</a></td> <td class="manual-header-form">(boolean? obj)</td> <td class="manual-header-description">Returns #t if obj is either #t or #f and returns #f otherwise.</td></tr> <tr><td class="manual-header-title"><a href="#bytevector-for-each">bytevector-for-each</a></td> <td class="manual-header-form">(bytevector-for-each bv proc)</td> <td class="manual-header-description">Applies proc element-wise to the elements of the bytevector for its side effects, in order from the first elements to the last.</td></tr> <tr><td class="manual-header-title"><a href="#bytevector-length">bytevector-length</a></td> <td class="manual-header-form">(bytevector-length bytevector)</td> <td class="manual-header-description">Returns, as an exact integer object, the number of bytes in bytevector.</td></tr> <tr><td class="manual-header-title"><a href="#bytevector-u8-ref">bytevector-u8-ref</a></td> <td class="manual-header-form">(bytevector-u8-ref bytevector k)</td> <td class="manual-header-description">Returns the byte at index k of bytevector, as an octet.</td></tr> <tr><td class="manual-header-title"><a href="#bytevector-u8-set!">bytevector-u8-set!</a></td> <td class="manual-header-form">(bytevector-u8-set! bytevector k octet)</td> <td class="manual-header-description">Stores octet in element k of bytevector.</td></tr> <tr><td class="manual-header-title"><a href="#caaaaar">caaaaar</a></td> <td class="manual-header-form">(caaaaar p)</td> <td class="manual-header-description">returns (car (car (car (car (car p))))) </td></tr> <tr><td class="manual-header-title"><a href="#caaaadr">caaaadr</a></td> <td class="manual-header-form">(caaaadr p)</td> <td class="manual-header-description">returns (car (car (car (car (cdr p))))) </td></tr> <tr><td class="manual-header-title"><a href="#caaaar">caaaar</a></td> <td class="manual-header-form">(caaaar p)</td> <td class="manual-header-description">returns (car (car (car (car p)))) </td></tr> <tr><td class="manual-header-title"><a href="#caaadar">caaadar</a></td> <td class="manual-header-form">(caaadar p)</td> <td class="manual-header-description">returns (car (car (car (cdr (car p))))) </td></tr> <tr><td class="manual-header-title"><a href="#caaaddr">caaaddr</a></td> <td class="manual-header-form">(caaaddr p)</td> <td class="manual-header-description">returns (car (car (car (cdr (cdr p))))) </td></tr> <tr><td class="manual-header-title"><a href="#caaadr">caaadr</a></td> <td class="manual-header-form">(caaadr p)</td> <td class="manual-header-description">returns (car (car (car (cdr p)))) </td></tr> <tr><td class="manual-header-title"><a href="#caaar">caaar</a></td> <td class="manual-header-form">(caaar p)</td> <td class="manual-header-description">returns (car (car (car p))) </td></tr> <tr><td class="manual-header-title"><a href="#caadaar">caadaar</a></td> <td class="manual-header-form">(caadaar p)</td> <td class="manual-header-description">returns (car (car (cdr (car (car p))))) </td></tr> <tr><td class="manual-header-title"><a href="#caadadr">caadadr</a></td> <td class="manual-header-form">(caadadr p)</td> <td class="manual-header-description">returns (car (car (cdr (car (cdr p))))) </td></tr> <tr><td class="manual-header-title"><a href="#caadar">caadar</a></td> <td class="manual-header-form">(caadar p)</td> <td class="manual-header-description">returns (car (car (cdr (car p)))) </td></tr> <tr><td class="manual-header-title"><a href="#caaddar">caaddar</a></td> <td class="manual-header-form">(caaddar p)</td> <td class="manual-header-description">returns (car (car (cdr (cdr (car p))))) </td></tr> <tr><td class="manual-header-title"><a href="#caadddr">caadddr</a></td> <td class="manual-header-form">(caadddr p)</td> <td class="manual-header-description">returns (car (car (cdr (cdr (cdr p))))) </td></tr> <tr><td class="manual-header-title"><a href="#caaddr">caaddr</a></td> <td class="manual-header-form">(caaddr p)</td> <td class="manual-header-description">returns (car (car (cdr (cdr p)))) </td></tr> <tr><td class="manual-header-title"><a href="#caadr">caadr</a></td> <td class="manual-header-form">(caadr p)</td> <td class="manual-header-description">returns (car (car (cdr p))) </td></tr> <tr><td class="manual-header-title"><a href="#caar">caar</a></td> <td class="manual-header-form">(caar p)</td> <td class="manual-header-description">returns (car (car p)) </td></tr> <tr><td class="manual-header-title"><a href="#cadaaar">cadaaar</a></td> <td class="manual-header-form">(cadaaar p)</td> <td class="manual-header-description">returns (car (cdr (car (car (car p))))) </td></tr> <tr><td class="manual-header-title"><a href="#cadaadr">cadaadr</a></td> <td class="manual-header-form">(cadaadr p)</td> <td class="manual-header-description">returns (car (cdr (car (car (cdr p))))) </td></tr> <tr><td class="manual-header-title"><a href="#cadaar">cadaar</a></td> <td class="manual-header-form">(cadaar p)</td> <td class="manual-header-description">returns (car (cdr (car (car p)))) </td></tr> <tr><td class="manual-header-title"><a href="#cadadar">cadadar</a></td> <td class="manual-header-form">(cadadar p)</td> <td class="manual-header-description">returns (car (cdr (car (cdr (car p))))) </td></tr> <tr><td class="manual-header-title"><a href="#cadaddr">cadaddr</a></td> <td class="manual-header-form">(cadaddr p)</td> <td class="manual-header-description">returns (car (cdr (car (cdr (cdr p))))) </td></tr> <tr><td class="manual-header-title"><a href="#cadadr">cadadr</a></td> <td class="manual-header-form">(cadadr p)</td> <td class="manual-header-description">returns (car (cdr (car (cdr p)))) </td></tr> <tr><td class="manual-header-title"><a href="#cadar">cadar</a></td> <td class="manual-header-form">(cadar p)</td> <td class="manual-header-description">returns (car (cdr (car p))) </td></tr> <tr><td class="manual-header-title"><a href="#caddaar">caddaar</a></td> <td class="manual-header-form">(caddaar p)</td> <td class="manual-header-description">returns (car (cdr (cdr (car (car p))))) </td></tr> <tr><td class="manual-header-title"><a href="#caddadr">caddadr</a></td> <td class="manual-header-form">(caddadr p)</td> <td class="manual-header-description">returns (car (cdr (cdr (car (cdr p))))) </td></tr> <tr><td class="manual-header-title"><a href="#caddar">caddar</a></td> <td class="manual-header-form">(caddar p)</td> <td class="manual-header-description">returns (car (cdr (cdr (car p)))) </td></tr> <tr><td class="manual-header-title"><a href="#cadddar">cadddar</a></td> <td class="manual-header-form">(cadddar p)</td> <td class="manual-header-description">returns (car (cdr (cdr (cdr (car p))))) </td></tr> <tr><td class="manual-header-title"><a href="#caddddr">caddddr</a></td> <td class="manual-header-form">(caddddr p)</td> <td class="manual-header-description">returns (car (cdr (cdr (cdr (cdr p))))) </td></tr> <tr><td class="manual-header-title"><a href="#cadddr">cadddr</a></td> <td class="manual-header-form">(cadddr p)</td> <td class="manual-header-description">returns (car (cdr (cdr (cdr p)))) </td></tr> <tr><td class="manual-header-title"><a href="#caddr">caddr</a></td> <td class="manual-header-form">(caddr p)</td> <td class="manual-header-description">returns (car (cdr (cdr p))) </td></tr> <tr><td class="manual-header-title"><a href="#cadr">cadr</a></td> <td class="manual-header-form">(cadr p)</td> <td class="manual-header-description">returns (car (cdr p)) </td></tr> <tr><td class="manual-header-title"><a href="#call-with-bytevector-output-port">call-with-bytevector-output-port</a></td> <td class="manual-header-form">(call-with-bytevector-output-port proc transcoder)</td> <td class="manual-header-description"><p>Creates an output port that accumulates the bytes written to it and calls proc with that output port as an argument.</p> <p>Whenever proc returns, a bytevector consisting of all of the port&#39;s accumulated bytes (regardless of the port’s currentposition) is returned and the port is closed.</p> </td></tr> <tr><td class="manual-header-title"><a href="#call-with-current-continuation">call-with-current-continuation</a></td> <td class="manual-header-form">(call-with-current-continuation proc)</td> <td class="manual-header-description"><p>The procedure call-with-current-continuation (which is the same as the procedure call/cc) packages the current continuation as an "escape procedure"and passes it as an argument to proc.</p> <p>The escape procedure is a Scheme procedure that, if it is later called, will abandon whatever continuation is in effect at that later time and will instead reinstate the continuation that was in effect when the escape procedure was created.</p> </td></tr> <tr><td class="manual-header-title"><a href="#call-with-input-file">call-with-input-file</a></td> <td class="manual-header-form">(call-with-input-file filename proc)</td> <td class="manual-header-description"><p>Open the file named by filename for input, with no specified file options, and call proc with the obtained port as an argument.</p> <p>If proc returns, the port is closed automatically and the values returned by proc are returned.</td></tr> <tr><td class="manual-header-title"><a href="#call-with-output-file">call-with-output-file</a></td> <td class="manual-header-form">(call-with-output-file filename proc)</td> <td class="manual-header-description"><p>Open the file named by filename for output, with no specified file options, and call proc with the obtained port as an argument.</p> <p>If proc returns, the port is closed automatically and the values returned by proc are returned.</td></tr> <tr><td class="manual-header-title"><a href="#call-with-string-input-port">call-with-string-input-port</a></td> <td class="manual-header-form">(call-with-string-input-port str proc)</td> <td class="manual-header-description">Creates a textual input port from string str and calls proc with that input port as an argument.</td></tr> <tr><td class="manual-header-title"><a href="#call-with-string-io">call-with-string-io</a></td> <td class="manual-header-form">(call-with-string-io str proc)</td> <td class="manual-header-description"><p>Convenient string I/O procedure.</p> <pre>(define (call-with-string-io str proc)<br> (receive (out get-string) (open-string-output-port)<br> (let1 in (open-string-input-port str)<br> (proc in out)<br> (get-string))))</pre> </td></tr> <tr><td class="manual-header-title"><a href="#call-with-string-output-port">call-with-string-output-port</a></td> <td class="manual-header-form">(call-with-string-output-port proc)</td> <td class="manual-header-description"><p>Creates a textual output port that accumulates the characters written to it and calls proc with that output port as an argument.</p> <p>Whenever proc returns, a string consisting of all of the port&#39;s accumulated characters (regardless of the port&#39;s current position) is returned and the port is closed.</p> </td></tr> <tr><td class="manual-header-title"><a href="#call-with-values">call-with-values</a></td> <td class="manual-header-form">(call-with-values producer consumer)</td> <td class="manual-header-description">Calls producer with no arguments and a continuation that, when passed some values, calls the consumer procedure with those values as arguments.</td></tr> <tr><td class="manual-header-title"><a href="#car">car</a></td> <td class="manual-header-form">(car pair)</td> <td class="manual-header-description">Returns the contents of the car field of pair.</td></tr> <tr><td class="manual-header-title"><a href="#case">case</a></td> <td class="manual-header-form">(case [key] [case clause1] [case clause2] ...)</td> <td class="manual-header-description"><p>case expression is evaluated as follows.</p> <p>[Key] is evaluated and its result is compared using eqv? against the data represented by the [datum]s of each [case clause] in turn, proceeding in order from left to right through the set of clauses.</p> <p>If the result of evaluating [key] is equivalent to a datum of a [case clause], the corresponding [expression]s are evaluated from left to right and the results of the last expression in the [case clause] are returned as the results of the case expression.</td></tr> <tr><td class="manual-header-title"><a href="#cdaaaar">cdaaaar</a></td> <td class="manual-header-form">(cdaaaar p)</td> <td class="manual-header-description">returns (cdr (car (car (car (car p))))) </td></tr> <tr><td class="manual-header-title"><a href="#cdaaadr">cdaaadr</a></td> <td class="manual-header-form">(cdaaadr p)</td> <td class="manual-header-description">returns (cdr (car (car (car (cdr p))))) </td></tr> <tr><td class="manual-header-title"><a href="#cdaaar">cdaaar</a></td> <td class="manual-header-form">(cdaaar p)</td> <td class="manual-header-description">returns (cdr (car (car (car p)))) </td></tr> <tr><td class="manual-header-title"><a href="#cdaadar">cdaadar</a></td> <td class="manual-header-form">(cdaadar p)</td> <td class="manual-header-description">returns (cdr (car (car (cdr (car p))))) </td></tr> <tr><td class="manual-header-title"><a href="#cdaaddr">cdaaddr</a></td> <td class="manual-header-form">(cdaaddr p)</td> <td class="manual-header-description">returns (cdr (car (car (cdr (cdr p))))) </td></tr> <tr><td class="manual-header-title"><a href="#cdaadr">cdaadr</a></td> <td class="manual-header-form">(cdaadr p)</td> <td class="manual-header-description">returns (cdr (car (car (cdr p)))) </td></tr> <tr><td class="manual-header-title"><a href="#cdaar">cdaar</a></td> <td class="manual-header-form">(cdaar p)</td> <td class="manual-header-description">returns (cdr (car (car p))) </td></tr> <tr><td class="manual-header-title"><a href="#cdadaar">cdadaar</a></td> <td class="manual-header-form">(cdadaar p)</td> <td class="manual-header-description">returns (cdr (car (cdr (car (car p))))) </td></tr> <tr><td class="manual-header-title"><a href="#cdadadr">cdadadr</a></td> <td class="manual-header-form">(cdadadr p)</td> <td class="manual-header-description">returns (cdr (car (cdr (car (cdr p))))) </td></tr> <tr><td class="manual-header-title"><a href="#cdadar">cdadar</a></td> <td class="manual-header-form">(cdadar p)</td> <td class="manual-header-description">returns (cdr (car (cdr (car p)))) </td></tr> <tr><td class="manual-header-title"><a href="#cdaddar">cdaddar</a></td> <td class="manual-header-form">(cdaddar p)</td> <td class="manual-header-description">returns (cdr (car (cdr (cdr (car p))))) </td></tr> <tr><td class="manual-header-title"><a href="#cdadddr">cdadddr</a></td> <td class="manual-header-form">(cdadddr p)</td> <td class="manual-header-description">returns (cdr (car (cdr (cdr (cdr p))))) </td></tr> <tr><td class="manual-header-title"><a href="#cdaddr">cdaddr</a></td> <td class="manual-header-form">(cdaddr p)</td> <td class="manual-header-description">returns (cdr (car (cdr (cdr p)))) </td></tr> <tr><td class="manual-header-title"><a href="#cdadr">cdadr</a></td> <td class="manual-header-form">(cdadr p)</td> <td class="manual-header-description">returns (cdr (car (cdr p))) </td></tr> <tr><td class="manual-header-title"><a href="#cdar">cdar</a></td> <td class="manual-header-form">(cdar p)</td> <td class="manual-header-description">returns (cdr (car p)) </td></tr> <tr><td class="manual-header-title"><a href="#cddaaar">cddaaar</a></td> <td class="manual-header-form">(cddaaar p)</td> <td class="manual-header-description">returns (cdr (cdr (car (car (car p))))) </td></tr> <tr><td class="manual-header-title"><a href="#cddaadr">cddaadr</a></td> <td class="manual-header-form">(cddaadr p)</td> <td class="manual-header-description">returns (cdr (cdr (car (car (cdr p))))) </td></tr> <tr><td class="manual-header-title"><a href="#cddaar">cddaar</a></td> <td class="manual-header-form">(cddaar p)</td> <td class="manual-header-description">returns (cdr (cdr (car (car p)))) </td></tr> <tr><td class="manual-header-title"><a href="#cddadar">cddadar</a></td> <td class="manual-header-form">(cddadar p)</td> <td class="manual-header-description">returns (cdr (cdr (car (cdr (car p))))) </td></tr> <tr><td class="manual-header-title"><a href="#cddaddr">cddaddr</a></td> <td class="manual-header-form">(cddaddr p)</td> <td class="manual-header-description">returns (cdr (cdr (car (cdr (cdr p))))) </td></tr> <tr><td class="manual-header-title"><a href="#cddadr">cddadr</a></td> <td class="manual-header-form">(cddadr p)</td> <td class="manual-header-description">returns (cdr (cdr (car (cdr p)))) </td></tr> <tr><td class="manual-header-title"><a href="#cddar">cddar</a></td> <td class="manual-header-form">(cddar p)</td> <td class="manual-header-description">returns (cdr (cdr (car p))) </td></tr> <tr><td class="manual-header-title"><a href="#cdddaar">cdddaar</a></td> <td class="manual-header-form">(cdddaar p)</td> <td class="manual-header-description">returns (cdr (cdr (cdr (car (car p))))) </td></tr> <tr><td class="manual-header-title"><a href="#cdddadr">cdddadr</a></td> <td class="manual-header-form">(cdddadr p)</td> <td class="manual-header-description">returns (cdr (cdr (cdr (car (cdr p))))) </td></tr> <tr><td class="manual-header-title"><a href="#cdddar">cdddar</a></td> <td class="manual-header-form">(cdddar p)</td> <td class="manual-header-description">returns (cdr (cdr (cdr (car p)))) </td></tr> <tr><td class="manual-header-title"><a href="#cddddar">cddddar</a></td> <td class="manual-header-form">(cddddar p)</td> <td class="manual-header-description">returns (cdr (cdr (cdr (cdr (car p))))) </td></tr> <tr><td class="manual-header-title"><a href="#cdddddr">cdddddr</a></td> <td class="manual-header-form">(cdddddr p)</td> <td class="manual-header-description">returns (cdr (cdr (cdr (cdr (cdr p))))) </td></tr> <tr><td class="manual-header-title"><a href="#cddddr">cddddr</a></td> <td class="manual-header-form">(cddddr p)</td> <td class="manual-header-description">returns (cdr (cdr (cdr (cdr p)))) </td></tr> <tr><td class="manual-header-title"><a href="#cdddr">cdddr</a></td> <td class="manual-header-form">(cdddr p)</td> <td class="manual-header-description">returns (cdr (cdr (cdr p))) </td></tr> <tr><td class="manual-header-title"><a href="#cddr">cddr</a></td> <td class="manual-header-form">(cddr p)</td> <td class="manual-header-description">returns (cdr (cdr p)) </td></tr> <tr><td class="manual-header-title"><a href="#cdr">cdr</a></td> <td class="manual-header-form">(cdr pair)</td> <td class="manual-header-description">Returns the contents of the cdr field of pair.</td></tr> <tr><td class="manual-header-title"><a href="#cgi-decode">cgi-decode</a></td> <td class="manual-header-form">(cgi-decode s)</td> <td class="manual-header-description">Apply "% decode" to string and return the result.</td></tr> <tr><td class="manual-header-title"><a href="#cgi-encode">cgi-encode</a></td> <td class="manual-header-form">(cgi-encode text)</td> <td class="manual-header-description">Apply "% encode" to string and return the result.</td></tr> <tr><td class="manual-header-title"><a href="#cgi-escape">cgi-escape</a></td> <td class="manual-header-form">(cgi-escape text)</td> <td class="manual-header-description">Escape some not safe characters.</td></tr> <tr><td class="manual-header-title"><a href="#cgi-header">cgi-header</a></td> <td class="manual-header-form">(cgi-header)</td> <td class="manual-header-description">Outputs HTTP header "Status: 200 OK\nContent-type: text/html; charset=utf-8\n" </td></tr> <tr><td class="manual-header-title"><a href="#cgi-init">cgi-init</a></td> <td class="manual-header-form">(cgi-init)</td> <td class="manual-header-description">Initialize CGI library and returns get-parameter and get-request-method procedures.</td></tr> <tr><td class="manual-header-title"><a href="#cgi-moved-header">cgi-moved-header</a></td> <td class="manual-header-form">(cgi-moved-header url)</td> <td class="manual-header-description">Outputs HTTP header "Status: 302 Moved Temporarily\nLocation: [url]\n\n" </td></tr> <tr><td class="manual-header-title"><a href="#cgi-parse-query-string">cgi-parse-query-string</a></td> <td class="manual-header-form">(cgi-parse-query-string input)</td> <td class="manual-header-description">used internal </td></tr> <tr><td class="manual-header-title"><a href="#char->integer">char->integer</a></td> <td class="manual-header-form">(char->integer char)</td> <td class="manual-header-description">Given a character, char->integer returns its Unicode scalar value as an exact integer object.</td></tr> <tr><td class="manual-header-title"><a href="#char<=?">char<=?</a></td> <td class="manual-header-form">(char<=? char1 char2 char3 ...)</td> <td class="manual-header-description">Impose a total ordering on the set of characters according to their Unicode scalar values.</td></tr> <tr><td class="manual-header-title"><a href="#char<?">char<?</a></td> <td class="manual-header-form">(char&amp;lt;? char1 char2 char3 ...)</td> <td class="manual-header-description">Impose a total ordering on the set of characters according to their Unicode scalar values.</td></tr> <tr><td class="manual-header-title"><a href="#char=?">char=?</a></td> <td class="manual-header-form">(char=? char1 char2 char3 ...)</td> <td class="manual-header-description">Returns #t if all given charctors are same charctor.</td></tr> <tr><td class="manual-header-title"><a href="#char>=?">char>=?</a></td> <td class="manual-header-form">(char>=? char1 char2 char3 ...)</td> <td class="manual-header-description">Impose a total ordering on the set of characters according to their Unicode scalar values.</td></tr> <tr><td class="manual-header-title"><a href="#char>?">char>?</a></td> <td class="manual-header-form">(char>? char1 char2 char3 ...)</td> <td class="manual-header-description">Impose a total ordering on the set of characters according to their Unicode scalar values.</td></tr> <tr><td class="manual-header-title"><a href="#char?">char?</a></td> <td class="manual-header-form">(char? obj)</td> <td class="manual-header-description">Returns #t if obj is a character, otherwise returns #f.</td></tr> <tr><td class="manual-header-title"><a href="#close-input-port">close-input-port</a></td> <td class="manual-header-form">(close-input-port input-port)</td> <td class="manual-header-description">Closes input-port or output-port, respectively.</td></tr> <tr><td class="manual-header-title"><a href="#close-output-port">close-output-port</a></td> <td class="manual-header-form">(close-output-port output-port)</td> <td class="manual-header-description">Closes output-port.</td></tr> <tr><td class="manual-header-title"><a href="#cond">cond</a></td> <td class="manual-header-form">(cond [cond clause1] [cond clause2] ...)</td> <td class="manual-header-description"><p>A cond expression is evaluated by evaluating the [test] expressions of successive [cond clause]s in order until one of them evaluates to a true value.</p> <p>When a [test] evaluates to a true value, then the remaining [expression]s in its [cond clause] are evaluated in order, and the results of the last [expression] in the [cond clause] are returned as the results of the entire cond expression.</p> <p>If the selected [cond clause] contains only the [test] and no [expression]s, then the value of the [test] is returned as the result.</td></tr> <tr><td class="manual-header-title"><a href="#cons">cons</a></td> <td class="manual-header-form">(cons obj1 obj2)</td> <td class="manual-header-description">Returns a newly allocated pair whose car is obj1 and whose cdr is obj2.</td></tr> <tr><td class="manual-header-title"><a href="#cons*">cons*</a></td> <td class="manual-header-form">(cons* elt1 elt2 ...)</td> <td class="manual-header-description"></td></tr> <tr><td class="manual-header-title"><a href="#current-error-port">current-error-port</a></td> <td class="manual-header-form">(current-error-port)</td> <td class="manual-header-description">Returns default textual ports for regular error output.</td></tr> <tr><td class="manual-header-title"><a href="#current-input-port">current-input-port</a></td> <td class="manual-header-form">(current-input-port)</td> <td class="manual-header-description">Returns a default textual port for input.</td></tr> <tr><td class="manual-header-title"><a href="#current-output-port">current-output-port</a></td> <td class="manual-header-form">(current-output-port)</td> <td class="manual-header-description">Returns a default textual port for output.</td></tr> <tr><td class="manual-header-title"><a href="#define">define</a></td> <td class="manual-header-form">(define [variable] [expression]) (define [variable]) (define ([variable] [formals]) [body]) (define ([variable] . [formal]) [body])</td> <td class="manual-header-description">The define form is used to create variable bindings and may appear anywhere other definitions may appear.</td></tr> <tr><td class="manual-header-title"><a href="#define-macro">define-macro</a></td> <td class="manual-header-form">(define-macro (name . args) body)</td> <td class="manual-header-description">The define-macro form is used to create traditional macro.</td></tr> <tr><td class="manual-header-title"><a href="#digit->integer">digit->integer</a></td> <td class="manual-header-form">(digit->integer char &amp;optional (radix 10))</td> <td class="manual-header-description">If given character char is a valid digit character in radix radix number, the corresponding integer is returned.</td></tr> <tr><td class="manual-header-title"><a href="#display">display</a></td> <td class="manual-header-form">(display obj) or (display obj textual-output-port)</td> <td class="manual-header-description"><p><p>Writes a representation of obj to the given textual-output-port.</p></p> <p>Strings that appear in the written representation are not enclosed in doublequotes, and no characters are escaped within those strings.</p> <p>Character objects appear in the representation as if written by write-char instead of by write.</p> <p>The textual-output-port argument may be omitted, in which case it defaults to the value returned by current-output-port.</p> </td></tr> <tr><td class="manual-header-title"><a href="#do">do</a></td> <td class="manual-header-form">(do (([variable1] [init1] [step1]) ...) ([test] [expression] ...) [command] ...)</td> <td class="manual-header-description"><p>The [init] expressions are evaluated (in some unspecified order), the [variable]s are bound to fresh locations, the results of the [init] expressions are stored in the bindings of the [variable]s, and then the iteration phase begins.</p> <p>Each iteration begins by evaluating [test]; if the result is #f, then the [command]s are evaluated in order for effect, the [step] expressions are evaluated in some unspecified order, the [variable]s are bound to fresh locations holding the results, and the next iteration begins.</p> <p>If [test] evaluates to a true value, the [expression]s are evaluated from left to right and the values of the last [expression] are returned.</p> <p>If no [expression]s are present, then the do expression returns unspecified values.</p> <p>The regionof the binding of a [variable] consists of the entire do expression except for the [init]s.</p> <p>A [step] may be omitted, in which case the effect is the same as if ([variable] [init] [variable]) had been written instead of ([variable] [init]).</p> </td></tr> <tr><td class="manual-header-title"><a href="#eof-object">eof-object</a></td> <td class="manual-header-form">(eof-object)</td> <td class="manual-header-description">Returns the end-of-file object.</td></tr> <tr><td class="manual-header-title"><a href="#eof-object?">eof-object?</a></td> <td class="manual-header-form">(eof-object? obj)</td> <td class="manual-header-description">Returns #t if obj is the end-of-file object, #f otherwise.</td></tr> <tr><td class="manual-header-title"><a href="#eq?">eq?</a></td> <td class="manual-header-form">(eq?)</td> <td class="manual-header-description"><p>The eq? predicate is similar to eqv? except that in some cases it is capable of discerning distinctions finer than those detectable by eqv?.</p> <p>The eq? and eqv? predicates are guaranteed to have the same behavior on symbols, booleans, the empty list, pairs, procedures, non-empty strings, bytevectors, and vectors, and records.</p> </td></tr> <tr><td class="manual-header-title"><a href="#equal?">equal?</a></td> <td class="manual-header-form">(equal? obj1 obj2)</td> <td class="manual-header-description">The equal? predicate returns #t if and only if the unfoldings of its arguments into regular trees are equal as ordered trees.</td></tr> <tr><td class="manual-header-title"><a href="#eqv?">eqv?</a></td> <td class="manual-header-form">(eqv? obj1 obj2)</td> <td class="manual-header-description"><p>The eqv? procedure defines a useful equivalence relation on objects.</td></tr> <tr><td class="manual-header-title"><a href="#error">error</a></td> <td class="manual-header-form">(error message)</td> <td class="manual-header-description">This error procedure will be replaced with R6RS (error) </td></tr> <tr><td class="manual-header-title"><a href="#eval">eval</a></td> <td class="manual-header-form">(eval expression environment)</td> <td class="manual-header-description"><p>Evaluates expression in the specified environment and returns its value.</p> <p>Note that currently the environment argument is ignored.</p> </td></tr> <tr><td class="manual-header-title"><a href="#even?">even?</a></td> <td class="manual-header-form">(even? x)</td> <td class="manual-header-description">Returns whether x is even.</td></tr> <tr><td class="manual-header-title"><a href="#file->string">file->string</a></td> <td class="manual-header-form">(file->string filename)</td> <td class="manual-header-description">Read string from a file filename.</td></tr> <tr><td class="manual-header-title"><a href="#file-exists?">file-exists?</a></td> <td class="manual-header-form">(file-exists? filename)</td> <td class="manual-header-description">Returns #t if the named file exists at the time the procedure is called, #f otherwise.</td></tr> <tr><td class="manual-header-title"><a href="#filter">filter</a></td> <td class="manual-header-form">(filter proc list)</td> <td class="manual-header-description"><p>The filter procedure applies proc to each element of list and returns a list of the elements of list for which proc returned a true value.</p> <p>The elements of the result list(s) are in the same order as they appear in the input list.</p> </td></tr> <tr><td class="manual-header-title"><a href="#find">find</a></td> <td class="manual-header-form">(find pred lst)</td> <td class="manual-header-description"><p>The find procedure applies proc to the elements of list in order.</td></tr> <tr><td class="manual-header-title"><a href="#first">first</a></td> <td class="manual-header-form">(first pair)</td> <td class="manual-header-description">Synonym for car </td></tr> <tr><td class="manual-header-title"><a href="#fold-left">fold-left</a></td> <td class="manual-header-form">(fold-left combine nil list1 list2 ...listn)</td> <td class="manual-header-description"><p>The fold-left procedure iterates the combine procedure over an accumulator value and the elements of the lists from left to right, starting with an accumulator value of nil.</p> <p>More specifically, fold-left returns nil if the lists are empty.</td></tr> <tr><td class="manual-header-title"><a href="#fold-right">fold-right</a></td> <td class="manual-header-form">(fold-right combine nil list1 list2 ...listn)</td> <td class="manual-header-description"><p>The fold-right procedure iterates the combine procedure over the elements of the lists from right to left and an accumulator value, starting with an accumulator value of nil.</p> <p>More specifically, fold-right returns nil if the lists are empty.</td></tr> <tr><td class="manual-header-title"><a href="#for-each">for-each</a></td> <td class="manual-header-form">(for-each proc list1 list2 ...)</td> <td class="manual-header-description">The for-each procedure applies proc element-wise to the elements of the lists for its side effects, in order from the first elements to the last.</td></tr> <tr><td class="manual-header-title"><a href="#format">format</a></td> <td class="manual-header-form">(format string arg ...) (format port string arg ...)</td> <td class="manual-header-description"><p>Format arg ...</td></tr> <tr><td class="manual-header-title"><a href="#fourth">fourth</a></td> <td class="manual-header-form">(fourth pair)</td> <td class="manual-header-description">Synonym for cadddr </td></tr> <tr><td class="manual-header-title"><a href="#gensym">gensym</a></td> <td class="manual-header-form">(gensym)</td> <td class="manual-header-description">Returns a new symbol.</td></tr> <tr><td class="manual-header-title"><a href="#get-bytevector-n">get-bytevector-n</a></td> <td class="manual-header-form">(get-bytevector-n binary-input-port count)</td> <td class="manual-header-description"><p>Reads from binary-input-port, blocking as necessary, until count bytes are available from binary-input-port or until an end of file is reached.</p> <p>If count bytes are available before an end of file, get-bytevector-n returns a bytevector of size count.</td></tr> <tr><td class="manual-header-title"><a href="#get-timeofday">get-timeofday</a></td> <td class="manual-header-form">(get-timeofday)</td> <td class="manual-header-description">get-timeofday </td></tr> <tr><td class="manual-header-title"><a href="#get-u8">get-u8</a></td> <td class="manual-header-form">(get-u8 binary-input-port)</td> <td class="manual-header-description"><p>Reads from binary-input-port, blocking as necessary, until a byte is available from binary-input-port or until an end of file is reached.</p> <p>If a byte becomes available, get-u8 returns the byte as an octet and updates binary-input-port to point just past that byte.</td></tr> <tr><td class="manual-header-title"><a href="#guard">guard</a></td> <td class="manual-header-form">(guard ([variable] [cond clause1] [cond clause2] ...)</td> <td class="manual-header-description"><p>(guard ([variable]    syntax</p> <p>[cond clause1] [cond clause2] ...)</p> <p>[body])</p> <p>=>    auxiliary syntax</p> <p>else    auxiliary syntax</p> <p>Semantics: Evaluating a guard form evaluates [body] with an exception handler that binds the raised object to [variable] and within the scope of that binding evaluates the clauses as if they were the clauses of a cond expression.</td></tr> <tr><td class="manual-header-title"><a href="#hashtable-for-each">hashtable-for-each</a></td> <td class="manual-header-form">(hashtable-for-each proc ht)</td> <td class="manual-header-description">todo document </td></tr> <tr><td class="manual-header-title"><a href="#hashtable-keys">hashtable-keys</a></td> <td class="manual-header-form">(hashtable-keys hashtable)</td> <td class="manual-header-description">(not implmented) Returns a vector of all keys in hashtable.</td></tr> <tr><td class="manual-header-title"><a href="#hashtable-ref">hashtable-ref</a></td> <td class="manual-header-form">(hashtable-ref hashtable key default)</td> <td class="manual-header-description">Returns the value in hashtable associated with key.</td></tr> <tr><td class="manual-header-title"><a href="#hashtable-set!">hashtable-set!</a></td> <td class="manual-header-form">(hashtable-set! hashtable key obj)</td> <td class="manual-header-description">Changes hashtable to associate key with obj, adding a new association or replacing any existing association for key.</td></tr> <tr><td class="manual-header-title"><a href="#if">if</a></td> <td class="manual-header-form">(if [test] [consequent] [alternate]) (if [test] [consequent])</td> <td class="manual-header-description"><p>An if expression is evaluated as follows: first, [test] is evaluated.</p> <p>If it yields a true value, then [consequent] is evaluated and its values are returned.Otherwise <alternate> is evaluated and its values are returned.</p> <p>If <test> yields #f and no [alternate] is specified, then the result of the expression is unspecified.</p> </td></tr> <tr><td class="manual-header-title"><a href="#integer->char">integer->char</a></td> <td class="manual-header-form">(integer->char sv)</td> <td class="manual-header-description">For a Unicode scalar value sv, integer->char returns its associated character.</td></tr> <tr><td class="manual-header-title"><a href="#lambda">lambda</a></td> <td class="manual-header-form">(lambda [formals] [body])</td> <td class="manual-header-description">A lambda expression evaluates to a procedure.</td></tr> <tr><td class="manual-header-title"><a href="#length">length</a></td> <td class="manual-header-form">(length l)</td> <td class="manual-header-description">Returns the length of list.</td></tr> <tr><td class="manual-header-title"><a href="#let">let</a></td> <td class="manual-header-form">(let [bindings] [body])</td> <td class="manual-header-description"><p>(let [bindings] [body])</p> <p>Syntax: [Bindings] must have the form</p> <p>  (([variable1] [init1]) ...),</p> <p>where each [init] is an expression.</p> <p>Any variable must not appear more than once in the [variable]s.</p> </td></tr> <tr><td class="manual-header-title"><a href="#let*">let*</a></td> <td class="manual-header-form">(let* [bindings] [body])</td> <td class="manual-header-description"><p>(let* [bindings] [body])</p> <p>Syntax: [Bindings] must have the form</p> <p>(([variable1] [init1]) ...),</p> <p>Semantics: The let* form is similar to let, but the [init]s are evaluated and bindings created sequentially from left to right, with the regionof each binding including the bindings to its right as well as [body].</p> <p>Thus the second [init] is evaluated in an environment in which the first binding is visible and initialized, and so on.</p> </td></tr> <tr><td class="manual-header-title"><a href="#let1">let1</a></td> <td class="manual-header-form">(let1 var val body ...)</td> <td class="manual-header-description">Same as (let ((var val)) body ...) </td></tr> <tr><td class="manual-header-title"><a href="#letrec">letrec</a></td> <td class="manual-header-form">(letrec [bindings] [body])</td> <td class="manual-header-description"><p>(letrec [bindings] [body])</p> <p>Syntax: [Bindings] must have the form</p> <p>(([variable1] [init1]) ...),</p> <p>Any variable must not appear more than once in the [variable]s.</p> <p>Semantics: The [variable]s are bound to fresh locations, the [init]s are evaluated in the resulting environment (in some unspecified order), each [variable] is assigned to the result of the corresponding [init], the [body] is evaluated in the resulting environment, and the values of the last expression in <body> are returned.</p> <p>Each binding of a [variable] has the entire letrec expression as its region, making it possible to define mutually recursive procedures.</p> </td></tr> <tr><td class="manual-header-title"><a href="#list">list</a></td> <td class="manual-header-form">(list obj ...)</td> <td class="manual-header-description">Returns a newly allocated list of its arguments.</td></tr> <tr><td class="manual-header-title"><a href="#list->string">list->string</a></td> <td class="manual-header-form">(list->string l)</td> <td class="manual-header-description">The list->string procedure returns a newly allocated string formed from the characters in list.</td></tr> <tr><td class="manual-header-title"><a href="#list->vector">list->vector</a></td> <td class="manual-header-form">(list->vector l)</td> <td class="manual-header-description">The list->vector procedure returns a newly created vector initialized to the elements of the list list.</td></tr> <tr><td class="manual-header-title"><a href="#list-ref">list-ref</a></td> <td class="manual-header-form">(list-ref l k)</td> <td class="manual-header-description">returns the kth element of list.</td></tr> <tr><td class="manual-header-title"><a href="#list-tail">list-tail</a></td> <td class="manual-header-form">(list-tail l k)</td> <td class="manual-header-description">returns the subchain of pairs of list obtained by omitting the first k elements </td></tr> <tr><td class="manual-header-title"><a href="#list?">list?</a></td> <td class="manual-header-form">(list? obj)</td> <td class="manual-header-description">(not implemented yet) Returns #t if obj is a list, #f otherwise.</td></tr> <tr><td class="manual-header-title"><a href="#list?">list?</a></td> <td class="manual-header-form">(list? obj)</td> <td class="manual-header-description">Returns #t if obj is a list, #f otherwise.</td></tr> <tr><td class="manual-header-title"><a href="#macroexpand">macroexpand</a></td> <td class="manual-header-form">(macroexpand form)</td> <td class="manual-header-description">Expand macro </td></tr> <tr><td class="manual-header-title"><a href="#macroexpand-1">macroexpand-1</a></td> <td class="manual-header-form">(macroexpand-1 form)</td> <td class="manual-header-description">Expand macro </td></tr> <tr><td class="manual-header-title"><a href="#make-custom-binary-input-port">make-custom-binary-input-port</a></td> <td class="manual-header-form">(make-custom-binary-input-port id read! procedure get-position set-position! close)</td> <td class="manual-header-description"><p>Note.</td></tr> <tr><td class="manual-header-title"><a href="#make-eq-hashtable">make-eq-hashtable</a></td> <td class="manual-header-form">(make-eq-hashtable) (make-eq-hashtable k)</td> <td class="manual-header-description"><p>Returns a newly allocated mutable hashtable that accepts arbitrary objects as keys, and compares those keys with eq?.</td></tr> <tr><td class="manual-header-title"><a href="#make-string">make-string</a></td> <td class="manual-header-form">(make-string k &amp;optional char)</td> <td class="manual-header-description">Returns a newly allocated string of length k.</td></tr> <tr><td class="manual-header-title"><a href="#make-transcoder">make-transcoder</a></td> <td class="manual-header-form">(make-transcoder codec)</td> <td class="manual-header-description">Returns transcoder with the behavior specified by its arguments.</td></tr> <tr><td class="manual-header-title"><a href="#map">map</a></td> <td class="manual-header-form">(map proc list1 list2 ...)</td> <td class="manual-header-description">The map procedure applies proc element-wise to the elements of the lists and returns a list of the results, in order.</td></tr> <tr><td class="manual-header-title"><a href="#map1">map1</a></td> <td class="manual-header-form">(map1 proc l)</td> <td class="manual-header-description">The map1 procedure applies proc element-wise to the elements of the list and returns a list of the results, in order.</td></tr> <tr><td class="manual-header-title"><a href="#match">match</a></td> <td class="manual-header-form">(match)</td> <td class="manual-header-description"></td></tr> <tr><td class="manual-header-title"><a href="#memq">memq</a></td> <td class="manual-header-form">(memq obj list)</td> <td class="manual-header-description">Return the first sublist of list whose car satisfies a given condition with eq?, where the sublists of lists are the lists returned by (list-tail list k) for k less than the length of list.</td></tr> <tr><td class="manual-header-title"><a href="#mode">mode</a></td> <td class="manual-header-form">(mod z1 z2)</td> <td class="manual-header-description">Returns the modulo of their arguments.</td></tr> <tr><td class="manual-header-title"><a href="#newline">newline</a></td> <td class="manual-header-form">(newline)</td> <td class="manual-header-description"><p>This is equivalent to using write-char to write #\linefeed to textual-output-port.</td></tr> <tr><td class="manual-header-title"><a href="#not">not</a></td> <td class="manual-header-form">(not obj)</td> <td class="manual-header-description">Returns #t if obj is #f, and returns #f otherwise.</td></tr> <tr><td class="manual-header-title"><a href="#null?">null?</a></td> <td class="manual-header-form">(null? obj)</td> <td class="manual-header-description">Returns #t if obj is the empty list, #f otherwise.</td></tr> <tr><td class="manual-header-title"><a href="#number->string">number->string</a></td> <td class="manual-header-form">(number->string z radix)</td> <td class="manual-header-description">Takes a number object and a radix and returns as a string an external representation of the given number object in the given radix.</td></tr> <tr><td class="manual-header-title"><a href="#number->string">number->string</a></td> <td class="manual-header-form">(number->string z)</td> <td class="manual-header-description">Takes a number object and returns as a string an external representation of the given number object.</td></tr> <tr><td class="manual-header-title"><a href="#number?">number?</a></td> <td class="manual-header-form">(number? obj)</td> <td class="manual-header-description">return #t if obj is number object and #f otherwise.</td></tr> <tr><td class="manual-header-title"><a href="#open-bytevector-output-port">open-bytevector-output-port</a></td> <td class="manual-header-form">(open-bytevector-output-port transcoder)</td> <td class="manual-header-description"><p>Returns two values: an output port and an extraction procedure.</p> <p>The output port accumulates the bytes written to it for later extraction by the procedure.</p> <p>If transcoder is a transcoder, it becomes the transcoder associated with the port.</td></tr> <tr><td class="manual-header-title"><a href="#open-file-input-port">open-file-input-port</a></td> <td class="manual-header-form">(open-file-input-port filename)</td> <td class="manual-header-description">Returns an input port for the named file.</td></tr> <tr><td class="manual-header-title"><a href="#open-file-output-port">open-file-output-port</a></td> <td class="manual-header-form">(open-file-output-port filename)</td> <td class="manual-header-description">Returns an output port for the named file.</td></tr> <tr><td class="manual-header-title"><a href="#open-output-file">open-output-file</a></td> <td class="manual-header-form">(open-output-file filename)</td> <td class="manual-header-description">Opens filename for output, with empty file options, and returns the obtained port.</td></tr> <tr><td class="manual-header-title"><a href="#open-string-input-port">open-string-input-port</a></td> <td class="manual-header-form">(open-string-input-port string)</td> <td class="manual-header-description">Returns a textual input port whose characters are drawn from string.</td></tr> <tr><td class="manual-header-title"><a href="#open-string-output-port">open-string-output-port</a></td> <td class="manual-header-form">(open-string-output-port)</td> <td class="manual-header-description"><p>Returns two values: a textual output port and an extraction procedure.</p> <p>The output port accumulates the characters written to it for later extraction by the procedure.</p> <p>The extraction procedure takes no arguments.</p> <p>When called, it returns a string consisting of all of the port&#39;s accumulated characters (regardless of the current position),removes the accumulated characters from the port, and resetsthe port&#39;s position</p> </td></tr> <tr><td class="manual-header-title"><a href="#or">or</a></td> <td class="manual-header-form">(or [test1] ...)</td> <td class="manual-header-description">If there are no [test]s, #f is returned.</td></tr> <tr><td class="manual-header-title"><a href="#pair?">pair?</a></td> <td class="manual-header-form">(pair? obj)</td> <td class="manual-header-description">Returns #t if obj is a pair, and otherwise returns #f.</td></tr> <tr><td class="manual-header-title"><a href="#print">print</a></td> <td class="manual-header-form">(print obj)</td> <td class="manual-header-description">Writes a representation of obj to the current output port and (newline) Strings that appear in the written representation are not enclosed in doublequotes, and no characters are escaped within those strings.</td></tr> <tr><td class="manual-header-title"><a href="#procedure?">procedure?</a></td> <td class="manual-header-form">(procedure? obj)</td> <td class="manual-header-description">Returns #t if obj is a procedure, otherwise returns #f.</td></tr> <tr><td class="manual-header-title"><a href="#quasiquote">quasiquote</a></td> <td class="manual-header-form">(quasiquote [qq template])</td> <td class="manual-header-description">Quasiquote </td></tr> <tr><td class="manual-header-title"><a href="#quote">quote</a></td> <td class="manual-header-form">(quote [datum])</td> <td class="manual-header-description">Evaluates to the datum value represented by [datum].</td></tr> <tr><td class="manual-header-title"><a href="#raise">raise</a></td> <td class="manual-header-form">(raise obj)</td> <td class="manual-header-description">Raises a non-continuable exception by invoking the current exception handler on obj.</td></tr> <tr><td class="manual-header-title"><a href="#raise-continuable">raise-continuable</a></td> <td class="manual-header-form">(raise-continuable obj)</td> <td class="manual-header-description"><p>Raises a continuable exception by invoking the current exception handler on obj.</p> <p>The handler is called with a continuation that is equivalent to the continuation of the call to raise-continuable, with these two exceptions:</p> <p>(1) the current exception handler is the one that was in place when the handler being called was installed, and (2) if the handler being called returns, then it will again become the current exception handler.</td></tr> <tr><td class="manual-header-title"><a href="#read">read</a></td> <td class="manual-header-form">(read) (read textual-input-port)</td> <td class="manual-header-description">Reads an external representation from textual-input-port and returns the datum it represents.</td></tr> <tr><td class="manual-header-title"><a href="#read-char">read-char</a></td> <td class="manual-header-form">(read-char &amp;optional textual-input-port)</td> <td class="manual-header-description"><p>Reads from textual-input-port, blocking as necessary until a character is available from textual-input-port, or the data that are available cannot be the prefix of any valid encoding, or an end of file is reached.</p> <p>If a complete character is available before the next end of file, read-char returns that character, and updates the input port to point past that character.</td></tr> <tr><td class="manual-header-title"><a href="#read-line">read-line</a></td> <td class="manual-header-form">(read-line  . port)</td> <td class="manual-header-description">Reads one line (a sequence of characters terminated by newline or EOF) from port and returns a string.</td></tr> <tr><td class="manual-header-title"><a href="#receive">receive</a></td> <td class="manual-header-form">(receive formals expression body ...)</td> <td class="manual-header-description"><p>This is the way to receive multiple values.</p> <p>Formals can be a (maybe-improper) list of symbols.</p> <p>Expression is evaluated, and the returned value(s) are bound to formals like the binding of lambda formals, then body ...</td></tr> <tr><td class="manual-header-title"><a href="#regexp">regexp</a></td> <td class="manual-header-form">(regexp string)</td> <td class="manual-header-description">Regexp is a regular expression object.</td></tr> <tr><td class="manual-header-title"><a href="#regexp->string">regexp->string</a></td> <td class="manual-header-form">(regexp->string regexp)</td> <td class="manual-header-description">Returns a source string describing the regexp regexp.</td></tr> <tr><td class="manual-header-title"><a href="#regexp-replace">regexp-replace</a></td> <td class="manual-header-form">(regexp-replace regexp string substitution)</td> <td class="manual-header-description">Replaces the part of string that matched to regexp for substitution.</td></tr> <tr><td class="manual-header-title"><a href="#regexp-replace-all">regexp-replace-all</a></td> <td class="manual-header-form">(regexp-replace-all regexp string substitution)</td> <td class="manual-header-description">Replaces the part of string that matched to regexp for substitution.</td></tr> <tr><td class="manual-header-title"><a href="#regexp?">regexp?</a></td> <td class="manual-header-form">(regexp? obj)</td> <td class="manual-header-description">Returns #t if obj is a regexp object.</td></tr> <tr><td class="manual-header-title"><a href="#regmatch">regmatch</a></td> <td class="manual-header-form">(regmatch &#39;after &amp;optional index)</td> <td class="manual-header-description">Works same as (rxmatch-after regmatch) </td></tr> <tr><td class="manual-header-title"><a href="#regmatch">regmatch</a></td> <td class="manual-header-form">(regmatch &#39;before &amp;optional index)</td> <td class="manual-header-description">Works same as (rxmatch-before regmatch) </td></tr> <tr><td class="manual-header-title"><a href="#regmatch">regmatch</a></td> <td class="manual-header-form">(regmatch &amp;optional index)</td> <td class="manual-header-description">Works same as (rxmatch-substring regmatch index), </td></tr> <tr><td class="manual-header-title"><a href="#remp">remp</a></td> <td class="manual-header-form">(remp pred l)</td> <td class="manual-header-description">The remp procedure applies proc to each element of list and returns a list of the elements of list for which proc returned #f.</td></tr> <tr><td class="manual-header-title"><a href="#reverse">reverse</a></td> <td class="manual-header-form">(reverse l)</td> <td class="manual-header-description">Returns a newly allocated list consisting of the elements of list in reverse order.</td></tr> <tr><td class="manual-header-title"><a href="#rxmatch">rxmatch</a></td> <td class="manual-header-form">(rxmatch regexp string)</td> <td class="manual-header-description"><p>Regexp is a regular expression object.</td></tr> <tr><td class="manual-header-title"><a href="#rxmatch-after">rxmatch-after</a></td> <td class="manual-header-form">(rxmatch-after match &amp;optional (i 0))</td> <td class="manual-header-description">Returns substring of the input string after match.</td></tr> <tr><td class="manual-header-title"><a href="#rxmatch-before">rxmatch-before</a></td> <td class="manual-header-form">(rxmatch-before match &amp;optional (i 0))</td> <td class="manual-header-description">Returns substring of the input string before match.</td></tr> <tr><td class="manual-header-title"><a href="#rxmatch-end">rxmatch-end</a></td> <td class="manual-header-form">(rxmatch-end match &amp;optional (i 0))</td> <td class="manual-header-description"><p>If i equals to zero, the functions return end of entire match.</td></tr> <tr><td class="manual-header-title"><a href="#rxmatch-start">rxmatch-start</a></td> <td class="manual-header-form">(rxmatch-start match &amp;optional (i 0))</td> <td class="manual-header-description"><p>If i equals to zero, the functions return start of entire match.</td></tr> <tr><td class="manual-header-title"><a href="#rxmatch-substring">rxmatch-substring</a></td> <td class="manual-header-form">(rxmatch-substring match &amp;optional (i 0))</td> <td class="manual-header-description"><p>If i equals to zero, the functions return substring of entire match.</td></tr> <tr><td class="manual-header-title"><a href="#second">second</a></td> <td class="manual-header-form">(second pair)</td> <td class="manual-header-description">Synonym for cadr </td></tr> <tr><td class="manual-header-title"><a href="#set!">set!</a></td> <td class="manual-header-form">(set! [variable] [expression])</td> <td class="manual-header-description"><p>[Expression] is evaluated, and the resulting value is stored in the location to which [variable] is bound.</td></tr> <tr><td class="manual-header-title"><a href="#set-car!">set-car!</a></td> <td class="manual-header-form">(set-car! pair obj)</td> <td class="manual-header-description">Stores obj in the car field of pair.</td></tr> <tr><td class="manual-header-title"><a href="#set-cdr!">set-cdr!</a></td> <td class="manual-header-form">(set-cdr! pair obj)</td> <td class="manual-header-description">Stores obj in the cdr field of pair.</td></tr> <tr><td class="manual-header-title"><a href="#set-current-input-port!">set-current-input-port!</a></td> <td class="manual-header-form">(set-current-input-port!)</td> <td class="manual-header-description">used internal </td></tr> <tr><td class="manual-header-title"><a href="#set-current-output-port!">set-current-output-port!</a></td> <td class="manual-header-form">(set-current-output-port!)</td> <td class="manual-header-description">used internal </td></tr> <tr><td class="manual-header-title"><a href="#standard-input-port">standard-input-port</a></td> <td class="manual-header-form">(standard-input-port)</td> <td class="manual-header-description">Returns a fresh binary input port connected to standard input.</td></tr> <tr><td class="manual-header-title"><a href="#string->number">string->number</a></td> <td class="manual-header-form">(string->number string)</td> <td class="manual-header-description">Returns a number by the given string.</td></tr> <tr><td class="manual-header-title"><a href="#string->regexp">string->regexp</a></td> <td class="manual-header-form">(string->regexp string)</td> <td class="manual-header-description">Takes string as a regexp specification, and constructs [regexp] object.</td></tr> <tr><td class="manual-header-title"><a href="#string->symbol">string->symbol</a></td> <td class="manual-header-form">(string->symbol string)</td> <td class="manual-header-description">Returns the symbol whose name is string.</td></tr> <tr><td class="manual-header-title"><a href="#string-append">string-append</a></td> <td class="manual-header-form">(string-append string ...)</td> <td class="manual-header-description">Returns a newly allocated string whose characters form the concatenation of the given strings.</td></tr> <tr><td class="manual-header-title"><a href="#string-length">string-length</a></td> <td class="manual-header-form">(string-length string)</td> <td class="manual-header-description">Returns the number of characters in the given string as an exact integer object.</td></tr> <tr><td class="manual-header-title"><a href="#string-ref">string-ref</a></td> <td class="manual-header-form">(string-ref string k)</td> <td class="manual-header-description">character at index k in string </td></tr> <tr><td class="manual-header-title"><a href="#string-ref">string-ref</a></td> <td class="manual-header-form">(string-ref string k)</td> <td class="manual-header-description">Returns character k of string using zero-origin indexing.</td></tr> <tr><td class="manual-header-title"><a href="#string-set!">string-set!</a></td> <td class="manual-header-form">(string-set! string k char)</td> <td class="manual-header-description">stores char in element k of string.</td></tr> <tr><td class="manual-header-title"><a href="#string-split">string-split</a></td> <td class="manual-header-form">(string-split string splitter)</td> <td class="manual-header-description">Splits string by splitter and returns a list of strings.</td></tr> <tr><td class="manual-header-title"><a href="#string=?">string=?</a></td> <td class="manual-header-form">(string=? string1 string2 string3 ...)</td> <td class="manual-header-description"><p>Returns #t if the strings are the same length and contain the same characters in the same positions.</p> <p>Otherwise, the string=? procedure returns #f.Returns #t if obj is a string, otherwise returns #f.</p> </td></tr> <tr><td class="manual-header-title"><a href="#string?">string?</a></td> <td class="manual-header-form">(string? obj)</td> <td class="manual-header-description">Returns #t if obj is a string, otherwise returns #f.</td></tr> <tr><td class="manual-header-title"><a href="#symbol->string">symbol->string</a></td> <td class="manual-header-form">(symbol->string symbol)</td> <td class="manual-header-description">Returns the name of symbol as an immutable string.</td></tr> <tr><td class="manual-header-title"><a href="#symbol?">symbol?</a></td> <td class="manual-header-form">(symbol? obj)</td> <td class="manual-header-description">Returns #t if obj is a symbol, otherwise returns #f.</td></tr> <tr><td class="manual-header-title"><a href="#sys-getenv">sys-getenv</a></td> <td class="manual-header-form">(sys-getenv name)</td> <td class="manual-header-description">Returns the value of the environment variable name as a string, or #f if the environment variable is not defined.</td></tr> <tr><td class="manual-header-title"><a href="#sys-readdir">sys-readdir</a></td> <td class="manual-header-form">(sys-readdir path)</td> <td class="manual-header-description">Returns a list of strings of the directory entries.</td></tr> <tr><td class="manual-header-title"><a href="#third">third</a></td> <td class="manual-header-form">(third pair)</td> <td class="manual-header-description">Synonym for caddr </td></tr> <tr><td class="manual-header-title"><a href="#transcoded-port">transcoded-port</a></td> <td class="manual-header-form">(transcoded-port binary-port transcoder)</td> <td class="manual-header-description"><p>Returns a new textual port with the specified transcoder.</p> <p>Otherwise the new textual port&#39;s state is largely the same as that of binary-port.</p> <p>If binary-port is an input port, the new textual port will be an input port and will transcode the bytes that have not yet been read from binary-port.</td></tr> <tr><td class="manual-header-title"><a href="#unless">unless</a></td> <td class="manual-header-form">(unless test body ...)</td> <td class="manual-header-description">Evaluates test.</td></tr> <tr><td class="manual-header-title"><a href="#utf-8-codec">utf-8-codec</a></td> <td class="manual-header-form">(utf-8-codec)</td> <td class="manual-header-description">Predefined codecs for the UTF-8 encoding schemes.</td></tr> <tr><td class="manual-header-title"><a href="#utf8->string">utf8->string</a></td> <td class="manual-header-form">(utf8->string bytevector)</td> <td class="manual-header-description">Returns a newly allocated (unless empty) string whose character sequence is encoded by the given bytevector.</td></tr> <tr><td class="manual-header-title"><a href="#values">values</a></td> <td class="manual-header-form">(values obj ...)</td> <td class="manual-header-description">Delivers all of its arguments to its continuation.</td></tr> <tr><td class="manual-header-title"><a href="#vector">vector</a></td> <td class="manual-header-form">(vector obj ...)</td> <td class="manual-header-description">Returns a newly allocated vector whose elements contain the given arguments.</td></tr> <tr><td class="manual-header-title"><a href="#vector->list">vector->list</a></td> <td class="manual-header-form">(vector->list v)</td> <td class="manual-header-description">returns a newly allocated list of the objects contained in the elements of vector </td></tr> <tr><td class="manual-header-title"><a href="#vector-for-each">vector-for-each</a></td> <td class="manual-header-form">(vector-for-each proc vector1 vector2 ...)</td> <td class="manual-header-description">Applies proc element-wise to the elements of the vectors for its side effects, in order from the first elements to the last.</td></tr> <tr><td class="manual-header-title"><a href="#vector-length">vector-length</a></td> <td class="manual-header-form">(vector-length vector)</td> <td class="manual-header-description">Returns the number of elements in vector as an exact integer object.</td></tr> <tr><td class="manual-header-title"><a href="#vector-map">vector-map</a></td> <td class="manual-header-form">(vector-map proc vector1 vector2 ...)</td> <td class="manual-header-description">Applies proc element-wise to the elements of the vectors and returns a vector of the results, in order.</td></tr> <tr><td class="manual-header-title"><a href="#vector-ref">vector-ref</a></td> <td class="manual-header-form">(vector-ref vector k)</td> <td class="manual-header-description">Returns the contents of elementk of vector.</td></tr> <tr><td class="manual-header-title"><a href="#vector-set!">vector-set!</a></td> <td class="manual-header-form">(vector-set! vector k obj)</td> <td class="manual-header-description">stores obj in element k of vector, and returns unspecified values.</td></tr> <tr><td class="manual-header-title"><a href="#vector?">vector?</a></td> <td class="manual-header-form">(vector? obj)</td> <td class="manual-header-description">Returns #t if obj is a vector.</td></tr> <tr><td class="manual-header-title"><a href="#when">when</a></td> <td class="manual-header-form">(when test body ...)</td> <td class="manual-header-description">Evaluates test.</td></tr> <tr><td class="manual-header-title"><a href="#with-exception-handler">with-exception-handler</a></td> <td class="manual-header-form">(with-exception-handler handler thunk)</td> <td class="manual-header-description">Returns the results of invoking thunk.</td></tr> <tr><td class="manual-header-title"><a href="#with-input-from-file">with-input-from-file</a></td> <td class="manual-header-form">(with-input-from-file filename thunk)</td> <td class="manual-header-description"></td></tr> <tr><td class="manual-header-title"><a href="#write">write</a></td> <td class="manual-header-form">(write obj &amp;optional textual-output-port)</td> <td class="manual-header-description">Writes the external representation of obj to textual-output-port.</td></tr> <tr><td class="manual-header-title"><a href="#write-to-file">write-to-file</a></td> <td class="manual-header-form">(write-to-file path content)</td> <td class="manual-header-description">Same as (call-with-output-file path (lambda (port) (display content obj))) </td></tr> <tr><td class="manual-header-title"><a href="#zero?">zero?</a></td> <td class="manual-header-form">(zero? n)</td> <td class="manual-header-description">tests if the number object is = to zero </td></tr></table></div> <p></p> <div class="manual-end-remark">Generated: Thursday, June 12, 2008 <br /> Generated by LAML <a href="http://www.cs.aau.dk/~normark/schemedoc/index.html" style="color:inherit;">SchemeDoc</a> using LAML Version 32.3 (June 11, 2007, schemedoc) <br /> </div></body></html>