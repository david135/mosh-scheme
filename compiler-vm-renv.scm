;; Do not edit this file generated by ./scripts/gen-compiler.scm.
(define (ungensym x) x)(define-macro (import-only module . syms) `(begin ,@(map (lambda (sym) `(define ,sym (with-module ,module ,sym))) syms)))(import-only gauche.internal extended-pair? extended-cons extended-list pair-attribute-get pair-attribute-set! pair-attributes)(define *command-line-args* '())(define (command-line) *command-line-args*)(define make-eq-hashtable make-hash-table)(define hashtable-set! hash-table-put!)(define hashtable-ref hash-table-get)(define hashtable-keys hash-table-keys)(define hashtable-for-each (lambda (proc ht) (hash-table-for-each ht proc)))(define dd (lambda a '()))(define pp (lambda a '()))(define syntax-error error)(define find10 find)(define append2 append)(define appendA append)(define memq2 memq)(define (source-info p) (let1 src (debug-source-info p) (if (pair? src) (cons (sys-basename (car src)) (cdr src)) src)))(define (make-list-with-src-slot lst) (apply extended-list lst))(define (set-source-info! a b) (cond ((extended-pair? a) (pair-attribute-set! a 'source-info b) a) (else a)))(define-macro
  (imap proc lis)
  (let ((p (gensym)) (r (gensym)) (loop (gensym)))
       (quasiquote
         (let (unquote loop)
              (((unquote r) (quote ()))
               ((unquote p) (unquote lis)))
              (if (null? (unquote p))
                  (reverse (unquote r))
                  ((unquote loop)
                   (cons ((unquote proc) (car (unquote p)))
                         (unquote r))
                   (cdr (unquote p))))))))

(define
  (eq-hashtable-copy ht)
  (let1 ret
        (make-eq-hashtable)
        (hashtable-for-each
          (lambda
            (key value)
            (hashtable-set! ret key value))
          ht)
        ret))

(define
  (hashtable-set-true! ht keys)
  (let loop
       ((keys keys))
       (cond ((null? keys) ht)
             (else (hashtable-set! ht (car keys) #t)
                   (loop (cdr keys))))))

(define
  ($for-each1-with-rindex proc lst)
  (let loop
       ((i (- (length lst) 1)) (lst lst))
       (cond ((null? lst) (quote ()))
             (else (proc i (car lst))
                   (loop (- i 1) (cdr lst))))))

(define-macro
  (begin0 form . forms)
  (let ((var (gensym)))
       (quasiquote
         (let (((unquote var) (unquote form)))
              (unquote-splicing forms)
              (unquote var)))))

(define-macro
  (first o)
  (quasiquote (car (unquote o))))

(define-macro
  (second o)
  (quasiquote (cadr (unquote o))))

(define-macro
  (third o)
  (quasiquote (caddr (unquote o))))

(define-macro
  (dolist a . body)
  (quasiquote
    (begin (for-each
             (lambda
               ((unquote (first a)))
               (unquote-splicing body))
             (unquote (second a)))
           (quote ()))))

(define-macro
  (do . sexp)
  (match sexp
         ((((var init step ...) ...)
           (test expr ...)
           command
           ...)
          (quasiquote
            (letrec
              ((loop (lambda
                       ((unquote-splicing var))
                       (if (unquote test)
                           (begin #f (unquote-splicing expr))
                           (begin (unquote-splicing command)
                                  (loop (unquote-splicing
                                          (map (lambda
                                                 (v s)
                                                 (quasiquote
                                                   (do "step"
                                                       (unquote v)
                                                       (unquote-splicing s))))
                                               var
                                               step))))))))
              (loop (unquote-splicing init)))))
         (("step" x) x)
         (("step" x y) y)
         (else (syntax-error "malformed do"))))

(define-macro
  (acond . clauses)
  (if (null? clauses)
      (quote ())
      (let ((cl1 (car clauses)) (sym (gensym)))
           (quasiquote
             (let (((unquote sym) (unquote (car cl1))))
                  (if (unquote sym)
                      (let ((it (unquote sym)))
                           (unquote-splicing (cdr cl1)))
                      (acond (unquote-splicing (cdr clauses)))))))))

(define-macro
  (aif test-form then-form . else-form)
  (quasiquote
    (let ((it (unquote test-form)))
         (if it
             (unquote then-form)
             (unquote-splicing else-form)))))

(define
  (syntax-error msg)
  (raise (format "syntax error: ~a" msg)))

(define
  (alist-cons obj1 obj2 obj3)
  (cons (cons obj1 obj2) obj3))

(define
  (libname->symbol name)
  (let loop
       ((name name) (ret ""))
       (if (null? name)
           (string->symbol ret)
           (loop (cdr name)
                 (string-append ret (symbol->string (car name)))))))

(define
  ($map1 f l)
  (if (null? l)
      l
      (cons (f (car l)) ($map1 f (cdr l)))))

(define
  ($filter-map1 f l)
  (if (null? l)
      l
      (aif (f (car l))
           (cons it ($filter-map1 f (cdr l)))
           ($filter-map1 f (cdr l)))))

(define
  ($map1-with-tail f l)
  (if (null? l)
      l
      (cons (f (car l) (null? (cdr l)))
            ($map1-with-tail f (cdr l)))))

(define-macro
  ($append-map1 f l)
  (quasiquote
    (apply append (imap (unquote f) (unquote l)))))

(define
  (uniq lst)
  (let loop
       ((lst lst) (ret (quote ())))
       (cond ((null? lst) ret)
             (else (if (memq (car lst) ret)
                       (loop (cdr lst) ret)
                       (loop (cdr lst) (cons (car lst) ret)))))))

(define
  (apply-each-pair proc lst)
  (if (null? (cdr lst))
      (quote ())
      (cons (list proc (car lst) (cadr lst))
            (apply-each-pair proc (cdr lst)))))

(define
  (remove-tail lst pred)
  (let loop
       ((lst lst) (ret (quote ())))
       (cond ((null? (cdr lst))
              (reverse
                (if (pred (car lst)) ret (cons (car lst) ret))))
             (else (loop (cdr lst) (cons (car lst) ret))))))

(define $CONST 0)

(define ($const val) (vector $CONST val))

(define-macro
  ($const.val iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($const.set-val! iform val)
  (quasiquote
    (vector-set! (unquote iform) 1 (unquote val))))

(define $LVAR 1)

(define
  ($lvar sym init-val ref-count set-count)
  (vector $LVAR sym init-val ref-count set-count))

(define
  ($lvar.sym-proc iform)
  (vector-ref iform 1))

(define-macro
  ($lvar.sym iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($lvar.init-val iform)
  (quasiquote (vector-ref (unquote iform) 2)))

(define-macro
  ($lvar.ref-count iform)
  (quasiquote (vector-ref (unquote iform) 3)))

(define-macro
  ($lvar.set-count iform)
  (quasiquote (vector-ref (unquote iform) 4)))

(define-macro
  ($lvar.set-sym! iform sym)
  (quasiquote
    (vector-set! (unquote iform) 1 (unquote sym))))

(define-macro
  ($lvar.set-init-val! iform init-val)
  (quasiquote
    (vector-set!
      (unquote iform)
      2
      (unquote init-val))))

(define-macro
  ($lvar.set-ref-count! iform ref-count)
  (quasiquote
    (vector-set!
      (unquote iform)
      3
      (unquote ref-count))))

(define-macro
  ($lvar.set-set-count! iform set-count)
  (quasiquote
    (vector-set!
      (unquote iform)
      4
      (unquote set-count))))

(define
  (pp-lvars lvars)
  (print (map (lambda (x) ($lvar.sym x)) lvars)))

(define $LET 2)

(define
  ($let type lvars inits body tail? src . error)
  (vector
    $LET
    type
    lvars
    inits
    body
    tail?
    src
    (if (null? error) #f (car error))))

(define-macro
  ($let.type iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($let.lvars iform)
  (quasiquote (vector-ref (unquote iform) 2)))

(define-macro
  ($let.inits iform)
  (quasiquote (vector-ref (unquote iform) 3)))

(define-macro
  ($let.body iform)
  (quasiquote (vector-ref (unquote iform) 4)))

(define-macro
  ($let.tail? iform)
  (quasiquote (vector-ref (unquote iform) 5)))

(define-macro
  ($let.src iform)
  (quasiquote (vector-ref (unquote iform) 6)))

(define-macro
  ($let.error iform)
  (quasiquote (vector-ref (unquote iform) 7)))

(define-macro
  ($let.set-type! iform type)
  (quasiquote
    (vector-set! (unquote iform) 1 (unquote type))))

(define-macro
  ($let.set-lvars! iform lvars)
  (quasiquote
    (vector-set! (unquote iform) 2 (unquote lvars))))

(define-macro
  ($let.set-inits! iform inits)
  (quasiquote
    (vector-set! (unquote iform) 3 (unquote inits))))

(define-macro
  ($let.set-body! iform body)
  (quasiquote
    (vector-set! (unquote iform) 4 (unquote body))))

(define-macro
  ($let.set-tail?! iform tail?)
  (quasiquote
    (vector-set! (unquote iform) 5 (unquote tail?))))

(define-macro
  ($let.set-src! iform src)
  (quasiquote
    (vector-set! (unquote iform) 6 (unquote src))))

(define-macro
  ($let.set-src! iform error)
  (quasiquote
    (vector-set! (unquote iform) 7 (unquote error))))

(define $SEQ 3)

(define
  ($seq body tail?)
  (vector $SEQ body tail?))

(define-macro
  ($seq.body iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($seq.tail? iform)
  (quasiquote (vector-ref (unquote iform) 2)))

(define-macro
  ($seq.set-body! iform body)
  (quasiquote
    (vector-set! (unquote iform) 1 (unquote body))))

(define-macro
  ($seq.set-tail?! iform tail?)
  (quasiquote
    (vector-set! (unquote iform) 2 (unquote tail?))))

(define $LAMBDA 4)

(define
  ($lambda
    src
    name
    reqargs
    optarg
    lvars
    body
    flag
    calls)
  (vector
    $LAMBDA
    src
    name
    reqargs
    optarg
    lvars
    body
    flag
    calls))

(define-macro
  ($lambda.src iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($lambda.name iform)
  (quasiquote (vector-ref (unquote iform) 2)))

(define-macro
  ($lambda.reqargs iform)
  (quasiquote (vector-ref (unquote iform) 3)))

(define-macro
  ($lambda.optarg iform)
  (quasiquote (vector-ref (unquote iform) 4)))

(define-macro
  ($lambda.lvars iform)
  (quasiquote (vector-ref (unquote iform) 5)))

(define-macro
  ($lambda.body iform)
  (quasiquote (vector-ref (unquote iform) 6)))

(define-macro
  ($lambda.flag iform)
  (quasiquote (vector-ref (unquote iform) 7)))

(define-macro
  ($lambda.calls iform)
  (quasiquote (vector-ref (unquote iform) 8)))

(define-macro
  ($lambda.set-src! iform src)
  (quasiquote
    (vector-set! (unquote iform) 1 (unquote src))))

(define-macro
  ($lambda.set-name! iform name)
  (quasiquote
    (vector-set! (unquote iform) 2 (unquote name))))

(define-macro
  ($lambda.set-reqargs! iform reqargs)
  (quasiquote
    (vector-set! (unquote iform) 3 (unquote reqargs))))

(define-macro
  ($lambda.set-optarg! iform optarg)
  (quasiquote
    (vector-set! (unquote iform) 4 (unquote optarg))))

(define-macro
  ($lambda.set-lvars! iform lvars)
  (quasiquote
    (vector-set! (unquote iform) 5 (unquote lvars))))

(define-macro
  ($lambda.set-body! iform body)
  (quasiquote
    (vector-set! (unquote iform) 6 (unquote body))))

(define-macro
  ($lambda.set-flag! iform flag)
  (quasiquote
    (vector-set! (unquote iform) 7 (unquote flag))))

(define-macro
  ($lambda.set-calls! iform calls)
  (quasiquote
    (vector-set! (unquote iform) 8 (unquote calls))))

(define $LOCAL-REF 5)

(define
  ($local-ref lvar)
  (vector $LOCAL-REF lvar))

(define-macro
  ($local-ref.lvar iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($local-ref.set-lvar! iform lvar)
  (quasiquote
    (vector-set! (unquote iform) 1 (unquote lvar))))

(define $LOCAL-ASSIGN 6)

(define
  ($local-assign lvar val)
  (vector $LOCAL-ASSIGN lvar val))

(define-macro
  ($local-assign.lvar iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($local-assign.val iform)
  (quasiquote (vector-ref (unquote iform) 2)))

(define-macro
  ($local-assign.set-lvar! iform lvar)
  (quasiquote
    (vector-set! (unquote iform) 1 (unquote lvar))))

(define-macro
  ($local-assign.set-val! iform val)
  (quasiquote
    (vector-set! (unquote iform) 2 (unquote val))))

(define $GLOBAL-REF 7)

(define
  ($global-ref libname sym)
  (vector $GLOBAL-REF libname sym))

(define-macro
  ($global-ref.libname iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($global-ref.sym iform)
  (quasiquote (vector-ref (unquote iform) 2)))

(define-macro
  ($global-ref.set-libname! iform libname)
  (quasiquote
    (vector-set! (unquote iform) 1 (unquote libname))))

(define-macro
  ($global-ref.set-sym! iform sym)
  (quasiquote
    (vector-set! (unquote iform) 2 (unquote sym))))

(define $GLOBAL-ASSIGN 8)

(define
  ($global-assign libname sym val)
  (vector $GLOBAL-ASSIGN libname sym val))

(define-macro
  ($global-assign.libname iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($global-assign.sym iform)
  (quasiquote (vector-ref (unquote iform) 2)))

(define-macro
  ($global-assign.val iform)
  (quasiquote (vector-ref (unquote iform) 3)))

(define-macro
  ($global-assign.set-libname! iform libname)
  (quasiquote
    (vector-set! (unquote iform) 1 (unquote libname))))

(define-macro
  ($global-assign.set-sym! iform sym)
  (quasiquote
    (vector-set! (unquote iform) 2 (unquote sym))))

(define-macro
  ($global-assign.set-val! iform val)
  (quasiquote
    (vector-set! (unquote iform) 3 (unquote val))))

(define $UNDEF 9)

(define ($undef) (make-vector 1 $UNDEF))

(define $IF 10)

(define
  ($if test then else)
  (vector $IF test then else))

(define-macro
  ($if.test iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($if.then iform)
  (quasiquote (vector-ref (unquote iform) 2)))

(define-macro
  ($if.else iform)
  (quasiquote (vector-ref (unquote iform) 3)))

(define-macro
  ($if.set-test! iform test)
  (quasiquote
    (vector-set! (unquote iform) 1 (unquote test))))

(define-macro
  ($if.set-then! iform then)
  (quasiquote
    (vector-set! (unquote iform) 2 (unquote then))))

(define-macro
  ($if.set-else! iform else)
  (quasiquote
    (vector-set! (unquote iform) 3 (unquote else))))

(define $ASM 11)

(define ($asm insn args) (vector $ASM insn args))

(define-macro
  ($asm.insn iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($asm.args iform)
  (quasiquote (vector-ref (unquote iform) 2)))

(define-macro
  ($asm.set-insn! iform insn)
  (quasiquote
    (vector-set! (unquote iform) 1 (unquote insn))))

(define-macro
  ($asm.set-args! iform args)
  (quasiquote
    (vector-set! (unquote iform) 2 (unquote args))))

(define $DEFINE 12)

(define
  ($define libname sym val)
  (vector $DEFINE libname sym val))

(define-macro
  ($define.libname iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($define.sym iform)
  (quasiquote (vector-ref (unquote iform) 2)))

(define-macro
  ($define.val iform)
  (quasiquote (vector-ref (unquote iform) 3)))

(define-macro
  ($define.set-libname! iform libname)
  (quasiquote
    (vector-set! (unquote iform) 1 (unquote libname))))

(define-macro
  ($define.set-sym! iform sym)
  (quasiquote
    (vector-set! (unquote iform) 2 (unquote sym))))

(define-macro
  ($define.set-val! iform val)
  (quasiquote
    (vector-set! (unquote iform) 3 (unquote val))))

(define $CALL-CC 13)

(define
  ($call-cc proc tail?)
  (vector $CALL-CC proc tail?))

(define-macro
  ($call-cc.proc iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($call-cc.tail? iform)
  (quasiquote (vector-ref (unquote iform) 2)))

(define-macro
  ($call-cc.set-proc! iform proc)
  (quasiquote
    (vector-set! (unquote iform) 1 (unquote proc))))

(define-macro
  ($call-cc.set-tail?! iform tail?)
  (quasiquote
    (vector-set! (unquote iform) 2 (unquote tail?))))

(define $CALL 14)
(define ($call proc args tail? type)
  (vector $CALL proc args tail? type 0))

(define-macro ($call.proc iform) `(vector-ref ,iform 1))
(define-macro ($call.args iform) `(vector-ref ,iform 2))
(define-macro ($call.tail? iform) `(vector-ref ,iform 3))
(define-macro ($call.type iform) `(vector-ref ,iform 4))
(define-macro ($call.depth iform) `(vector-ref ,iform 5))
(define-macro ($call.set-proc! iform proc) `(vector-set! ,iform 1 ,proc))
(define-macro ($call.set-args! iform args) `(vector-set! ,iform 2 ,args))
(define-macro ($call.set-tail?! iform tail?) `(vector-set! ,iform 3 ,tail?))
(define-macro ($call.set-type! iform type) `(vector-set! ,iform 4 ,type))
(define-macro ($call.set-depth! iform type) `(vector-set! ,iform 5 ,type))

(define $LABEL 15)

(define ($label body) (vector $LABEL body))

(define-macro
  ($label.body iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($label.set-body! iform body)
  (quasiquote
    (vector-set! (unquote iform) 1 (unquote body))))

(define-macro
  (make-label)
  (quasiquote ($label #f)))

(define-macro (ref-label l) l)

(define $LIST 16)

(define ($list args) (vector $LIST args))

(define-macro
  ($list.args iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($list.set-args! iform args)
  (quasiquote
    (vector-set! (unquote iform) 1 (unquote args))))

(define $LIBRARY 17)

(define
  ($library
    name
    export-syms
    import-syms
    import
    macro
    body
    compiled-body)
  (vector
    $LIBRARY
    (libname->symbol name)
    export-syms
    import-syms
    import
    macro
    body
    compiled-body))

(define-macro
  ($library.name iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($library.export-syms iform)
  (quasiquote (vector-ref (unquote iform) 2)))

(define-macro
  ($library.import-syms iform)
  (quasiquote (vector-ref (unquote iform) 3)))

(define-macro
  ($library.import iform)
  (quasiquote (vector-ref (unquote iform) 4)))

(define-macro
  ($library.macro iform)
  (quasiquote (vector-ref (unquote iform) 5)))

(define-macro
  ($library.body iform)
  (quasiquote (vector-ref (unquote iform) 6)))

(define-macro
  ($library.compiled-body iform)
  (quasiquote (vector-ref (unquote iform) 7)))

(define-macro
  ($library.set-name! iform name)
  (quasiquote
    (vector-set! (unquote iform) 1 (unquote name))))

(define-macro
  ($library.set-export-syms! iform export-syms)
  (quasiquote
    (vector-set!
      (unquote iform)
      2
      (unquote export-syms))))

(define-macro
  ($library.set-import-syms! iform import-syms)
  (quasiquote
    (vector-set!
      (unquote iform)
      3
      (unquote import-syms))))

(define-macro
  ($library.set-import! iform import)
  (quasiquote
    (vector-set! (unquote iform) 4 (unquote import))))

(define-macro
  ($library.set-macro! iform macro)
  (quasiquote
    (vector-set! (unquote iform) 5 (unquote macro))))

(define-macro
  ($library.append-macro! iform macro)
  (quasiquote
    (vector-set!
      (unquote iform)
      5
      (append
        ($library.macro (unquote iform))
        (unquote macro)))))

(define-macro
  ($library.set-body! iform body)
  (quasiquote
    (vector-set! (unquote iform) 6 (unquote body))))

(define-macro
  ($library.set-compiled-body! iform compiled-body)
  (quasiquote
    (vector-set!
      (unquote iform)
      7
      (unquote compiled-body))))

(define $IMPORT 18)

(define
  ($import import-specs)
  (vecto $IMPORT import-specs))

(define-macro
  ($import.import-specs iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($import.set-import-specs! iform import-specs)
  (quasiquote
    (vector-set!
      (unquote iform)
      1
      (unquote import-specs))))

(define $IMPORT-SPEC 19)

(define
  ($import-spec libname level)
  (vector $IMPORT-SPEC libname level))

(define-macro
  ($import-spec.libname iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($import-spec.level iform)
  (quasiquote (vector-ref (unquote iform) 2)))

(define-macro
  ($import-spec.set-libname! iform libname)
  (quasiquote
    (vector-set! (unquote iform) 1 (unquote libname))))

(define-macro
  ($import-spec.set-level! iform level)
  (quasiquote
    (vector-set! (unquote iform) 2 (unquote level))))

(define $IT 20)

(define ($it) (make-vector 1 $IT))

(define $RECEIVE 21)

(define
  ($receive lvars reqargs optarg vals body tail?)
  (vector
    $RECEIVE
    lvars
    reqargs
    optarg
    vals
    body
    tail?))

(define-macro
  ($receive.lvars iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($receive.reqargs iform)
  (quasiquote (vector-ref (unquote iform) 2)))

(define-macro
  ($receive.optarg iform)
  (quasiquote (vector-ref (unquote iform) 3)))

(define-macro
  ($receive.vals iform)
  (quasiquote (vector-ref (unquote iform) 4)))

(define-macro
  ($receive.body iform)
  (quasiquote (vector-ref (unquote iform) 5)))

(define-macro
  ($receive.tail? iform)
  (quasiquote (vector-ref (unquote iform) 6)))

(define-macro
  ($receive.set-lvars! iform lvars)
  (quasiquote
    (vector-set! (unquote iform) 1 (unquote lvars))))

(define-macro
  ($receive.set-vals! iform body)
  (quasiquote
    (vector-set! (unquote iform) 4 (unquote body))))

(define-macro
  ($receive.set-body! iform body)
  (quasiquote
    (vector-set! (unquote iform) 5 (unquote body))))

(define-macro
  ($receive.set-tail?! iform tail?)
  (quasiquote
    (vector-set! (unquote iform) 6 (unquote tail?))))

(define $INSN-NUM 22)

(define-macro
  (tag iform)
  (quasiquote (vector-ref (unquote iform) 0)))

(define-macro
  (tag? iform t)
  (quasiquote
    (eqv? (unquote t) (tag (unquote iform)))))

(define-macro
  (set-tag! iform t)
  (quasiquote
    (vector-set! (unquote iform) 0 (unquote t))))

(define-macro
  (make-lvar sym)
  (quasiquote ($lvar (unquote sym) (quote ()) 0 0)))

(define-macro
  ($lvar.ref-count++! lvar)
  (quasiquote
    ($lvar.set-ref-count!
      (unquote lvar)
      (+ ($lvar.ref-count (unquote lvar)) 1))))

(define-macro
  ($lvar.ref-count--! lvar)
  (quasiquote
    ($lvar.set-ref-count!
      (unquote lvar)
      (- ($lvar.ref-count (unquote lvar)) 1))))

(define-macro
  ($lvar.set-count++! lvar)
  (quasiquote
    ($lvar.set-set-count!
      (unquote lvar)
      (+ 1 ($lvar.set-count (unquote lvar))))))

(define-macro
  ($local-ref.copy dst src)
  (quasiquote
    ($local-ref.set-lvar!
      (unquote dst)
      ($local-ref.lvar (unquote src)))))

(define-macro
  ($library.add-import-syms! library import-syms)
  (quasiquote
    ($library.set-import-syms!
      (unquote library)
      (append
        ($library.import-syms (unquote library))
        (unquote import-syms)))))

(define-macro
  ($library.add-import! library import)
  (quasiquote
    ($library.set-import!
      (unquote library)
      (append
        ($library.import (unquote library))
        (list (unquote import))))))

(define
  (make-empty-library name)
  ($library
    name
    (quote ())
    (quote ())
    (quote ())
    (quote ())
    (quote ())
    #f))

(define
  top-level-library
  (make-empty-library (quote (top-level))))

(define
  (parse-lambda-vars vars)
  (cond ((pair? vars)
         (let loop
              ((p vars) (ret (quote ())))
              (cond ((null? p) (list #f vars))
                    ((pair? p) (loop (cdr p) (cons (car p) ret)))
                    (else (list #t (reverse (cons p ret)))))))
        ((null? vars) (list #f (quote ())))
        (else (list #t (list vars)))))

(define
  (parse-lambda-args formals)
  (let loop
       ((formals formals) (args (quote ())))
       (cond ((null? formals)
              (values (reverse args) (length args) 0))
             ((pair? formals)
              (loop (cdr formals) (cons (car formals) args)))
             (else (values
                     (reverse (cons formals args))
                     (length args)
                     1)))))

(define-macro
  ($src x sexp)
  (quasiquote
    (set-source-info!
      (make-list-with-src-slot (unquote x))
      (source-info (unquote sexp)))))

(define
  (lambda-has-define? sexp)
  (and (not (null? (cddr sexp)))
       (pair? (third sexp))
       (eq? (car (third sexp)) (quote define))))

(define
  (let1->let sexp)
  (quasiquote
    (let (((unquote (second sexp)) (unquote (third sexp))))
         (unquote-splicing (cdddr sexp)))))

(define
  (expand-let vars body)
  (let1 expanded-vars
        (fold-right
          (lambda
            (x y)
            (cons (list (first x)  (pass1/expand (second x)))
                  y))
          (quote ())
          vars)
        (quasiquote
          (let (unquote expanded-vars)
               (unquote-splicing (pass1/expand body))))))

(define
  (pass1/expand sexp)
  (cond ((pair? sexp)
         (case (first sexp)
               ((quote) sexp)
               ((define-macro) sexp)
               ((define)
                (if (define-is-lambda? sexp)
                    (pass1/expand (define->lambda sexp))
                    ($src (imap (lambda (s) (pass1/expand s)) sexp)
                          sexp)))
               ((let1)
                ($src (pass1/expand (let1->let sexp)) sexp))
               ((let)
                (if (let-is-named? sexp)
                    ($src (pass1/expand (named-let->letrec sexp))
                          sexp)
                    ($src (expand-let (second sexp) (cddr sexp))
                          sexp)))
               ((let*)
                ($src (pass1/expand (let*->let sexp)) sexp))
               ((cond)
                ($src (pass1/expand (cond->if sexp)) sexp))
               ((lambda)
                (cond ((lambda-has-define? sexp)
                       ($src (pass1/expand
                               ($src (internal-define->letrec sexp) sexp))
                             sexp))
                      (else ($src (append!
                                    (list (quote lambda) (cadr sexp))
                                    (pass1/expand (cddr sexp)))
                                  sexp))))
               ((when)
                (match sexp
                       (((quote when) pred body . more)
                        ($src (pass1/expand
                                (quasiquote
                                  (cond ((unquote pred)
                                         (unquote body)
                                         (unquote-splicing more)))))
                              sexp))
                       (else (syntax-error "malformed when"))))
               ((unless)
                (match sexp
                       (((quote unless) pred body . more)
                        ($src (pass1/expand
                                (quasiquote
                                  (cond ((not (unquote pred))
                                         (unquote body)
                                         (unquote-splicing more)))))
                              sexp))
                       (else (syntax-error "malformed unless"))))
               ((aif)
                ($src (pass1/expand (aif->let sexp)) sexp))
               ((case)
                ($src (pass1/expand (case->cond sexp)) sexp))
               ((quasiquote) (expand-quasiquote (cadr sexp) 0))
               (else sexp)))
        (else sexp)))

(define
  (define-is-lambda? sexp)
  (pair? (cadr sexp)))

(define
  (conditions->if conditions)
  (if (null? (cdr conditions))
      (car conditions)
      (list (quote if)
            (car conditions)
            (conditions->if (cdr conditions))
            #f)))

(define
  (find-serial-from-head pred lst)
  (let loop
       ((found (quote ())) (lst lst))
       (cond ((null? lst)
              (if (null? found)
                  (list (quote ()) lst)
                  (values found (quote ()))))
             ((pred (car lst))
              (loop (append found (list (car lst))) (cdr lst)))
             (else (if (null? found)
                       (list (quote ()) lst)
                       (list found lst))))))

(define
  (internal-define->letrec sexp)
  (let* ((body (cddr sexp))
         (args (second sexp))
         (ret (find-serial-from-head
                (lambda
                  (s)
                  (and (pair? s) (eq? (quote define) (car s))))
                body))
         (defines (first ret))
         (rest (second ret))
         (letrec-body
           ($src (quasiquote
                   (letrec
                     (unquote
                       (map (lambda (d) (list (second d) (third d)))
                            (map pass1/expand defines)))
                     (unquote-splicing rest)))
                 sexp)))
        ($src (quasiquote
                (lambda (unquote args) (unquote letrec-body)))
              sexp)))

(define
  (define->lambda sexp)
  (let ((args (cadr sexp)) (body (cddr sexp)))
       (quasiquote
         (define
           (unquote (car args))
           (unquote
             ($src (append! (list (quote lambda) (cdr args)) body)
                   sexp))))))

(define
  (let*->let sexp)
  (let ((args (cadr sexp)) (body (cddr sexp)))
       (car (let loop
                 ((args args))
                 (if (null? args)
                     body
                     ($src (quasiquote
                             ((let ((unquote (car args)))
                                   (unquote-splicing (loop (cdr args))))))
                           sexp))))))

(define
  (cond->if sexp)
  (define
    (make-if test then else)
    (let ((then (if (> (length then) 1)
                    (cons (quote begin) then)
                    (car then))))
         (quasiquote
           (if (unquote test) (unquote then) (unquote else)))))
  (let loop
       ((clauses (cdr sexp)))
       (if (null? clauses)
           (quote #f)
           (cond ((and (null? (cdr clauses))
                       (eq? (quote else) (caar clauses)))
                  (if (> (length (cdar clauses)) 1)
                      (cons (quote begin) (cdar clauses))
                      (cadar clauses)))
                 ((and (= 3 (length (car clauses)))
                       (eq? (quote =>) (cadar clauses)))
                  (let ((tmp (gensym)))
                       (quasiquote
                         (let (((unquote tmp) (unquote (caar clauses))))
                              (if (unquote tmp)
                                  ((unquote (caddar clauses)) (unquote tmp))
                                  (unquote (loop (cdr clauses))))))))
                 ((= 1 (length (car clauses)))
                  (let ((tmp (gensym)))
                       (quasiquote
                         (let (((unquote tmp) (unquote (caar clauses))))
                              (if (unquote tmp)
                                  (unquote tmp)
                                  (unquote (loop (cdr clauses))))))))
                 (else (make-if
                         (caar clauses)
                         (cdar clauses)
                         (loop (cdr clauses))))))))

(define
  (expand-clauses clauses tmpname)
  (let loop
       ((clauses clauses))
       (if (null? clauses)
           (quote ())
           (if (eq? (quote else) (caar clauses))
               clauses
               (if (= 1 (length (caar clauses)))
                   (cons (quasiquote
                           ((eqv? (quote (unquote (caaar clauses)))
                                  (unquote tmpname))
                            (unquote-splicing (cdar clauses))))
                         (loop (cdr clauses)))
                   (cons (quasiquote
                           ((memv (unquote tmpname)
                                  (quote (unquote (caar clauses))))
                            (unquote-splicing (cdar clauses))))
                         (loop (cdr clauses))))))))

(define
  (case->cond sexp)
  (let* ((pred (cadr sexp))
         (clauses (cddr sexp))
         (tmpname (gensym))
         (expanded-clauses
           (expand-clauses clauses tmpname)))
        (quasiquote
          (let (((unquote tmpname) (unquote pred)))
               (cond (unquote-splicing expanded-clauses))))))

(define
  (named-let->letrec sexp)
  (let* ((name (cadr sexp))
         (args (caddr sexp))
         (vars (imap car args))
         (vals (imap cadr args))
         (body (cdddr sexp))
         (lambda-body
           ($src (quasiquote
                   (lambda (unquote vars) (unquote-splicing body)))
                 sexp)))
        ($src (quasiquote
                (letrec
                  (((unquote name) (unquote lambda-body)))
                  ((unquote name) (unquote-splicing vals))))
              sexp)))

(define
  (aif->let sexp)
  (quasiquote
    (let ((it (unquote (cadr sexp))))
         (if it
             (unquote (caddr sexp))
             (unquote (cadddr sexp))))))

(define
  (let-is-named? sexp)
  (symbol? (cadr sexp)))

(define
  (finalize-quasiquote mode arg)
  (cond ((eq? mode (quote quote))
         (list (quote quote) arg))
        ((eq? mode (quote unquote)) arg)
        ((eq? mode (quote unquote-splicing))
         (error (quote quasiquote)
                ",@ in invalid context"
                arg))
        (else (cons mode arg))))

(define
  (descend-quasiquote x level return)
  (cond ((vector? x)
         (descend-quasiquote-vector x level return))
        ((not (pair? x)) (return (quote quote) x))
        ((interesting-to-quasiquote? x (quote quasiquote))
         (descend-quasiquote-pair x (+ level 1) return))
        ((interesting-to-quasiquote? x (quote unquote))
         (cond ((= level 0) (return (quote unquote) (cadr x)))
               (else (descend-quasiquote-pair x (- level 1) return))))
        ((interesting-to-quasiquote?
           x
           (quote unquote-splicing))
         (cond ((= level 0)
                (return (quote unquote-splicing) (cadr x)))
               (else (descend-quasiquote-pair x (- level 1) return))))
        (else (descend-quasiquote-pair x level return))))

(define
  (descend-quasiquote-pair x level return)
  (descend-quasiquote
    (car x)
    level
    (lambda
      (car-mode car-arg)
      (descend-quasiquote
        (cdr x)
        level
        (lambda
          (cdr-mode cdr-arg)
          (cond ((and (eq? car-mode (quote quote))
                      (eq? cdr-mode (quote quote)))
                 (return (quote quote) x))
                ((eq? car-mode (quote unquote-splicing))
                 (cond ((and (eq? cdr-mode (quote quote))
                             (null? cdr-arg))
                        (return (quote unquote) car-arg))
                       (else (return
                               (quote append)
                               (list car-arg
                                     (finalize-quasiquote
                                       cdr-mode
                                       cdr-arg))))))
                (else (return
                        (quote cons)
                        (list (finalize-quasiquote car-mode car-arg)
                              (finalize-quasiquote cdr-mode cdr-arg))))))))))

(define
  (descend-quasiquote-vector x level return)
  (descend-quasiquote
    (vector->list x)
    level
    (lambda
      (mode arg)
      (if (eq? mode (quote quote))
          (return (quote quote) x)
          (return
            (quote list->vector)
            (list (finalize-quasiquote mode arg)))))))

(define
  (interesting-to-quasiquote? x marker)
  (and (pair? x) (eq? (car x) marker)))

(define
  (expand-quasiquote x level)
  (descend-quasiquote x level finalize-quasiquote))

(define
  (find-with-car object lst)
  (if (null? lst)
      #f
      (if (eq? object (caar lst))
          (car lst)
          (find-with-car object (cdr lst)))))

(define
  (pass1/lib-refer->iform symbol library)
  (let1 import-syms
        ($library.import-syms library)
        (aif (find-with-car symbol import-syms)
             ($global-ref (second it) (third it))
             ($global-ref ($library.name library) symbol))))

(define
  (pass1/lib-assign->iform symbol library val)
  (let1 import-syms
        ($library.import-syms library)
        (aif (find-with-car symbol import-syms)
             ($global-assign (second it) (third it) val)
             ($global-assign
               ($library.name library)
               symbol
               val))))

(define (pass1/find-symbol-in-lvars symbol lvars) (cond ((null? lvars) #f) ((eq? symbol ($lvar.sym (car lvars))) (car lvars)) (else (pass1/find-symbol-in-lvars symbol (cdr lvars)))))(define
  (pass1/refer->iform symbol library lvars)
  (acond ((pass1/find-symbol-in-lvars symbol lvars)
          ($lvar.ref-count++! it)
          ($local-ref it))
         ((pass1/lib-refer->iform symbol library) it)
         (#t ($global-ref (quote (top-level)) symbol))))

(define
  (pass1/assign symbol val library lvars tail?)
  (let1 iform
        (pass1/sexp->iform val library lvars tail?)
        (acond ((pass1/find-symbol-in-lvars symbol lvars)
                ($lvar.set-count++! it)
                ($local-assign it iform))
               ((pass1/lib-assign->iform symbol library iform)
                it)
               (#t
                ($global-assign (quote (top-level)) symbol iform)))))

(define
  (pass1/body->iform body library lvars tail?)
  (let1 iforms
        ($map1-with-tail
          (lambda
            (b t?)
            (pass1/sexp->iform
              (pass1/expand b)
              library
              lvars
              (and t? tail?)))
          body)
        (if (= 1 (length iforms))
            (car iforms)
            ($seq iforms tail?))))

(define
  (dotpair->list p)
  (let loop
       ((p p))
       (cond ((and (not (pair? p)) (not (null? p)))
              (cons p (quote ())))
             ((null? p) (quote ()))
             (else (cons (car p) (loop (cdr p)))))))

(define
  (pass1/lambda->iform name sexp library lvars)
  (let* ((vars (second sexp))
         (body (cddr sexp))
         (parsed-vars (parse-lambda-vars vars))
         (optional-arg? (first parsed-vars))
         (vars (second parsed-vars))
         (this-lvars
           (imap (lambda (sym) ($lvar sym #f 0 0)) vars))
         (vars-length (length vars)))
        ($lambda
          (cons (source-info sexp)
                (cons name (dotpair->list (second sexp))))
          name
          (if optional-arg? (- vars-length 1) vars-length)
          (if optional-arg? 1 0)
          this-lvars
          (pass1/body->iform
            body
            library
            (append this-lvars lvars)
            #t)
          (quote ())
          (quote ()))))

(define libraries (make-eq-hashtable))

(define-macro
  (make-identifier alias libname name)
  (quasiquote
    (list (unquote alias)
          (unquote libname)
          (unquote name))))

(define
  (copy-identifier i)
  (list (first i) (second i) (third i)))

(define
  (library-name form)
  (remove-tail (second form) pair?))

(define
  (pass1/and->iform sexp library lvars tail?)
  (define
    (rec s)
    (match s
           (() ($const #t))
           ((s)
            (pass1/sexp->iform
              (pass1/expand s)
              library
              lvars
              tail?))
           ((e . more)
            ($if (pass1/sexp->iform
                   (pass1/expand e)
                   library
                   lvars
                   tail?)
                 (rec more)
                 ($it)))
           (else (error (quote compiler)
                        "syntax-error: malformed and:"
                        sexp))))
  (rec (cdr sexp)))

(define
  (pass1/or->iform sexp library lvars tail?)
  (define
    (rec s)
    (match s
           (() ($const #f))
           ((s)
            (pass1/sexp->iform
              (pass1/expand s)
              library
              lvars
              tail?))
           ((e . more)
            ($if (pass1/sexp->iform
                   (pass1/expand e)
                   library
                   lvars
                   tail?)
                 ($it)
                 (rec more)))
           (else (error (quote compiler)
                        "syntax-error: malformed or:"
                        sexp))))
  (rec (cdr sexp)))

(define
  (pass1/macroexpand sexp)
  (let1 proc
        (first sexp)
        (acond ((and (symbol? proc)
                     (assq proc ($library.macro top-level-library)))
                (pass1/expand (vm/apply (cdr it) (cdr sexp))))
               (#t sexp))))

(define-macro
  (case-with-time val . clauses)
  (quasiquote
    (case (unquote val)
          (unquote-splicing
            (map (lambda
                   (clause)
                   (match clause
                          ((p . more)
                           (let1 temp
                                 (gensym)
                                 (quasiquote
                                   ((unquote p)
                                    (let1 (unquote temp)
                                          (get-timeofday)
                                          (let1 v
                                                (begin (unquote-splicing more))
                                                (dd "(log ")
                                                (dd (quote (unquote p)))
                                                (dd (unquote temp))
                                                (dd (get-timeofday))
                                                (dd ")
")
                                                v))))))))
                 clauses)))))

(define-macro
  (case-with-lambda val . clauses)
  (quasiquote
    (case (unquote val)
          (unquote-splicing
            (map (lambda
                   (clause)
                   (match clause
                          (((quote else) . more)
                           (quasiquote
                             (else ((lambda
                                      (else)
                                      (set! else 3)
                                      (unquote-splicing more))
                                    4))))
                          ((p . more)
                           (if (and (pair? p) (symbol? (car p)))
                               (let1 sym
                                     (string->symbol
                                       (string-append
                                         "profile-"
                                         (symbol->string (car p))))
                                     (quasiquote
                                       ((unquote p)
                                        ((lambda
                                           ((unquote sym))
                                           (set! (unquote sym) 3)
                                           (unquote-splicing more))
                                         4))))
                               (quasiquote
                                 ((unquote p)
                                  ((lambda
                                     (anonymous)
                                     (set! anonymous 3)
                                     (unquote-splicing more))
                                   4)))))))
                 clauses)))))

(define-macro
  (pass1/s->i sexp)
  (quasiquote
    (pass1/sexp->iform
      (pass1/expand (unquote sexp))
      library
      lvars
      tail?)))

(define-macro
  (pass1/map-s->i sexp)
  (quasiquote
    (imap (lambda (s) (pass1/s->i s)) (unquote sexp))))

(define
  (pass1/call proc args library lvars tail?)
;  (write/ss (map car ($library.macro library)))
  (acond ((and (symbol? proc)
                (assq proc ($library.macro library)))
          (pass1/s->i (vm/apply (cdr it) args)))
         ((and (symbol? proc)
               (find-with-car
                 proc
                 ($library.import-syms library)))
          (let* ((lib (hashtable-ref libraries (second it) #f))
                 (macro (assq (third it) ($library.macro lib))))
                (if macro
                    (pass1/s->i (vm/apply (cdr macro) args))
                    ($call (pass1/s->i proc)
                           (pass1/map-s->i args)
                           tail?
                           #f))))
         (#t
          ($call (pass1/s->i proc)
                 (pass1/map-s->i args)
                 tail?
                 #f))))

(define
  (pass1/define sexp library lvars tail?)
  (match sexp
         (((quote define) name ((quote lambda) . more))
          (let1 closure
                (make-list-with-src-slot
                  (cons (quote lambda) more))
                (set-source-info!
                  closure
                  (source-info (third sexp)))
                ($define
                  ($library.name library)
                  name
                  (pass1/lambda->iform name closure library lvars))))
         (else ($define
                 ($library.name library)
                 (second sexp)
                 (pass1/s->i (third sexp))))))

(define
  (pass1/receive sexp library lvars tail?)
  (match sexp
         (((quote receive) vars vals . body)
          (receive
            (vars reqargs optarg)
            (parse-lambda-args vars)
            (let1 this-lvars
                  (imap (lambda (sym) ($lvar sym #f 0 0)) vars)
                  ($receive
                    this-lvars
                    reqargs
                    optarg
                    (pass1/s->i vals)
                    (pass1/body->iform
                      (pass1/expand body)
                      library
                      (append this-lvars lvars)
                      tail?)
                    tail?))))
         (else (syntax-error "malformed receive"))))

(define
  (pass1/let
    vars
    vals
    body
    source-info
    library
    lvars
    tail?)
  (let* ((inits (pass1/map-s->i vals))
         (this-lvars
           (map (lambda (sym init) ($lvar sym init 0 0))
                vars
                inits)))
        ($let (quote let)
              this-lvars
              inits
              (pass1/body->iform
                (pass1/expand body)
                library
                (append this-lvars lvars)
                tail?)
              tail?
              source-info)))

(define
  (make-compile-error who message . irritants)
  (list who message irritants))

(define
  (pass1/letrec
    vars
    vals
    body
    source-info
    library
    lvars
    tail?)
  (let* ((this-lvars
           (imap (lambda (sym) ($lvar sym ($undef) 0 0))
                 vars))
         (inits (imap (lambda
                        (x)
                        (pass1/sexp->iform
                          x
                          library
                          (append this-lvars lvars)
                          tail?))
                      vals)))
        (for-each
          (lambda
            (lvar init)
            ($lvar.set-init-val! lvar init))
          this-lvars
          inits)
        (let1 found-error
              (find (lambda
                      (init)
                      (and (tag? init $LOCAL-REF)
                           (memq ($local-ref.lvar init) this-lvars)))
                    inits)
              ($let (quote rec)
                    this-lvars
                    inits
                    (pass1/body->iform
                      (pass1/expand body)
                      library
                      (append this-lvars lvars)
                      tail?)
                    tail?
                    source-info
                    (if found-error
                        (make-compile-error
                          (quote letrec)
                          "reference to uninitialized variable on letrec"
                          (ungensym
                            ($lvar.sym ($local-ref.lvar found-error))))
                        #f)))))

(define
  (pass1/if test then more library lvars tail?)
  ($if (pass1/sexp->iform
         (pass1/expand test)
         library
         lvars
         #f)
       (pass1/s->i then)
       (if (null? more)
           ($undef)
           (pass1/s->i (car more)))))

(define
  (pass1/define-macro sexp library lvars tail?)
  (if (pair? (second sexp))
      ($library.set-macro!
        library
        (alist-cons
          (caadr sexp)
          (compile-partial
            (quasiquote
              (lambda
                (unquote (cdadr sexp))
                (unquote (third sexp))))
            library)
          ($library.macro library)))
      ($library.set-macro!
        library
        (alist-cons
          (second sexp)
          (compile-partial (third sexp))
          ($library.macro library))))
  ($undef))

(define
  (pass1/asm-numcmp
    tag
    operator
    args
    library
    lvars
    tail?)
  (let1 len
        (length args)
        (cond ((> 2 len)
               (error operator " got too few argument"))
              ((= 2 len)
               ($asm tag
                     (list (pass1/s->i (first args))
                           (pass1/s->i (second args)))))
              (else (pass1/s->i
                      (conditions->if (apply-each-pair operator args)))))))

(define
  (pass1/asm-1-arg tag arg1 library lvars tail?)
  ($asm tag (list (pass1/s->i arg1))))

(define
  (pass1/asm-2-arg
    tag
    arg1
    arg2
    library
    lvars
    tail?)
  ($asm tag
        (list (pass1/s->i arg1) (pass1/s->i arg2))))

(define
  (pass1/asm-3-arg
    tag
    arg1
    arg2
    arg3
    library
    lvars
    tail?)
  ($asm tag
        (list (pass1/s->i arg1)
              (pass1/s->i arg2)
              (pass1/s->i arg3))))

(define
  (pass1/asm-1-arg-optional
    tag
    args
    library
    lvars
    tail?)
  (let1 arg1
        (if (null? args) (quote ()) (car args))
        ($asm tag (list (pass1/s->i arg1)))))

(define
  (pass1/asm-2-arg-optional
    tag
    arg1
    rest
    library
    lvars
    tail?)
  (let1 arg2
        (if (null? rest) (quote ()) (car rest))
        ($asm tag
              (list (pass1/s->i arg1) (pass1/s->i arg2)))))

(define
  (pass1/asm-n-args
    tag
    operator
    args
    library
    lvars
    tail?)
  (let1 len
        (length args)
        (cond ((zero? len)
               (case operator
                     ((+) (pass1/s->i 0))
                     ((*) (pass1/s->i 1))
                     (else (error operator " got too few argment"))))
              ((= 1 len)
               (case operator
                     ((-)
                      (pass1/s->i
                        (quasiquote (* -1 (unquote (car args))))))
                     ((/)
                      (pass1/s->i
                        (quasiquote (/ 1 (unquote (car args))))))
                     (else (pass1/s->i (car args)))))
              ((= 2 len)
               ($asm tag
                     (list (pass1/s->i (first args))
                           (pass1/s->i (second args)))))
              (else (let1 args-iform
                          (pass1/map-s->i args)
                          (fold (lambda (x y) ($asm tag (list y x)))
                                (car args-iform)
                                (cdr args-iform)))))))

(define
  (pass1/sexp->iform sexp library lvars tail?)
  (cond ((pair? sexp)
         (case (car sexp)
               ((lambda)
                (pass1/lambda->iform
                  (quote lambda)
                  sexp
                  library
                  lvars))
               ((cons)
                ($asm (quote CONS) (pass1/map-s->i (cdr sexp))))
               ((and)
                (pass1/and->iform sexp library lvars tail?))
               ((or) (pass1/or->iform sexp library lvars tail?))
               ((begin)
                (pass1/body->iform
                  (pass1/expand (cdr sexp))
                  library
                  lvars
                  tail?))
               ((values)
                ($asm (quote VALUES) (pass1/map-s->i (cdr sexp))))
               ((define)
                (pass1/define sexp library lvars tail?))
               ((define-macro)
                (pass1/define-macro sexp library lvars tail?))
               ((receive)
                (pass1/receive sexp library lvars tail?))
               ((let)
                (pass1/let
                  (imap car (second sexp))
                  (imap cadr (second sexp))
                  (cddr sexp)
                  (source-info sexp)
                  library
                  lvars
                  tail?))
               ((letrec)
                (pass1/letrec
                  (imap car (second sexp))
                  (imap cadr (second sexp))
                  (cddr sexp)
                  (source-info sexp)
                  library
                  lvars
                  tail?))
               ((letrec*)
                (pass1/letrec
                  (imap car (second sexp))
                  (imap cadr (second sexp))
                  (cddr sexp)
                  (source-info sexp)
                  library
                  lvars
                  tail?))
               ((set!)
                (pass1/assign
                  (second sexp)
                  (pass1/expand (third sexp))
                  library
                  lvars
                  tail?))
               ((if)
                (pass1/if
                  (second sexp)
                  (third sexp)
                  (cdddr sexp)
                  library
                  lvars
                  tail?))
               ((%call/cc)
                ($call-cc (pass1/s->i (second sexp)) tail?))
               ((%call-with-current-continuation)
                ($call-cc (pass1/s->i (second sexp)) tail?))
               ((quote) ($const (second sexp)))
               ((append)
                (pass1/asm-n-args
                  (quote APPEND2)
                  (quote dummy)
                  (cdr sexp)
                  library
                  lvars
                  tail?))
               ((+)
                (pass1/asm-n-args
                  (quote NUMBER_ADD)
                  (quote +)
                  (cdr sexp)
                  library
                  lvars
                  tail?))
               ((-)
                (pass1/asm-n-args
                  (quote NUMBER_SUB)
                  (quote -)
                  (cdr sexp)
                  library
                  lvars
                  tail?))
               ((*)
                (pass1/asm-n-args
                  (quote NUMBER_MUL)
                  (quote *)
                  (cdr sexp)
                  library
                  lvars
                  tail?))
               ((/)
                (pass1/asm-n-args
                  (quote NUMBER_DIV)
                  (quote /)
                  (cdr sexp)
                  library
                  lvars
                  tail?))
               ((=)
                (pass1/asm-numcmp
                  (quote NUMBER_EQUAL)
                  (quote =)
                  (cdr sexp)
                  library
                  lvars
                  tail?))
               ((>=)
                (pass1/asm-numcmp
                  (quote NUMBER_GE)
                  (quote >=)
                  (cdr sexp)
                  library
                  lvars
                  tail?))
               ((>)
                (pass1/asm-numcmp
                  (quote NUMBER_GT)
                  (quote >)
                  (cdr sexp)
                  library
                  lvars
                  tail?))
               ((<)
                (pass1/asm-numcmp
                  (quote NUMBER_LT)
                  (quote <)
                  (cdr sexp)
                  library
                  lvars
                  tail?))
               ((<=)
                (pass1/asm-numcmp
                  (quote NUMBER_LE)
                  (quote <=)
                  (cdr sexp)
                  library
                  lvars
                  tail?))
               ((vector?)
                (pass1/asm-1-arg
                  (quote VECTOR_P)
                  (second sexp)
                  library
                  lvars
                  tail?))
               ((vector-length)
                (pass1/asm-1-arg
                  (quote VECTOR_LENGTH)
                  (second sexp)
                  library
                  lvars
                  tail?))
               ((vector-set!)
                (pass1/asm-3-arg
                  (quote VECTOR_SET)
                  (second sexp)
                  (third sexp)
                  (fourth sexp)
                  library
                  lvars
                  tail?))
               ((vector-ref)
                (pass1/asm-2-arg
                  (quote VECTOR_REF)
                  (second sexp)
                  (third sexp)
                  library
                  lvars
                  tail?))
               ((make-vector)
                (pass1/asm-2-arg-optional
                  (quote MAKE_VECTOR)
                  (second sexp)
                  (cddr sexp)
                  library
                  lvars
                  tail?))
               ((car)
                (pass1/asm-1-arg
                  (quote CAR)
                  (second sexp)
                  library
                  lvars
                  tail?))
               ((cdr)
                (pass1/asm-1-arg
                  (quote CDR)
                  (second sexp)
                  library
                  lvars
                  tail?))
               ((caar)
                (pass1/asm-1-arg
                  (quote CAAR)
                  (second sexp)
                  library
                  lvars
                  tail?))
               ((cadr)
                (pass1/asm-1-arg
                  (quote CADR)
                  (second sexp)
                  library
                  lvars
                  tail?))
               ((cdar)
                (pass1/asm-1-arg
                  (quote CDAR)
                  (second sexp)
                  library
                  lvars
                  tail?))
               ((cddr)
                (pass1/asm-1-arg
                  (quote CDDR)
                  (second sexp)
                  library
                  lvars
                  tail?))
               ((set-car!)
                (pass1/asm-2-arg
                  (quote SET_CAR)
                  (second sexp)
                  (third sexp)
                  library
                  lvars
                  tail?))
               ((set-cdr!)
                (pass1/asm-2-arg
                  (quote SET_CDR)
                  (second sexp)
                  (third sexp)
                  library
                  lvars
                  tail?))
               ((eq?)
                (pass1/asm-2-arg
                  (quote EQ)
                  (second sexp)
                  (third sexp)
                  library
                  lvars
                  tail?))
               ((eqv?)
                (pass1/asm-2-arg
                  (quote EQV)
                  (second sexp)
                  (third sexp)
                  library
                  lvars
                  tail?))
               ((equal?)
                (pass1/asm-2-arg
                  (quote EQUAL)
                  (second sexp)
                  (third sexp)
                  library
                  lvars
                  tail?))
               ((not)
                (pass1/asm-1-arg
                  (quote NOT)
                  (second sexp)
                  library
                  lvars
                  tail?))
               ((null?)
                (pass1/asm-1-arg
                  (quote NULL_P)
                  (second sexp)
                  library
                  lvars
                  tail?))
               ((pair?)
                (pass1/asm-1-arg
                  (quote PAIR_P)
                  (second sexp)
                  library
                  lvars
                  tail?))
               ((symbol?)
                (pass1/asm-1-arg
                  (quote SYMBOL_P)
                  (second sexp)
                  library
                  lvars
                  tail?))
               ((read)
                (pass1/asm-1-arg-optional
                  (quote READ)
                  (cdr sexp)
                  library
                  lvars
                  tail?))
               ((read-char)
                (pass1/asm-1-arg-optional
                  (quote READ_CHAR)
                  (cdr sexp)
                  library
                  lvars
                  tail?))
               (else (pass1/call
                       (car sexp)
                       (cdr sexp)
                       library
                       lvars
                       tail?))))
        ((symbol? sexp)
         (pass1/refer->iform sexp library lvars))
        (else ($const sexp))))

(define
  (pretty-iform iform)
  (define labels (quote ()))
  (define
    (indent count)
    (dotimes (i count) (write-char #\space)))
  (define (nl ind) (newline) (indent ind))
  (define
    (lvar->string lvar)
    (format
      "~a[~a ~a]"
      ($lvar.sym lvar)
      ($lvar.ref-count lvar)
      ($lvar.set-count lvar)))
  (define
    (rec ind iform)
    (cond ((tag? iform $CONST)
           (format #t "($CONST ~s)" ($const.val iform)))
          ((tag? iform $UNDEF) (display "($UNDEF)"))
          ((tag? iform $LAMBDA)
           (format
             #t
             "($LAMBDA[~a ~a ~a]"
             ($lambda.name iform)
             (map lvar->string ($lambda.lvars iform))
             ($lambda.flag iform))
           (nl (+ ind 2))
           (rec (+ ind 2) ($lambda.body iform))
           (display ")"))
          ((tag? iform $SEQ)
           (format #t "($SEQ")
           (for-each
             (lambda
               (node)
               (nl (+ ind 2))
               (rec (+ ind 2) node))
             ($seq.body iform))
           (display ")"))
          ((tag? iform $LIBRARY)
           (format
             #t
             "($LIBRARY ~a export [~a] import [~a]"
             ($library.name iform)
             ($library.export-syms iform)
             ($library.import-syms iform))
           (nl (+ ind 2))
           (display ")"))
          ((tag? iform $RECEIVE) 'todo)
          ((tag? iform $LOCAL-REF)
           (format
             #t
             "($LOCAL-REF ~a)"
             (lvar->string ($local-ref.lvar iform))))
          ((tag? iform $GLOBAL-REF)
           (format
             #t
             "($GLOBAL-REF ~a ~a)"
             ($global-ref.libname iform)
             ($global-ref.sym iform)))
          ((tag? iform $LOCAL-ASSIGN)
           (format
             #t
             "($LOCAL-ASSIGN ~a"
             (lvar->string ($local-assign.lvar iform)))
           (nl (+ ind 2))
           (rec (+ ind 2) ($local-assign.val iform))
           (display ")"))
          ((tag? iform $GLOBAL-ASSIGN)
           (format
             #t
             "($GLOBAL-ASSIGN ~a ~a)"
             ($global-assign.sym iform)
             ($global-assign.val iform)))
          ((tag? iform $LET)
           (let* ((hdr (format "($LET ("))
                  (xind (+ ind (string-length hdr))))
                 (display hdr)
                 (for-each
                   (lambda
                     (var init)
                     (let1 z
                           (format "(~a " (lvar->string var))
                           (display z)
                           (rec (+ xind (string-length z)) init)
                           (display ")")
                           (nl xind)))
                   ($let.lvars iform)
                   ($let.inits iform))
                 (display ")")
                 (nl (+ ind 2))
                 (rec (+ ind 2) ($let.body iform))
                 (display ")")))
          ((tag? iform $IF)
           (display "($IF ")
           (rec (+ ind 5) ($if.test iform))
           (nl (+ ind 2))
           (rec (+ ind 2) ($if.then iform))
           (nl (+ ind 2))
           (rec (+ ind 2) ($if.else iform))
           (display ")"))
          ((tag? iform $LABEL)
           (cond ((assq iform labels)
                  =>
                  (lambda (p) (format #t "label#~a" (cdr p))))
                 (else (let1 num
                             (length labels)
                             (push! labels (cons iform num))
                             (format #t "($label #~a" num)
                             (nl (+ ind 2))
                             (rec (+ ind 2) ($label.body iform))
                             (display ")")))))
          ((tag? iform $ASM)
           (let1 insn
                 ($asm.insn iform)
                 (format #t "($asm ~a" insn))
           (for-each
             (lambda
               (node)
               (nl (+ ind 2))
               (rec (+ ind 2) node))
             ($asm.args iform))
           (display ")"))
          ((tag? iform $DEFINE)
           (format
             #t
             "($DEFINE ~a:~a"
             ($define.libname iform)
             ($define.sym iform))
           (nl (+ ind 2))
           (rec (+ ind 2) ($define.val iform))
           (display ")"))
          ((tag? iform $CALL-CC)
           (display "($CALL-CC ")
           (rec 0 ($call-cc.proc iform))
           (display ")"))
          ((tag? iform $LABEL)
           (display "($LABEL ")
           (rec 0 ($label.body iform))
           (display ")"))
          ((tag? iform $IT) (display "it"))
          ((tag? iform $CALL)
           (let1 pre
                 (cond (($call.tail? iform)
                        =>
                        (lambda (x) "($call[tail] "))
                       (else "($call "))
                 (format #t pre)
                 (format #t "[~a]" ($call.type iform))
                 (rec (+ ind (string-length pre))
                      ($call.proc iform))
                 (for-each
                   (lambda
                     (node)
                     (nl (+ ind 2))
                     (rec (+ ind 2) node))
                   ($call.args iform))
                 (display ")")))
          (else (error "pretty-iform: unknown tag:" (tag iform)))))
  (rec 0 iform)
  (newline))

(define SMALL_LAMBDA_SIZE 12)

(define
  pass2/dispatch-table
  (make-vector $INSN-NUM))

(define
  (pass2/$let iform closures)
  (cond (($let.error iform) iform)
        (else ($let.set-body!
                iform
                (pass2/optimize ($let.body iform) closures))
              ($let.set-inits!
                iform
                (imap (lambda (i) (pass2/optimize i closures))
                      ($let.inits iform)))
              (let1 o
                    (pass2/eliminate-let iform)
                    (if (eq? o iform) o (pass2/optimize o closures))))))

(define
  (pass2/$receive iform closures)
  ($receive.set-body!
    iform
    (pass2/optimize ($receive.body iform) closures))
  ($receive.set-vals!
    iform
    (pass2/optimize ($receive.vals iform) closures))
  iform)

(define
  (pass2/$local-ref iform closures)
  (pass2/optimize-local-ref iform)
  iform)

(define
  (pass2/$seq iform closures)
  ($seq.set-body!
    iform
    (imap (lambda (x) (pass2/optimize x closures))
          ($seq.body iform)))
  iform)

(define
  (pass2/const-inliner iform)
  (let ((insn ($asm.insn iform))
        (args ($asm.args iform)))
       (case insn
             ((NUMBER_ADD)
              (when (and (tag? (first args) $CONST)
                         (tag? (second args) $CONST))
                    (vector-set! iform 0 $CONST)
                    ($const.set-val!
                      iform
                      (+ ($const.val (first args))
                         ($const.val (second args))))))
             ((NUMBER_MUL)
              (when (and (tag? (first args) $CONST)
                         (tag? (second args) $CONST))
                    (vector-set! iform 0 $CONST)
                    ($const.set-val!
                      iform
                      (* ($const.val (first args))
                         ($const.val (second args))))))
             ((NUMBER_MINUS)
              (when (and (tag? (first args) $CONST)
                         (tag? (second args) $CONST))
                    (vector-set! iform 0 $CONST)
                    ($const.set-val!
                      iform
                      (- ($const.val (first args))
                         ($const.val (second args))))))
             (else #f))))

(define
  (pass2/$asm iform closures)
  ($asm.set-args!
    iform
    (imap (lambda (x) (pass2/optimize x closures))
          ($asm.args iform)))
  (pass2/const-inliner iform)
  iform)

(define
  (pass2/$lambda iform closures)
  ($lambda.set-body!
    iform
    (pass2/optimize
      ($lambda.body iform)
      (cons iform closures)))
  iform)

(define
  (pass2/$if iform closures)
  (let ((test-c
          (pass2/optimize ($if.test iform) closures))
        (then-c
          (pass2/optimize ($if.then iform) closures))
        (else-c
          (pass2/optimize ($if.else iform) closures)))
       ($if test-c then-c else-c)))

(define
  (pass2/$local-assign iform closures)
  ($local-assign.set-val!
    iform
    (pass2/optimize
      ($local-assign.val iform)
      closures))
  iform)

(define
  (pass2/$call iform closures)
  (pass2/collect-call iform closures))

(define (pass2/empty iform closures) iform)

(define
  (pass2/register insn proc)
  (vector-set! pass2/dispatch-table insn proc))

(pass2/register $CONST pass2/empty)

(pass2/register $LAMBDA pass2/$lambda)

(pass2/register $LOCAL-REF pass2/$local-ref)

(pass2/register
  $LOCAL-ASSIGN
  pass2/$local-assign)

(pass2/register $GLOBAL-ASSIGN pass2/empty)

(pass2/register $GLOBAL-REF pass2/empty)

(pass2/register $SEQ pass2/$seq)

(pass2/register $UNDEF pass2/empty)

(pass2/register $IF pass2/$if)

(pass2/register $ASM pass2/$asm)

(pass2/register $DEFINE pass2/empty)

(pass2/register $CALL pass2/$call)

(pass2/register $CALL-CC pass2/empty)

(pass2/register $LET pass2/$let)

(pass2/register $LIST pass2/empty)

(pass2/register $IMPORT pass2/empty)

(pass2/register $IT pass2/empty)

(pass2/register $RECEIVE pass2/$receive)

(define
  (pass2/optimize iform closures)
  ((vector-ref
     pass2/dispatch-table
     (vector-ref iform 0))
   iform
   closures))

(define
  (pass2/optimize-local-ref iform)
  (let* ((lvar ($local-ref.lvar iform))
         (init-val ($lvar.init-val lvar)))
        (cond ((and init-val
                    (zero? ($lvar.set-count lvar))
                    (tag? init-val $CONST))
               (set-tag! iform $CONST)
               ($lvar.ref-count--! lvar)
               ($const.set-val! iform ($const.val init-val)))
              ((and init-val
                    (tag? init-val $LOCAL-REF)
                    (zero? ($lvar.set-count ($local-ref.lvar init-val))))
               ($lvar.ref-count--! lvar)
               ($lvar.ref-count++! ($local-ref.lvar init-val))
               ($local-ref.copy iform init-val)
               (pass2/optimize-local-ref iform))
              (else iform))))

(define
  (pass2/eliminate-let iform)
  (let ((vars ($let.lvars iform))
        (inits ($let.inits iform))
        (body ($let.body iform)))
       (for-each pass2/optimize-closure vars inits)
       (let* ((v (pass2/remove-vars vars inits))
              (new-vars (vector-ref v 0))
              (new-inits (vector-ref v 1))
              (removed-inits (vector-ref v 2)))
             (cond ((null? new-vars)
                    (if (null? removed-inits)
                        body
                        ($seq (append removed-inits (list body))
                              ($let.tail? iform))))
                   (else ($let.set-lvars! iform new-vars)
                         ($let.set-inits! iform new-inits)
                         ($let.set-body! iform body)
                         (unless
                           (null? removed-inits)
                           (if (tag? body $SEQ)
                               ($seq.set-body!
                                 body
                                 (append removed-inits ($seq.body body)))
                               ($let.set-body!
                                 iform
                                 ($seq (append removed-inits (list body))
                                       ($let.tail? iform)))))
                         iform)))))

(define
  (iform-copy-zip-lvs orig-lvars lv-alist)
  (let1 new-lvars
        (imap (lambda
                (lv)
                (let1 new-lvar
                      (make-lvar ($lvar.sym lv))
                      ($lvar.set-ref-count!
                        new-lvar
                        ($lvar.ref-count lv))
                      new-lvar))
              orig-lvars)
        (cons new-lvars
              (foldr2 alist-cons lv-alist orig-lvars new-lvars))))

(define
  (iform-copy-lvar lvar lv-alist)
  (cond ((assq lvar lv-alist) => (lambda (p) (cdr p)))
        (else lvar)))

(define
  (iform-copy iform lv-alist)
  (let1 t
        (tag iform)
        (cond ((= $DEFINE t)
               ($define
                 ($define.libname iform)
                 ($define.sym iform)
                 (iform-copy ($define.val iform) lv-alist)))
              ((= $LOCAL-REF t)
               ($local-ref
                 (iform-copy-lvar
                   ($local-ref.lvar iform)
                   lv-alist)))
              ((= $LOCAL-ASSIGN t)
               ($local-assign
                 (iform-copy-lvar
                   ($local-assign.lvar iform)
                   lv-alist)
                 (iform-copy ($local-assign.val iform) lv-alist)))
              ((= $GLOBAL-REF t)
               ($global-ref
                 ($global-ref.libname iform)
                 ($global-ref.sym iform)))
              ((= $GLOBAL-ASSIGN t)
               ($global-assign
                 ($global-assign.libname iform)
                 ($global-assign.sym iform)
                 (iform-copy ($global-assign.val iform) lv-alist)))
              ((= $CONST t) ($const ($const.val iform)))
              ((= $IF t)
               ($if (iform-copy ($if.test iform) lv-alist)
                    (iform-copy ($if.then iform) lv-alist)
                    (iform-copy ($if.else iform) lv-alist)))
              ((= $LET t)
               (let* ((ret (iform-copy-zip-lvs ($let.lvars iform) lv-alist))
                      (newlvs (car ret))
                      (newalist (cdr ret)))
                     ($let ($let.type iform)
                           newlvs
                           (let1 al
                                 (case ($let.type iform)
                                       ((let) lv-alist)
                                       ((rec) newalist))
                                 (imap (lambda (x) (iform-copy x al))
                                       ($let.inits iform)))
                           (iform-copy ($let.body iform) newalist)
                           ($let.tail? iform)
                           ($let.src iform))))
              ((= $LAMBDA t)
               (let* ((ret (iform-copy-zip-lvs
                             ($lambda.lvars iform)
                             lv-alist))
                      (newlvs (car ret))
                      (newalist (cdr ret)))
                     ($lambda
                       ($lambda.src iform)
                       ($lambda.name iform)
                       ($lambda.reqargs iform)
                       ($lambda.optarg iform)
                       newlvs
                       (iform-copy ($lambda.body iform) newalist)
                       ($lambda.flag iform)
                       ($lambda.calls iform))))
              ((= $SEQ t)
               ($seq (imap (lambda (x) (iform-copy x lv-alist))
                           ($seq.body iform))
                     ($seq.tail? iform)))
              ((= $CALL t)
               ($call (iform-copy ($call.proc iform) lv-alist)
                      (imap (lambda (x) (iform-copy x lv-alist))
                            ($call.args iform))
                      #f
                      ($call.type iform)))
              ((= $ASM t)
               ($asm ($asm.insn iform)
                     (imap (lambda (x) (iform-copy x lv-alist))
                           ($asm.args iform))))
              (else iform))))

(define
  (pass2/optimize-closure lvar lambda-node)
  (when (and (zero? ($lvar.set-count lvar))
             (> ($lvar.ref-count lvar) 0)
             (tag? lambda-node $LAMBDA))
        (or (and (= ($lvar.ref-count lvar)
                    (length ($lambda.calls lambda-node)))
                 (let* ((ret (pass2/classify-calls
                               ($lambda.calls lambda-node)
                               lambda-node))
                        (locals (first ret))
                        (recs (second ret))
                        (tail-recs (third ret)))
                       (and (null? recs)
                            (pair? locals)
                            (or (and (null? (cdr locals))
                                     (pass2/local-call-embedder
                                       lvar
                                       lambda-node
                                       (car locals)
                                       tail-recs))
                                (and (null? tail-recs)
                                     (< (iform-count-size-upto
                                          lambda-node
                                          SMALL_LAMBDA_SIZE)
                                        SMALL_LAMBDA_SIZE)
                                     (pass2/local-call-inliner
                                       lvar
                                       lambda-node
                                       locals))))))
            (pass2/local-call-optimizer lvar lambda-node))))

(define-macro
  (sum-items cnt . items)
  (if (null? items)
      cnt
      (let1 target-list?
            (and (pair? (car items))
                 (eq? (caar items) (quote *)))
            (quasiquote
              (let1 s1
                    ((unquote
                       (if target-list? (quote rec-list) (quote rec)))
                     (unquote
                       (if target-list? (cadar items) (car items)))
                     (unquote cnt))
                    (if (>= s1 limit)
                        limit
                        (sum-items s1 (unquote-splicing (cdr items)))))))))

(define
  (iform-count-size-upto iform limit)
  (define
    (rec iform cnt)
    (let1 t
          (tag iform)
          (cond ((= $DEFINE t)
                 (sum-items (+ cnt 1) ($define.val iform)))
                ((= $LOCAL-REF t) (+ cnt 1))
                ((= $GLOBAL-REF t) (+ cnt 1))
                ((= $CONST t) (+ cnt 1))
                ((= $LOCAL-ASSIGN t)
                 (sum-items (+ cnt 1) ($local-assign.val iform)))
                ((= $GLOBAL-ASSIGN t)
                 (sum-items (+ cnt 1) ($global-assign.val iform)))
                ((= $IF t)
                 (sum-items
                   (+ cnt 1)
                   ($if.test iform)
                   ($if.then iform)
                   ($if.else iform)))
                ((= $LET t)
                 (sum-items
                   (+ cnt 1)
                   (* ($let.inits iform))
                   ($let.body iform)))
                ((= $LAMBDA t)
                 (sum-items (+ cnt 1) ($lambda.body iform)))
                ((= $LABEL t)
                 (sum-items cnt ($label.body iform)))
                ((= $SEQ t)
                 (sum-items cnt (* ($seq.body iform))))
                ((= $CALL t)
                 (sum-items
                   (+ cnt 1)
                   ($call.proc iform)
                   (* ($call.args iform))))
                ((= $ASM t)
                 (sum-items (+ cnt 1) (* ($asm.args iform))))
                (else (error "[internal error] iform-count-size-upto: unknown iform tag:"
                             (tag iform))))))
  (define
    (rec-list iform-list cnt)
    (cond ((null? iform-list) cnt)
          ((>= cnt limit) limit)
          (else (rec-list
                  (cdr iform-list)
                  (rec (car iform-list) cnt)))))
  (rec iform 0))

(define
  (adjust-arglist reqargs optarg iargs name)
  (unless
    (argcount-ok? iargs reqargs (> optarg 0))
    (errorf
      "wrong number of arguments: ~a requires ~a, but got ~a at ~a"
      name
      reqargs
      (length iargs)
      (source-info iargs)))
  (if (zero? optarg)
      iargs
      (receive
        (reqs opts)
        (split-at iargs reqargs)
        (append reqs (list ($list opts))))))

(define
  (argcount-ok? args reqargs optarg?)
  (let1 nargs
        (length args)
        (or (and (not optarg?) (= nargs reqargs))
            (and optarg? (>= nargs reqargs)))))

(define
  (pass2/local-call-inliner lvar lambda-node calls)
  (define
    (inline-it call-node lambda-node)
    (let1 inlined
          (pass2/expand-inlined-procedure
            lambda-node
            ($call.args call-node))
          (vector-set! call-node 0 $SEQ)
          (if (tag? inlined $SEQ)
              ($seq.set-body! call-node ($seq.body inlined))
              ($seq.set-body! call-node (list inlined)))))
  ($lvar.set-ref-count! lvar 0)
  ($lambda.set-flag! lambda-node (quote dissolved))
  (let loop
       ((calls calls))
       (cond ((null? (cdr calls))
              (inline-it (car calls) lambda-node))
             (else (inline-it
                     (car calls)
                     (iform-copy lambda-node (quote ())))
                   (loop (cdr calls))))))

(define
  (pass2/local-call-embedder
    lvar
    lambda-node
    call
    rec-calls)
  (let ((reqargs ($lambda.reqargs lambda-node))
        (optarg ($lambda.optarg lambda-node))
        (name ($lambda.name lambda-node)))
       ($call.set-args!
         call
         (adjust-arglist
           reqargs
           optarg
           ($call.args call)
           name))
       ($lvar.ref-count--! lvar)
       ($call.set-type! call (quote embed))
       ($call.set-proc! call lambda-node)
       ($lambda.set-flag! lambda-node (quote dissolved))
       (unless
         (null? rec-calls)
         (let1 body
               ($label ($lambda.body lambda-node))
               ($lambda.set-body! lambda-node body)
               (dolist
                 (jcall rec-calls)
                 ($lvar.ref-count--! lvar)
                 ($call.set-args!
                   jcall
                   (adjust-arglist
                     reqargs
                     optarg
                     ($call.args jcall)
                     name))
                 ($call.set-proc! jcall call)
                 ($call.set-type! jcall (quote jump)))))))

(define
  (pass2/local-call-optimizer lvar lambda-node)
  (let ((reqargs ($lambda.reqargs lambda-node))
        (optarg ($lambda.optarg lambda-node))
        (name ($lambda.name lambda-node))
        (calls ($lambda.calls lambda-node)))
       (dolist
         (call calls)
         ($call.set-args!
           (car call)
           (adjust-arglist
             reqargs
             optarg
             ($call.args (car call))
             name))
         ($call.set-type! (car call) (quote local)))
       ($lambda.set-calls! lambda-node (quote ()))))

(define
  (pass2/classify-calls call&envs lambda-node)
  (define
    (direct-call? env)
    (let loop
         ((env env))
         (cond ((null? env) #t)
               ((eq? (car env) lambda-node) #t)
               ((eq? ($lambda.flag (car env)) (quote dissolved))
                (loop (cdr env)))
               (else #f))))
  (let loop
       ((call&envs call&envs)
        (local (quote ()))
        (rec (quote ()))
        (trec (quote ())))
       (match call&envs
              (() (list local rec trec))
              (((call . env) . more)
               (case ($call.type call)
                     ((tail-rec)
                      (if (direct-call? env)
                          (loop more local rec (cons call trec))
                          (loop more local (cons call rec) trec)))
                     ((rec) (loop more local (cons call rec) trec))
                     (else (loop more (cons call local) rec trec)))))))

(define
  (pass2/remove-vars vars init-iforms)
  (let loop
       ((vars vars)
        (init-iforms init-iforms)
        (rl (quote ()))
        (ri (quote ()))
        (rr (quote ())))
       (cond ((null? vars)
              (quasiquote
                #((unquote (reverse rl))
                  (unquote (reverse ri))
                  (unquote (reverse rr)))))
             ((and (= 0 ($lvar.ref-count (car vars)))
                   (zero? ($lvar.set-count (car vars))))
              (cond ((tag? (car init-iforms) $LOCAL-REF)
                     ($lvar.ref-count--!
                       ($local-ref.lvar (car init-iforms)))))
              (loop (cdr vars)
                    (cdr init-iforms)
                    rl
                    ri
                    (if (memq (tag (car init-iforms))
                              (quasiquote
                                ((unquote $CONST)
                                 (unquote $LOCAL-REF)
                                 (unquote $LAMBDA))))
                        rr
                        (cons (car init-iforms) rr))))
             (else (loop (cdr vars)
                         (cdr init-iforms)
                         (cons (car vars) rl)
                         (cons (car init-iforms) ri)
                         rr)))))

(define
  (pass2/self-recursing? closure closures)
  (memq closure closures))

(define
  (pass2/classify-local-ref-call
    iform
    closures
    tail?)
  (let1 lvar
        ($local-ref.lvar iform)
        (if (> ($lvar.set-count lvar) 0) (quote local))
        (let1 init-val
              ($lvar.init-val lvar)
              (cond ((and init-val (tag? init-val $LAMBDA))
                     (cond ((pass2/self-recursing? init-val closures)
                            (if tail? (quote tail-rec) (quote rec)))
                           ((= ($lvar.ref-count lvar) 1)
                            ($lvar.ref-count--! lvar)
                            ($lvar.set-init-val! lvar (quote ()))
                            init-val)
                           (else (quote local))))
                    (else #f)))))

(define
  (pass2/expand-inlined-procedure iform iargs)
  (let ((lvars ($lambda.lvars iform))
        (args (pass2/adjust-arglist
                ($lambda.reqargs iform)
                ($lambda.optarg iform)
                iargs
                ($lambda.name iform))))
       (for-each
         (lambda (lv a) ($lvar.set-init-val! lv a))
         lvars
         args)
       ($let (quote let)
             lvars
             args
             ($lambda.body iform)
             #f
             #f)))

(define
  (pass2/argcount-ok? args reqargs optarg?)
  (let1 nargs
        (length args)
        (or (and (not optarg?) (= nargs reqargs))
            (and optarg? (>= nargs reqargs)))))

(define
  (pass2/adjust-arglist reqargs optarg iargs name)
  (unless
    (pass2/argcount-ok? iargs reqargs (> optarg 0))
    (errorf
      "wrong number of arguments: ~a requires ~a, but got ~a at ~a"
      name
      reqargs
      (length iargs)
      (source-info iargs)))
  (if (zero? optarg)
      iargs
      (let* ((ret-args (pass2/split-args iargs reqargs))
             (reqs (car ret-args))
             (opts (cdr ret-args)))
            (append reqs (list ($list opts))))))

(define
  (pass2/split-args args reqargs)
  (let loop
       ((i reqargs) (rest args) (r (quote ())))
       (cond ((= i 0) (cons (reverse r) rest))
             ((null? rest)
              (error "given list is too short:" args))
             (else (loop (- i 1) (cdr rest) (cons (car rest) r))))))

(define
  (pass2/collect-call iform closures)
  (cond (($call.type iform) iform)
        (else (let ((proc ($call.proc iform))
                    (args ($call.args iform)))
                   (cond ((tag? proc $LAMBDA)
                          (pass2/optimize
                            (pass2/expand-inlined-procedure proc args)
                            closures))
                         ((and (tag? proc $LOCAL-REF)
                               (pass2/classify-local-ref-call
                                 proc
                                 closures
                                 ($call.tail? iform)))
                          =>
                          (lambda
                            (type)
                            (cond ((vector? type)
                                   ($call.set-proc! iform type)
                                   (let1 o
                                         (pass2/expand-inlined-procedure
                                           type
                                           args)
                                         (pass2/optimize o closures)
                                         o))
                                  ((not type) iform)
                                  (else (let1 lambda-iform
                                              ($lvar.init-val
                                                ($local-ref.lvar proc))
                                              ($call.set-type! iform type)
                                              ($lambda.set-calls!
                                                lambda-iform
                                                (cons (cons iform closures)
                                                      ($lambda.calls
                                                        lambda-iform)))
                                              ($call.set-args!
                                                iform
                                                (imap (lambda
                                                        (x)
                                                        (pass2/optimize
                                                          x
                                                          closures))
                                                      args))
                                              iform)))))
                         (else ($call.set-args!
                                 iform
                                 (imap (lambda (x) (pass2/optimize x closures))
                                       args))
                               iform))))))

;;--------------------------------------------------------------------
;;
;;  Pass3
;;
;;

(define (pass3/exists-in-can-frees? sym can-frees)
  (if (null? can-frees)
      #f
      (if (memq sym (car can-frees))
          #t
          (pass3/exists-in-can-frees? sym (cdr can-frees)))))

;;
;; Find free variables in IForm.
;;   free variables is neither global variable nor local variable.
;;
;;   Arguments
;;     iform:     IForm
;;     locals:    local variables as $lvar structure.
;;     can-frees: candidates of free variables as $lvar structure.
;;
  ;; moved to freeproc.cpp
  ;; N.B. these procedures are still required by vm.scm
  (define (pass3/find-free iform locals can-frees)
    (define (rec i l labels-seen)
      (let1 t (tag i)
        (cond
         [(= $CONST t) '()]
         [(= $LET t)
          (append ($append-map1 (lambda (fm) (rec fm l labels-seen)) ($let.inits i))
                  (rec ($let.body i) ($let.lvars i) labels-seen))]
         [(= $RECEIVE t)
          (append (rec ($receive.vals i) l labels-seen)
                  (rec ($receive.body i) ($receive.lvars i) labels-seen))]
         [(= $SEQ t)
          ($append-map1 (lambda (fm) (rec fm l labels-seen)) ($seq.body i))]
         [(= $LAMBDA t)
          (rec ($lambda.body i) ($lambda.lvars i) labels-seen)]
         [(= $LOCAL-ASSIGN t)
          (let1 sym ($lvar.sym ($local-assign.lvar i))
            (if (pass3/exists-in-can-frees? sym can-frees)
                (cons sym (rec ($local-assign.val i) l labels-seen))
                (rec ($local-assign.val i) l labels-seen)))]
         [(= $LOCAL-REF t)
          (let1 sym ($lvar.sym ($local-ref.lvar i))
            (cond [(memq sym l) '()]
                  [(pass3/exists-in-can-frees? sym can-frees) (list sym)]
                  [else '()]))]
         [(= $GLOBAL-REF t)
          (let* ([sym ($global-ref.sym i)]
                 [found (pass3/exists-in-can-frees? sym can-frees)])
            (if found (list sym) '()))]
         [(= $UNDEF t)      '()]
         [(= $IF t)
          (append (rec ($if.test i) l labels-seen)
                  (append (rec ($if.then i) l labels-seen)
                          (rec ($if.else i) l labels-seen)))]
         [(= $ASM t)
          ($append-map1 (lambda (fm) (rec fm l labels-seen)) ($asm.args i))]
         [(= $DEFINE t)
          (rec ($define.val i) l labels-seen)]
         [(= $CALL t)
          ;; N.B.
          ;; (proc args)
          ;;   args are evaluate before proc, so you should find free variables of args at first.
          (append
           ($append-map1 (lambda (fm) (rec fm l labels-seen)) ($call.args i))
           (rec ($call.proc i) l labels-seen)
           )]
         [(= $CALL-CC t)
          (rec ($call-cc.proc i) l labels-seen)]
         [(= $GLOBAL-ASSIGN t)
          (rec ($global-assign.val i) l labels-seen)]
         [(= $LIST t)
          ($append-map1 (lambda (fm) (rec fm l labels-seen)) ($list.args i))]
         [(= $LABEL t)
          (if (memq i labels-seen)
              '()
              (rec ($label.body i) l (cons i labels-seen)))]
;;          [(= $IMPORT t)
;;           '() ;; todo 本当?
;;           ]
;;          [(= $LIBRARY t)
;;           '() ;; todo 本当?
;;           ]
         [(= $IT t) '()]
         [else
          (error "pass3/find-free unknown iform:" (tag i))])))
    (uniq (rec iform locals '())))

  ;; moved to freeproc.cpp
  ;; N.B. these procedures are still required by vm.scm
  (define (pass3/find-sets iform lvars)
    (define (rec i)
      (let1 t (tag i)
        (cond
         [(= $CONST t) '()]
         [(= $LET t)
          (append ($append-map1 rec ($let.inits i))
                  (rec ($let.body i)))]
         [(= $RECEIVE t)
          (append (rec ($receive.vals i))
                  (rec ($receive.body i)))]
         [(= $SEQ t)
          ($append-map1 rec ($seq.body i))]
         [(= $LAMBDA t)
          (rec ($lambda.body i))]
         [(= $LOCAL-ASSIGN t)
          (let1 lvar ($local-assign.lvar i)
            (append (if (memq lvar lvars) (list lvar) '())
                    (rec ($local-assign.val i))))]
         [(= $LOCAL-REF t)  '()]
         [(= $GLOBAL-REF t) '()]
         [(= $UNDEF t)      '()]
         [(= $IF t)
          (append (rec ($if.test i))
                  (rec ($if.then i))
                  (rec ($if.else i)))]
         [(= $ASM t)
          ($append-map1 rec ($asm.args i))]
         [(= $DEFINE t)
          (rec ($define.val i))]
         [(= $CALL t)
          (append
           ($append-map1 rec ($call.args i))
           (rec ($call.proc i))
           )]
         [(= $CALL-CC t)
          (rec ($call-cc.proc i))]
         [(= $GLOBAL-ASSIGN t)
          (rec ($global-assign.val i))]
         [(= $LIST t)
          ($append-map1 rec ($list.args i))]
         [(= $LABEL t)
          '() ;; todo 本当
          ]
;;          [(= $IMPORT t)
;;           '() ;; todo 本当?
;;           ]
;;          [(= $LIBRARY t)
;;           '() ;; todo 本当?
;;           ]
         [(= $IT t) '()]
         [else
          (error "pass3/find-sets unknown iform:" i)])))
    (uniq (rec iform)))
  (define (make-array)
    (list 'array (make-vector 2) 0))

  (define (array? obj)
    (eq? 'array (car obj)))

  (define (array-length array)
    (caddr array))

  (define (vector-copy dst src length)
    (do ((i 0 (+ i 1))) ((>= i length) #f)
      (vector-set! dst i (vector-ref src i))))

  (define (set-array-length! array length)
    (set! (caddr array) length)
    (when (>= length (vector-length (array-data array)))
      (let1 next-data (make-vector (* length 2))
        (vector-copy next-data (array-data array) length)
        (set! (cadr array) next-data))))

  (define (array-data array)
    (cadr array))

  (define (array-push! array obj)
    (let* ([data (array-data array)]
           [length (array-length array)])
      (vector-set! data length obj)
      (set-array-length! array (+ length 1))))

  (define (array->list array)
    (let ([data (array-data array)]
          [length (array-length array)])
      (let loop ([i 0]
                 [ret '()])
        (if (>= i length)
            (reverse ret)
            (loop (+ i 1) (cons (vector-ref data i) ret))))))

  ;; moved to freeproc.cpp start
  ;; N.B. these procedures are still required by vm.scm
  (define (make-code-builder)
    (make-array))

  (define (code-builder-put-extra1! cb x)
    (array-push! cb x))

  (define (code-builder-put-extra2! cb a b)
    (array-push! cb a)
    (array-push! cb b)
    )


  (define (code-builder-put-extra3! cb a b c)
    (array-push! cb a)
    (array-push! cb b)
    (array-push! cb c)
    )

  (define (code-builder-put-extra4! cb a b c d)
    (array-push! cb a)
    (array-push! cb b)
    (array-push! cb c)
    (array-push! cb d)
    )

  (define (code-builder-put-extra5! cb a b c d e)
    (array-push! cb a)
    (array-push! cb b)
    (array-push! cb c)
    (array-push! cb d)
    (array-push! cb e)
    )

  (define (code-builder-append! cb1 cb2)
    (let loop ([e (array->list cb2)])
      (cond
       [(null? e)
        '()]
       [else
        (code-builder-put-extra1! cb1 (car e))
        (loop (cdr e))])))

  (define (code-builder-emit cb)
    (array->list cb))

  (define code-builder-put-insn-arg1! code-builder-put-extra2!)
  (define code-builder-put-insn-arg0! code-builder-put-extra1!)
  ;; moved to freeproc.cpp end

;; code-builder synonym
(define-macro (cput! cb . more)
  (match more
    [() '()]
    [(a b c d e . f)
     `(begin (code-builder-put-extra5! ,cb ,a ,b ,c ,d ,e)
             (cput! ,cb ,@f))]
    [(a b c d . e)
     `(begin (code-builder-put-extra4! ,cb ,a ,b ,c ,d)
             (cput! ,cb ,@e))]
    [(a b c . d)
     `(begin (code-builder-put-extra3! ,cb ,a ,b ,c)
             (cput! ,cb ,@d))]
    [(a b . c)
     `(begin (code-builder-put-extra2! ,cb ,a ,b)
             (cput! ,cb ,@c))]
    [(a . b)
     `(begin (code-builder-put-extra1! ,cb ,a)
             (cput! ,cb ,@b))]))

(define-macro (cput-shift! cb n m)
  `(when (> ,m 0)
    (cput! ,cb 'SHIFT ,n ,m)))

(define-macro (pass3/add-sets! sets new-sets)
  `(if (null? ,new-sets)
       ,sets
       (hashtable-set-true! (eq-hashtable-copy ,sets) ,new-sets)))

(define-macro (pass3/let-frame-size) 2)
(define-macro (pass3/frame-size) 4)

(define (pass3/collect-free cb frees-here locals frees)
  (let loop ([size 0]
             [reversed-frees (reverse frees-here)])
    (cond
     [(null? reversed-frees) size]
     [else
      (let1 stack-size (pass3/compile-refer cb (car reversed-frees) locals frees)
        (code-builder-put-insn-arg0! cb 'PUSH)
        (loop (+ size stack-size) (cdr reversed-frees)))])))

(define (pass3/symbol-lookup cb lvar locals frees return-local return-free)
  (let next-local ([locals locals] [n 0])
    (if (null? locals)
        (let next-free ([free frees] [n 0])
          (cond [(null? free)
                 (error "pass3/symbol-lookup bug? Unknown lvar:" lvar)]
                [(eq? (car free) lvar)
                 (return-free cb n)]
                [else
                 (next-free (cdr free) (+ n 1))]))
        (if (eq? (car locals) lvar)
            (return-local cb n)
            (next-local (cdr locals) (+ n 1))))))

;; N.B. Do NOT use anonymous closure for this usage. Because symbol-lookup will be called many times.
;; moved to CompilerProcedures.cpp
(define (pass3/return-refer-local cb n)
  (code-builder-put-insn-arg1! cb 'REFER_LOCAL n)
  0)

(define (pass3/return-refer-free cb n)
  (code-builder-put-insn-arg1! cb 'REFER_FREE n)
  0)

;; moved to CompilerProcedures.cpp
;; N.B. this procedure is still required by vm.scm
(define (pass3/compile-refer cb lvar locals frees)
  (pass3/symbol-lookup cb lvar locals frees pass3/return-refer-local pass3/return-refer-free))

(define (pass3/return-assign-local cb n)
  (code-builder-put-insn-arg1! cb 'ASSIGN_LOCAL n)
  0)

(define (pass3/return-assign-free cb n)
  (code-builder-put-insn-arg1! cb 'ASSIGN_FREE n)
  0)

(define (pass3/compile-assign cb lvar locals frees)
  (pass3/symbol-lookup cb lvar locals frees pass3/return-assign-local pass3/return-assign-free))

(define (pass3/make-boxes cb sets vars)
  ($for-each1-with-rindex (lambda (index var)
                            (if (memq var sets)
                                (code-builder-put-insn-arg1! cb 'BOX index)))
                          vars))

(define pass3/dispatch-table (make-vector $INSN-NUM))

(define (pass3/register insn proc)
  (vector-set! pass3/dispatch-table insn proc))

(define (pass3/$const cb iform locals frees can-frees sets tail depth)
  (code-builder-put-insn-arg1! cb 'CONSTANT ($const.val iform))
  0)

(define (pass3/$it cb iform locals frees can-frees sets tail depth) 0)

(define (pass3/$list cb iform locals frees can-frees sets tail depth)
  (let1 args ($list.args iform)
    (begin0
      (fold (lambda (i accum)
              (let1 size (pass3/rec cb i locals frees can-frees sets tail depth)
                (code-builder-put-insn-arg0! cb 'PUSH)
                (+ size accum))) 0 args)
      (code-builder-put-insn-arg1! cb 'LIST (length args)))))

;; $local-lef is classified into REFER_LOCAL and REFER_FREE
(define (pass3/$local-ref cb iform locals frees can-frees sets tail depth)
  (pass3/compile-refer cb ($lvar.sym ($local-ref.lvar iform)) locals frees)
  (when (hashtable-ref sets ($local-ref.lvar iform) #f)
    (code-builder-put-insn-arg0! cb 'INDIRECT))
  0)

;; $local-assign is classified into ASSIGN_LOCAL and ASSIGN_FREE
(define (pass3/$local-assign cb iform locals frees can-frees sets tail depth)
  (let ([val-stack-size (pass3/rec cb ($local-assign.val iform) locals frees can-frees sets #f depth)]
        [var-stack-size (pass3/compile-assign cb ($lvar.sym ($local-assign.lvar iform)) locals frees)])
    (+ val-stack-size var-stack-size)))

(define top-level-sym (string->symbol "top-level-"))

(define (merge-libname-sym libname sym)
  (string->symbol
   (string-append (symbol->string libname)
                  ":$:"
                  (symbol->string sym))))

;; $global-lef is classified into REFER_GLOBAL and REFER_FREE
(define (pass3/$global-ref cb iform locals frees can-frees sets tail depth)
  (let1 sym ($global-ref.sym iform)
    (let next-free ([free frees] [n 0])
      (cond [(null? free)
             (code-builder-put-insn-arg1! cb 'REFER_GLOBAL (merge-libname-sym ($global-ref.libname iform) sym))
             0]
            [(eq? (car free) sym)
             (code-builder-put-insn-arg1! cb 'REFER_FREE n)
             0]
            [else
             (next-free (cdr free) (+ n 1))]))))

(define (pass3/$global-assign cb iform locals frees can-frees sets tail depth)
  (let1 sym ($global-assign.sym iform)
    (let next-free ([free frees] [n 0])
      (cond
       [(null? free)
        (begin0
          (pass3/rec cb ($global-assign.val iform) locals frees can-frees sets #f depth)
          (code-builder-put-insn-arg1! cb
                 'ASSIGN_GLOBAL
                 (merge-libname-sym ($global-assign.libname iform) sym)))]
       [(eq? (car free) sym)
        (begin0
         (pass3/rec cb ($global-assign.val iform) locals frees can-frees sets #f depth)
         (code-builder-put-insn-arg1! cb 'ASSIGN_FREE n))]
       [else
        (next-free (cdr free) (+ n 1))]))))

(define (pass3/$seq cb iform locals frees can-frees sets tail depth)
  (let loop ([form ($seq.body iform)]
             [size 0])
    (cond
     [(null? form) size]
     [else
      (let1 tail? (if (null? (cdr form)) tail #f)
        (loop (cdr form)
              (+ size (pass3/rec cb (car form) locals frees can-frees sets tail? depth))))])))

(define (pass3/$undef cb iform locals frees can-frees sets tail depth)
  (code-builder-put-insn-arg0! cb 'UNDEF)
  0)

(define (pass3/$asm-1-arg cb insn arg1 locals frees can-frees sets depth)
  (begin0
    (pass3/rec cb arg1 locals frees can-frees sets #f depth)
    (code-builder-put-insn-arg0! cb insn)))

(define (pass3/$asm-2-arg cb insn arg1 arg2 locals frees can-frees sets depth)
    (let ([x (pass3/compile-arg cb arg1 locals frees can-frees sets #f depth)]
          [y (pass3/rec cb arg2 locals frees can-frees sets #f depth)])
      (code-builder-put-insn-arg0! cb insn)
      (+ x y)))

(define (pass3/$asm-3-arg cb insn arg1 arg2 arg3 locals frees can-frees sets depth)
  (let ([x (pass3/compile-arg cb arg1 locals frees can-frees sets #f depth)]
        [y (pass3/compile-arg cb arg2 locals frees can-frees sets #f depth)]
        [z (pass3/rec cb arg3 locals frees can-frees sets #f depth)])
    (code-builder-put-insn-arg0! cb insn)
    (+ x y z)))

(define (pass3/$asm-n-args cb args locals frees can-frees sets depth)
  (let loop ([args args]
             [stack-size 0])
    (cond
     [(null? args) stack-size]
     [(null? (cdr args)) ;; last argument is not pushed.
      (+ stack-size (pass3/rec cb (car args) locals frees can-frees sets #f depth))]
     [else
      (loop (cdr args)
            (+ stack-size (pass3/compile-arg cb (car args) locals frees can-frees sets #f depth)))])))

(define (pass3/$asm cb iform locals frees can-frees sets tail depth)
  (let1 args ($asm.args iform)
    (case ($asm.insn iform)
      [(APPEND2)           (pass3/$asm-2-arg cb  'APPEND2         (first args) (second args) locals frees can-frees sets depth)]
      [(NUMBER_ADD)        (pass3/$asm-2-arg cb  'NUMBER_ADD      (first args) (second args) locals frees can-frees sets depth)]
      [(NUMBER_SUB)        (pass3/$asm-2-arg cb  'NUMBER_SUB      (first args) (second args) locals frees can-frees sets depth)]
      [(NUMBER_MUL)        (pass3/$asm-2-arg cb  'NUMBER_MUL      (first args) (second args) locals frees can-frees sets depth)]
      [(NUMBER_DIV)        (pass3/$asm-2-arg cb  'NUMBER_DIV      (first args) (second args) locals frees can-frees sets depth)]
      [(NUMBER_EQUAL)      (pass3/$asm-2-arg cb  'NUMBER_EQUAL    (first args) (second args) locals frees can-frees sets depth)]
      [(NUMBER_GE)         (pass3/$asm-2-arg cb  'NUMBER_GE       (first args) (second args) locals frees can-frees sets depth)]
      [(NUMBER_GT)         (pass3/$asm-2-arg cb  'NUMBER_GT       (first args) (second args) locals frees can-frees sets depth)]
      [(NUMBER_LT)         (pass3/$asm-2-arg cb  'NUMBER_LT       (first args) (second args) locals frees can-frees sets depth)]
      [(NUMBER_LE)         (pass3/$asm-2-arg cb  'NUMBER_LE       (first args) (second args) locals frees can-frees sets depth)]
      [(CONS)              (pass3/$asm-2-arg cb  'CONS            (first args) (second args) locals frees can-frees sets depth)]
      [(CAR)               (pass3/$asm-1-arg cb   'CAR             (first args) locals frees can-frees sets depth)]
      [(CDR)               (pass3/$asm-1-arg cb   'CDR             (first args) locals frees can-frees sets depth)]
      [(CAAR)              (pass3/$asm-1-arg cb   'CAAR            (first args) locals frees can-frees sets depth)]
      [(CADR)              (pass3/$asm-1-arg cb   'CADR            (first args) locals frees can-frees sets depth)]
      [(CDAR)              (pass3/$asm-1-arg cb   'CDAR            (first args) locals frees can-frees sets depth)]
      [(CDDR)              (pass3/$asm-1-arg cb   'CDDR            (first args) locals frees can-frees sets depth)]
      [(SET_CDR)           (pass3/$asm-2-arg cb  'SET_CDR         (first args) (second args) locals frees can-frees sets depth)]
      [(SET_CAR)           (pass3/$asm-2-arg cb  'SET_CAR         (first args) (second args) locals frees can-frees sets depth)]
      [(MAKE_VECTOR)       (pass3/$asm-2-arg cb  'MAKE_VECTOR     (first args) (second args) locals frees can-frees sets depth)]
      [(VECTOR_LENGTH)     (pass3/$asm-1-arg cb   'VECTOR_LENGTH   (first args)locals frees can-frees sets depth)]
      [(VECTOR_SET)        (pass3/$asm-3-arg cb 'VECTOR_SET      (first args) (second args) (third args) locals frees can-frees sets depth)]
      [(VECTOR_REF)        (pass3/$asm-2-arg cb  'VECTOR_REF      (first args) (second args) locals frees can-frees sets depth)]
      [(EQ)                (pass3/$asm-2-arg cb  'EQ              (first args) (second args) locals frees can-frees sets depth)]
      [(EQV)               (pass3/$asm-2-arg cb  'EQV             (first args) (second args) locals frees can-frees sets depth)]
      [(EQUAL)             (pass3/$asm-2-arg cb  'EQUAL           (first args) (second args) locals frees can-frees sets depth)]
      [(PAIR_P)            (pass3/$asm-1-arg cb   'PAIR_P          (first args) locals frees can-frees sets depth)]
      [(NULL_P)            (pass3/$asm-1-arg cb   'NULL_P          (first args) locals frees can-frees sets depth)]
      [(SYMBOL_P)          (pass3/$asm-1-arg cb   'SYMBOL_P        (first args) locals frees can-frees sets depth)]
      [(VECTOR_P)          (pass3/$asm-1-arg cb   'VECTOR_P        (first args) locals frees can-frees sets depth)]
      [(NOT)               (pass3/$asm-1-arg cb   'NOT             (first args) locals frees can-frees sets depth)]
      [(OPEN_INPUT_FILE)   (pass3/$asm-1-arg cb   'OPEN_INPUT_FILE (first args) locals frees can-frees sets depth)]
      [(READ)              (pass3/$asm-1-arg cb   'READ            (first args) locals frees can-frees sets depth)]
      [(READ_CHAR)         (pass3/$asm-1-arg cb   'READ_CHAR       (first args) locals frees can-frees sets depth)]
      [(VALUES)
       (begin0
         (pass3/$asm-n-args cb args locals frees can-frees sets depth)
         (code-builder-put-insn-arg1! cb 'VALUES (length args)))]
      [(APPLY)
       (let1 end-of-frame (make-label)
         (code-builder-put-insn-arg1! cb 'FRAME (ref-label end-of-frame))
         (let1 arg2-size (pass3/rec cb (second args) locals frees can-frees sets #f depth)
           (code-builder-put-insn-arg0! cb 'PUSH)
           (let1 arg1-size (pass3/rec cb (first args) locals frees can-frees sets #f depth)
             (cput! cb 'APPLY end-of-frame)
             (+ arg1-size arg2-size))))]
      [else
       (error "unknown insn on pass3/$asm")])))

(define (pass3/$if cb iform locals frees can-frees sets tail depth)
  (let ([end-of-else   (make-label)]
        [begin-of-else (make-label)])
    (let1 test-size (pass3/rec cb ($if.test iform) locals frees can-frees sets #f depth)
      (code-builder-put-insn-arg1! cb 'TEST (ref-label begin-of-else))
      (let1 then-size (pass3/rec cb ($if.then iform) locals frees can-frees sets tail depth)
        (cput! cb
               'UNFIXED_JUMP
               (ref-label end-of-else)
               begin-of-else)
        (let1 else-size (pass3/rec cb ($if.else iform) locals frees can-frees sets tail depth)
          (cput! cb end-of-else)
          (+ test-size then-size else-size))))))

(define (pass3/$define cb iform locals frees can-frees sets tail depth)
  (begin0
    (pass3/rec cb ($define.val iform) locals frees can-frees sets #f depth)
    (cput! cb 'DEFINE_GLOBAL (merge-libname-sym ($define.libname iform)
                                                ($define.sym iform)))))

(define (pass3/compile-arg cb arg locals frees can-frees sets tail depth)
  (let1 size (pass3/rec cb arg locals frees can-frees sets #f depth)
    (code-builder-put-insn-arg0! cb 'PUSH)
    (+ size 1)))

;; fold requires anonymous closure
;; So, if this procedure is called many times, it causes slow compilation.
(define (pass3/compile-args cb args locals frees can-frees sets tail depth)
  (let loop ([size 0]
             [iform args])
    (cond
     [(null? iform) size]
     [else
      (loop (+ size (pass3/compile-arg cb (car iform) locals frees can-frees sets tail depth))
            (cdr iform))])))

;; N.B.
;; We don't append vars directory.
;; If vars's length is very long, it causes very slow compilations.
;; So we append the referrence of vars instread.
;; can-frees may be like following.
;; '((a b c) (x y) (i j))
(define-macro (pass3/add-can-frees1 can-frees vars)
  `(append ,can-frees (list ,vars)))

(define-macro (pass3/add-can-frees2 can-frees vars1 vars2)
  `(append (append ,can-frees (list ,vars1)) (list ,vars2)))

(define (pass3/$call cb iform locals frees can-frees sets tail depth)
  (case ($call.type iform)
    [(jump)
     (let ([label ($lambda.body ($call.proc ($call.proc iform)))]
           [args-length (length ($call.args iform))])
       (begin0
         ;; This refers local variables at stack, so we do this first before emitting SHIFTJ.
         (pass3/compile-args cb ($call.args iform) locals frees can-frees sets #f depth)
         ;;
         ;; Named let jump optimization needs to control stack like following.
         ;;
         ;;   let loop (var val) [jump destination] [... body ...] [jump point]
         ;;
         ;;   In [... body ...] we may have let or lambda, these expressions push arguments and frames to stack.
         ;;   So if we jump across the let or lambda boundary, we have to cleanup unnecessary arguments from stack.
         ;;   "depth" variable is used for this cleaning up.
         ;;   Just before the jump point, stack may be like following.
         ;;
         ;;     [first N values for loop]                <=== cleanup
         ;;     [M arguments and frames pushed in body]  <=== cleanup
         ;;     [next K values for loop]
         ;;
         ;;   We cleanup M + N objects in stack and shift.
         ;;
         ;;   Then we restore fp and display registers, and finally jump to [jump destination]
         ;;
;       (format #t "jump depth=~a ($call.depth iform)=~a ~a\n" depth ($call.depth iform) ($call.depth ($call.proc iform)))
         (cput! cb 'SHIFTJ args-length (- depth ($call.depth ($call.proc iform))))
         (cput! cb 'UNFIXED_JUMP label)))]
    [(embed)
     (let* ([label ($lambda.body ($call.proc iform))]
            [body ($label.body label)]
            [vars ($lambda.lvars ($call.proc iform))]
            [vars-sym (imap $lvar.sym-proc vars)]
            [frees-here (pass3/find-free body
                                         vars-sym
                                         (pass3/add-can-frees2 can-frees locals frees))]
            [sets-for-this-lvars (pass3/find-sets body vars)]
            [let-cb (make-code-builder)])
;       (format #t "embeded depth=~a\n" depth)
       ($call.set-depth! iform depth) ;; record depth at jump destination point.
       (cput! cb 'LET_FRAME)
       (let* ([frees-here-length (length frees-here)]
              [free-size (if (> frees-here-length 0)
                             (pass3/collect-free let-cb frees-here locals frees)
                             0)])
         (when (> frees-here-length 0)
           (cput! let-cb 'DISPLAY frees-here-length))
         (let ([args-size (pass3/compile-args let-cb ($call.args iform) locals frees-here can-frees sets #f depth)]
               [args-length (length ($call.args iform))])
           (pass3/make-boxes let-cb sets-for-this-lvars vars)
           (code-builder-put-insn-arg1! let-cb 'ENTER args-length)
           (cput! let-cb label)
           (let1 body-size (pass3/rec let-cb
                                      body
                                      vars-sym
                                      frees-here
                                      (pass3/add-can-frees1 can-frees vars-sym)
                                      (pass3/add-sets! sets sets-for-this-lvars)
                                      (if tail (+ tail (length vars) (pass3/let-frame-size)) #f)
                                      (+ depth (length vars))); (if tail (pass3/let-frame-size) 0)))
             (code-builder-put-insn-arg1! let-cb 'LEAVE args-length)
             (cput! cb (+ args-size body-size free-size))
             (code-builder-append! cb let-cb)
             (+ args-size body-size free-size)))))]
    [else
     (let1 end-of-frame (make-label)
       ;;
       ;; How tail context call be optimized.
       ;;
       ;;   On ((lambda () (a 3))), (a 3) is tail call.
       ;;   Normally, after this call, VM jmp to saved continuation (code, ip, sp) with (RETURN n) instruction.
       ;;   This continuation is saved by FRAME instruction before applying (a 3).
       ;;   Because (a 3) is tail call, continuation of (a 3) is exactly equal to continuation of ((lambda () ...)).
       ;;   So we don't have to execute FRAME, instead we can use FRAME informtion which is saved before applying ((lambda () ...)).
       ;;   To access the FRAME informtion, we remove arguments for a, so we do this SHIFT.
       ;;
       (unless tail
         (code-builder-put-insn-arg1! cb 'FRAME (ref-label end-of-frame)))
       (let* ([args-size (pass3/compile-args cb ($call.args iform) locals frees can-frees sets #f depth)]
              [proc-size (pass3/rec cb ($call.proc iform) locals frees can-frees sets #f depth)]
              [args-length (length ($call.args iform))])
         (when tail
           (cput-shift! cb args-length tail))
         (code-builder-put-insn-arg1! cb 'CALL args-length)
         (unless tail
           (cput! cb end-of-frame))
         (+ args-size proc-size)))]))

(define (pass3/$call-cc cb iform locals frees can-frees sets tail depth)
  (let1 end-of-frame (make-label)
    (unless tail
      (code-builder-put-insn-arg1! cb 'FRAME (ref-label end-of-frame)))
    (cput! cb 'MAKE_CONTINUATION (if tail 1 0))
    (code-builder-put-insn-arg0! cb 'PUSH)
    (begin0
      (pass3/rec cb ($call-cc.proc iform) locals frees can-frees sets #f depth)
      (when tail
        (cput-shift! cb 1 tail))
      (code-builder-put-insn-arg1! cb 'CALL 1)
      (unless tail
        (cput! cb end-of-frame)))))

(define (pass3/$lambda cb iform locals frees can-frees sets tail depth)
  (let* ([vars ($lambda.lvars iform)]
         [vars-sym (imap $lvar.sym-proc vars)]
         [body ($lambda.body iform)]
         [frees-here (pass3/find-free body
                                      vars
                                      (pass3/add-can-frees2 can-frees locals frees))]
         [sets-for-this-lvars (pass3/find-sets body vars)]
         [end-of-closure (make-label)]
         [lambda-cb (make-code-builder)]
         [frees-here-length (length frees-here)]
         [free-size (if (> frees-here-length 0)
                        (pass3/collect-free cb frees-here locals frees)
                        0)]
         [vars-length (length vars)])
    (cput! cb
           'CLOSURE
           (ref-label end-of-closure)
           vars-length                                              ;; length of arguments
           (> ($lambda.optarg iform) 0)                             ;; optional-arg?
           frees-here-length)                                       ;; number of free variables
      ;; we want to know stack size of lambda body, before emit.
      (let1 body-size (pass3/rec lambda-cb
                                 body
                                 vars-sym
                                 frees-here
                                 (pass3/add-can-frees1 can-frees vars-sym) ;; can-frees and vars don't have common lvars.
                                 (pass3/add-sets! sets sets-for-this-lvars)
                                 vars-length
                                 (+ (length vars) (pass3/frame-size) depth))
        (cput! cb
               (+ body-size free-size vars-length 4) ;; max-stack 4 is sizeof frame
               ($lambda.src iform))                    ;; source code information
        (pass3/make-boxes cb sets-for-this-lvars vars)
        (code-builder-append! cb lambda-cb)
        (code-builder-put-insn-arg1! cb 'RETURN vars-length)
        (cput! cb end-of-closure)
        0)))

(define (pass3/$receive cb iform locals frees can-frees sets tail depth)
  (let* ([vars ($receive.lvars iform)]
         [vars-sym (imap $lvar.sym-proc vars)]
         [body ($receive.body iform)]
         [frees-here (append
                      (pass3/find-free ($receive.vals iform) locals (pass3/add-can-frees2 can-frees locals frees))
                      (pass3/find-free body
                                       vars-sym
                                       (pass3/add-can-frees2 can-frees locals frees)))]
         [sets-for-this-lvars (pass3/find-sets body vars)]
         [let-cb (make-code-builder)])
    (cput! cb 'LET_FRAME)
    (let* ([frees-here-length (length frees-here)]
           [free-size (if (> frees-here-length 0)
                          (pass3/collect-free let-cb frees-here locals frees)
                          0)])
      (when (> frees-here-length 0)
        (cput! let-cb 'DISPLAY frees-here-length))
      (let ([vals-size (pass3/rec let-cb ($receive.vals iform) locals frees-here can-frees sets #f depth)]
            [vars-length (length vars)])
        (cput! let-cb 'RECEIVE ($receive.reqargs iform) ($receive.optarg  iform))
        (pass3/make-boxes let-cb sets-for-this-lvars vars)
        (code-builder-put-insn-arg1! let-cb 'ENTER vars-length)
        (let1 body-size (pass3/rec let-cb
                                   body
                                   vars-sym
                                   frees-here
                                   (pass3/add-can-frees1 can-frees vars-sym)
                                   (pass3/add-sets! sets sets-for-this-lvars)
                                   (if tail (+ tail vars-length (pass3/let-frame-size)) #f)
                                   (+ depth vars-length (pass3/let-frame-size)))
          (code-builder-put-insn-arg1! let-cb 'LEAVE vars-length)
          (cput! cb (+ body-size vals-size free-size))
          (code-builder-append! cb let-cb)
          (+ body-size vals-size free-size))))))

(define (pass3/$let cb iform locals frees can-frees sets tail depth)
  (if (eq? ($let.type iform) 'rec)
      (pass3/letrec cb iform locals frees can-frees sets tail depth)
      (let* ([vars ($let.lvars iform)]
             [vars-sym (imap $lvar.sym-proc vars)]
             [body ($let.body iform)]
             [frees-here (append
                          ($append-map1 (lambda (i) (pass3/find-free i locals (pass3/add-can-frees2 can-frees frees locals))) ($let.inits iform))
                          (pass3/find-free body
                                           vars-sym
                                           (pass3/add-can-frees2 can-frees frees locals)))]
             [sets-for-this-lvars (pass3/find-sets body vars)]
             [frees-here-length   (length frees-here)]
             [vars-length         (length vars)]
             [let-cb (make-code-builder)])
        (cput! cb 'LET_FRAME)
        (let1 free-size (if (> frees-here-length 0) (pass3/collect-free let-cb frees-here locals frees) 0)
          (when (> frees-here-length 0)
            (cput! let-cb 'DISPLAY frees-here-length))
          (let1 args-size (pass3/compile-args let-cb ($let.inits iform) locals frees-here can-frees sets tail depth)
            (pass3/make-boxes let-cb sets-for-this-lvars vars)
            (code-builder-put-insn-arg1! let-cb 'ENTER vars-length)
            (let1 body-size (pass3/rec let-cb
                                       body
                                       vars-sym
                                       frees-here
                                       (pass3/add-can-frees1 can-frees vars-sym)
                                       (pass3/add-sets! sets sets-for-this-lvars)
                                       (if tail (+ tail vars-length (pass3/let-frame-size)) #f)
                                       (+ depth vars-length (pass3/let-frame-size)))
              (code-builder-put-insn-arg1! let-cb 'LEAVE vars-length)
              (cput! cb (+ body-size args-size free-size))
              (code-builder-append! cb let-cb)
              (+ body-size args-size free-size)))))))

(define (raise-compile-error cb who message irritants)
  (cput! cb 'COMPILE_ERROR who message irritants))

(define (pass3/letrec cb iform locals frees can-frees sets tail depth)
  (let* ([vars ($let.lvars iform)]
         [vars-sym (imap $lvar.sym-proc vars)]
         [body ($let.body iform)]
         [frees-here (append
                      ($append-map1 (lambda (i) (pass3/find-free i vars
(pass3/add-can-frees2 can-frees locals frees))) ($let.inits iform))
                      (pass3/find-free body
                                       vars-sym
                                       (pass3/add-can-frees2 can-frees locals frees)))]
         ;; each vars can be set!
         [sets-for-this-lvars  (append vars (pass3/find-sets body vars) ($append-map1 (lambda (i) (pass3/find-sets i vars)) ($let.inits iform)))]
         [args ($let.inits iform)]
         [frees-here-length (length frees-here)]
         [vars-length (length vars)]
         [let-cb (make-code-builder)])
    (when ($let.error iform)
      (raise-compile-error cb (first ($let.error iform))
                              (second ($let.error iform))
                              (third ($let.error iform))))
    (cput! cb 'LET_FRAME)
    (let1 free-size (if (> frees-here-length 0) (pass3/collect-free let-cb frees-here locals frees) 0)
      (when (> frees-here-length 0)
        (cput! let-cb 'DISPLAY frees-here-length))
      (let loop ([args args]) ;; init code
        (cond
         [(null? args) '()]
         [else
          (cput! let-cb 'UNDEF)
          (code-builder-put-insn-arg0! let-cb 'PUSH)
          (loop (cdr args))]))
      (pass3/make-boxes let-cb sets-for-this-lvars vars)
      (code-builder-put-insn-arg1! let-cb 'ENTER vars-length)
      (let* ([new-can-frees (pass3/add-can-frees1 can-frees vars-sym)]
             [assign-size
              (let loop ([args  args]
                         [size  0]
                         [index 0])
                (cond
                 [(null? args) size]
                 [else
                  (let1 stack-size (pass3/rec let-cb (car args) vars-sym frees-here
                                              new-can-frees
                                              (pass3/add-sets! sets sets-for-this-lvars)
                                              #f
                                              depth)
                    (code-builder-put-insn-arg1! let-cb 'ASSIGN_LOCAL index)
                    (loop (cdr args)
                          (+ stack-size size)
                          (+ index 1)))]))])
             (let1 body-size (pass3/rec let-cb
                                        body
                                        vars-sym
                                        frees-here
                                        new-can-frees
                                        (pass3/add-sets! sets sets-for-this-lvars)
                                        (if tail (+ tail vars-length (pass3/let-frame-size)) #f)
                                        (+ depth vars-length (pass3/let-frame-size)))
          (code-builder-put-insn-arg1! let-cb 'LEAVE vars-length)
          (cput! cb (+ free-size assign-size body-size))
          (code-builder-append! cb let-cb)
          (+ free-size assign-size body-size))))))

;; (define (pass3/$import cb iform locals frees can-frees sets tail)
;;   (define (rec form)
;;     (for-each
;;      (lambda (s)
;;        (let* ([libname      ($import-spec.libname s)]
;;               [lib          (hashtable-ref libraries libname)]
;;               [end-of-frame (make-label)])
;;          (rec ($library.import lib))
;;          (code-builder-put-insn-arg1! cb 'FRAME  ;; We execute (RETURN 0) in library body
;;                                       (ref-label end-of-frame))
;;          (cput! cb
;;                 'IMPORT
;;                 libname
;;                 end-of-frame)))
;;      ($import.import-specs form))
;;     0)
;;   (rec iform))

(define (pass3/$library cb iform locals frees can-frees sets tail depth)
  (cput! cb 'LIBRARY ($library.name iform) iform)
  0)

(pass3/register $CONST         pass3/$const)
(pass3/register $LAMBDA        pass3/$lambda)
(pass3/register $LOCAL-REF     pass3/$local-ref)
(pass3/register $LOCAL-ASSIGN  pass3/$local-assign)
(pass3/register $GLOBAL-ASSIGN pass3/$global-assign)
(pass3/register $GLOBAL-REF    pass3/$global-ref)
(pass3/register $SEQ           pass3/$seq)
(pass3/register $UNDEF         pass3/$undef)
(pass3/register $IF            pass3/$if)
(pass3/register $ASM           pass3/$asm)
(pass3/register $DEFINE        pass3/$define)
(pass3/register $CALL          pass3/$call)
(pass3/register $CALL-CC       pass3/$call-cc)
(pass3/register $LET           pass3/$let)
(pass3/register $LIST          pass3/$list)
(pass3/register $LIBRARY       pass3/$library)
;(pass3/register $IMPORT        pass3/$import)
(pass3/register $IT            pass3/$it)
(pass3/register $RECEIVE       pass3/$receive)

;; depth is the depth of frame, used for 'jump' and 'embeded' call and indicate the size of frame to discard.
(define (pass3/rec cb iform locals frees can-frees sets tail depth)
  ((vector-ref pass3/dispatch-table (vector-ref iform 0)) cb iform locals frees can-frees sets tail depth))

(define (pass3 iform)
  (let1 cb (make-code-builder)
    (pass3/rec cb iform '() *free-vars-decl* '() (make-eq-hashtable) #f 0)
    (code-builder-emit cb)))

(define
  (pass4 lst)
  (pass4/fixup-labels
    (list->vector (append lst (quote (HALT))))))

(define
  (compile-library-body! lib)
  (let1 body
        ($append-map1
          (lambda
            (sexp)
            (pass3 (pass2/optimize
                     (pass1/sexp->iform
                       (pass1/expand sexp)
                       lib
                       (quote ())
                       #f)
                     (quote ()))))
          ($library.body lib))
        ($library.set-compiled-body!
          lib
          (pass4 (quasiquote ((unquote-splicing body) RETURN 0))))))

(define (merge-insn sexp) (define (iter s) (cond ((null? s) '()) (else (match s (('REFER_LOCAL0_PUSH 'CONSTANT . rest) (iter `(REFER_LOCAL0_PUSH_CONSTANT ,@rest))) (('REFER_LOCAL1_PUSH 'CONSTANT . rest) (iter `(REFER_LOCAL1_PUSH_CONSTANT ,@rest))) (('REFER_LOCAL 1 'PUSH . rest) (iter `(REFER_LOCAL1_PUSH ,@rest))) (('REFER_LOCAL 0 'PUSH . rest) (iter `(REFER_LOCAL0_PUSH ,@rest))) (('REFER_LOCAL 0 . rest) (iter `(REFER_LOCAL0 ,@rest))) (((and x (not 'CONSTANT)) 'NUMBER_SUB 'PUSH . rest) (iter `(,x NUMBER_SUB_PUSH ,@rest))) (('PUSH 'ENTER . rest) (iter (cons 'PUSH_ENTER rest))) (('CONSTANT v 'PUSH . rest) (iter `(CONSTANT_PUSH ,v ,@rest))) (('REFER_FREE 0 'PUSH . rest) (iter `(REFER_FREE0_PUSH ,@rest))) (('REFER_FREE 1 'PUSH . rest) (iter `(REFER_FREE1_PUSH ,@rest))) (('REFER_FREE 2 'PUSH . rest) (iter `(REFER_FREE2_PUSH ,@rest))) (('REFER_FREE n 'PUSH . rest) (iter `(REFER_FREE_PUSH ,n ,@rest))) (('REFER_FREE_PUSH n 'REFER_FREE_PUSH . rest) (iter `(REFER_FREE_PUSH_REFER_FREE_PUSH ,n ,@rest))) (('REFER_FREE 0 . rest) (iter `(REFER_FREE0 ,@rest))) (('REFER_FREE 1 . rest) (iter `(REFER_FREE1 ,@rest))) (('REFER_FREE 2 . rest) (iter `(REFER_FREE2 ,@rest))) (('REFER_LOCAL 1 . rest) (iter `(REFER_LOCAL1 ,@rest))) (('REFER_LOCAL 2 . rest) (iter `(REFER_LOCAL2 ,@rest))) (('LEAVE 1 . rest) (iter `(LEAVE1 ,@rest))) (('NUMBER_LE 'TEST . rest) (iter `(NUMBER_LE_TEST ,@rest))) (('NUMBER_ADD 'PUSH . rest) (iter `(NUMBER_ADD_PUSH ,@rest))) (('RETURN 1 . rest) (iter `(RETURN1 ,@rest))) (('RETURN 2 . rest) (iter `(RETURN2 ,@rest))) (('RETURN 3 . rest) (iter `(RETURN3 ,@rest))) (('CALL 2 . rest) (iter `(CALL2 ,@rest))) (('REFER_LOCAL0 'EQV 'TEST . rest) (iter `(REFER_LOCAL0_EQV_TEST ,@rest))) (('PUSH 'CONSTANT . rest) (iter `(PUSH_CONSTANT ,@rest))) (('PUSH 'FRAME . rest) (iter `(PUSH_FRAME ,@rest))) (((and x (not 'CONSTANT_PUSH)) 'PUSH 'FRAME . rest) (iter `(,x PUSH_FRAME ,@rest))) (('REFER_FREE 3 . rest) (iter `(REFER_FREE3 ,@rest))) (('REFER_LOCAL 3 . rest) (iter `(REFER_LOCAL3 ,@rest))) (('CAR 'PUSH . rest) (iter `(CAR_PUSH ,@rest))) (('CDR 'PUSH . rest) (iter `(CDR_PUSH ,@rest))) (('REFER_FREE0 'INDIRECT . rest) (iter `(REFER_FREE0_INDIRECT ,@rest))) (('REFER_LOCAL2 'PUSH . rest) (iter `(REFER_LOCAL2_PUSH ,@rest))) (('SHIFT m n 'CALL o . rest) (iter `(SHIFT_CALL ,m ,n ,o ,@rest))) (('CALL 3 . rest) (iter `(CALL3 ,@rest))) (('REFER_FREE1 'INDIRECT . rest) (iter `(REFER_FREE1_INDIRECT ,@rest))) (('NOT 'TEST . rest) (iter `(NOT_TEST ,@rest))) (('REFER_GLOBAL lib-id 'CALL n . rest) (iter `(REFER_GLOBAL_CALL ,lib-id ,n ,@rest))) (('REFER_LOCAL0 'NUMBER_ADD_PUSH . rest) (iter (cons 'REFER_LOCAL0_NUMBER_ADD_PUSH rest))) (('REFER_LOCAL0 'VECTOR_SET . rest) (iter (cons 'REFER_LOCAL0_VECTOR_SET rest))) (('REFER_LOCAL0 'VECTOR_REF . rest) (iter (cons 'REFER_LOCAL0_VECTOR_REF rest))) (('REFER_LOCAL n 'PUSH . rest) (iter `(REFER_LOCAL_PUSH ,n ,@rest))) (else (cons (car s) (iter (cdr s)))))))) (iter sexp))
(define
  (compile-partial sexp . lib)
  (let1 ss
        (pass1/expand sexp)
        (vector->list
          (pass4/fixup-labels
            (list->vector
              (merge-insn
               (let1 code
                (pass3 (let1 v (pass2/optimize
                             (let1 x
                              (pass1/sexp->iform
                                ss
                                (if (null? lib) top-level-library (car lib))
                                (quote ())
                                #f)
;                              (pretty-iform x)
                              x)
                              (quote ()))
;                         (pretty-iform v)
                         v)
                         )
;                (write/ss code)
;                (newline)
                code)
                ))))))

(define-macro
  (pass4/fixup-labels-clollect insn)
  (quasiquote
    (begin (vector-set! ret j (unquote insn))
           (vector-set! ret (+ j 1) (vector-ref v (+ i 1)))
           (loop (+ i 2) (+ j 2)))))

(define-macro
  (pass4/fixup-labels-insn insn)
  (quasiquote
    (let1 label
          (hashtable-ref
            labels
            (vector-ref code (+ i 1))
            #f)
          (cond (label (vector-set! code i (unquote insn))
                       (vector-set! code (+ i 1) (- label i 1))
                       (loop (+ i 2)))
                (else (loop (+ i 1)))))))

(define (peephole-optimization v) (let ((len (vector-length v))) (let loop ((i 0)) (if (= i len) '() (let1 insn (vector-ref v i) (cond ((or (eq? insn 'LOCAL_JMP) (and (eq? insn 'FRAME) (number? (vector-ref v (+ i 1))))) (let* ((offset (+ (vector-ref v (+ i 1)) 1)) (destination-index (+ i offset))) (cond ((eq? (vector-ref v destination-index) 'LOCAL_JMP) (vector-set! v (+ i 1) (+ offset (vector-ref v (+ destination-index 1))))) ((eq? (vector-ref v destination-index) 'RETURN) (vector-set! v i 'RETURN) (vector-set! v (+ i 1) (vector-ref v (+ destination-index 1))))))) ((and (eq? insn 'TEST) (number? (vector-ref v (+ i 1)))) (let* ((offset (+ (vector-ref v (+ i 1)) 1)) (destination-index (+ i offset))) (when (or (eq? (vector-ref v destination-index) 'TEST) (eq? (vector-ref v destination-index) 'LOCAL_JMP)) (vector-set! v (+ i 1) (+ offset (vector-ref v (+ destination-index 1)))))))) (loop (+ i 1)))))))(define (pass4/fixup-labels v) (define (collect-labels) (let* ((len (vector-length v)) (ret (make-vector len 'NOP)) (labels (make-eq-hashtable))) (let loop ((i 0) (j 0)) (cond ((= i len) (values ret labels)) (else (let1 insn (vector-ref v i) (cond ((eq? insn 'UNFIXED_JUMP) (pass4/fixup-labels-clollect 'UNFIXED_JUMP)) ((eq? insn 'TEST) (pass4/fixup-labels-clollect 'TEST)) ((eq? insn 'NUMBER_LE_TEST) (pass4/fixup-labels-clollect 'NUMBER_LE_TEST)) ((eq? insn 'NOT_TEST) (pass4/fixup-labels-clollect 'NOT_TEST)) ((eq? insn 'REFER_LOCAL0_EQV_TEST) (pass4/fixup-labels-clollect 'REFER_LOCAL0_EQV_TEST)) ((eq? insn 'FRAME) (pass4/fixup-labels-clollect 'FRAME)) ((eq? insn 'PUSH_FRAME) (pass4/fixup-labels-clollect 'PUSH_FRAME)) ((eq? insn 'CLOSURE) (pass4/fixup-labels-clollect 'CLOSURE)) ((and (vector? insn) (> (vector-length insn) 0) (tag? insn $LABEL)) (hashtable-set! labels insn j) (loop (+ i 1) j)) (else (vector-set! ret j insn) (loop (+ i 1) (+ j 1)))))))))) (receive (code labels) (collect-labels) (let1 len (vector-length code) (let loop ((i 0)) (cond ((= i len) code) (else (let1 insn (vector-ref code i) (cond ((eq? insn 'UNFIXED_JUMP) (pass4/fixup-labels-insn 'LOCAL_JMP)) ((eq? insn 'CLOSURE) (pass4/fixup-labels-insn 'CLOSURE)) ((eq? insn 'TEST) (pass4/fixup-labels-insn 'TEST)) ((eq? insn 'NUMBER_LE_TEST) (pass4/fixup-labels-insn 'NUMBER_LE_TEST)) ((eq? insn 'NOT_TEST) (pass4/fixup-labels-insn 'NOT_TEST)) ((eq? insn 'REFER_LOCAL0_EQV_TEST) (pass4/fixup-labels-insn 'REFER_LOCAL0_EQV_TEST)) ((eq? insn 'FRAME) (pass4/fixup-labels-insn 'FRAME)) ((eq? insn 'PUSH_FRAME) (pass4/fixup-labels-insn 'PUSH_FRAME)) (else (loop (+ i 1))))))))) (peephole-optimization code) code))(define
  (compile sexp)
  (pass4 (merge-insn
          (let1 p3
           (pass3 (let1 x
                        (pass2/optimize
                          (pass1/sexp->iform
                            (pass1/expand sexp)
                            top-level-library
                            (quote ())
                            #f)
                          (quote ()))
;                    (pretty-iform x)
                        x))
           p3)
)))

(define
  (compile-no-optimize sexp)
  (pass4 (pass3 (pass1/sexp->iform
                  (pass1/expand sexp)
                  top-level-library
                  (quote ())
                  #f))))

(define (main args) (if (= (length args) 2) (let1 port (open-string-input-port (second args)) (write (compile (read port))))))
