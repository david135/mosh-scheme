#!/usr/bin/env gosh
(define (proc-name->c-proc-name name)
  (cond
   [(string=? name "+")
    "addEx"]
   [(string=? name "-")
    "subEx"]
   [(string=? name "*")
    "mulEx"]
   [(string=? name "/")
    "divideEx"]
   [(string=? name "=")
    "eqEx"]
   [(string=? name ">")
    "gtEx"]
   [(string=? name "<")
    "ltEx"]
   [(string=? name ">=")
    "geEx"]
   [(string=? name "<=")
    "leEx"]
   [(string=? name "div")
    "integerDivEx"]
   [(string=? name "div0")
    "integerDiv0Ex"]
   [(string=? name "fldiv")
    "flIntegerDivEx"]
   [(string=? name "flmod")
    "flIntegerModEx"]
   [(string=? name "fldiv0")
    "flIntegerDiv0Ex"]
   [(string=? name "flmod0")
    "flIntegerMod0Ex"]
   [else
    (call-with-string-io
     name
     (lambda (in out)
       (define (rec c)
         (cond
          [(eof-object? c)
           (display "Ex" out)]
          [else
           (case c
             [(#\?)
              (display "P" out)
              (rec (read-char in))]
             [(#\!)
              (display "D" out)
              (rec (read-char in))]
             [(#\%)
              (display "internal" out)
              (display (char-upcase (read-char in)) out)
              (rec (read-char in))]
             [(#\$)
              (rec (read-char in))]
             [(#\>)
              (let1 c (read-char in)
                (cond
                 [(eof-object? c)
                  (display "GtEx" out)]
                 [(char=? #\= c)
                  (display "Ge" out)
                  (rec (read-char in))]
                 [else
                  (display "Gt" out)
                  (rec c)]))]
             [(#\<)
              (let1 c (read-char in)
                (cond
                 [(eof-object? c)
                  (display "LtEx" out)]
                 [(char=? #\= c)
                  (display "Le" out)
                  (rec (read-char in))]
                 [else
                  (display "Lt" out)
                  (rec c)]))]
             [(#\!)
              (rec (read-char in))]
             [(#\=)
              (display "Eq" out)
              (rec (read-char in))]
             [(#\+)
              (display "Add" out)
              (rec (read-char in))]
             [(#\/)
              (let1 c (read-char in)
                (if (eof-object? c)
                    (display "Div" out)
                    (display (char-upcase c) out)))
                (rec (read-char in))]
             [(#\*)
              (display "Mul" out)
              (rec (read-char in))]
             [(#\-)
              (let1 c  (read-char in)
                (if (eof-object? c)
                    (display "Sub" out)
                    (if (char=? #\> c)
                        (display "To" out)
                        (display (char-upcase c) out))))
              (rec (read-char in))]
             [else
              (display c out)
              (rec (read-char in))])]))
       (rec (read-char in))))]))

(define (main args)
  (load "./free-vars-decl.scm")
  (print "// Do not edit this file generated by gen-cproc.scm");
  (let1 procs (map symbol->string *free-vars-decl*)
    (format #t "const int cProcNum = ~d;\n" (length procs))
    (display "static const Object cProcs[] = {\n")
    (for-each (lambda (proc) (format #t "     Object::makeCProcedure(~a),\n" (proc-name->c-proc-name proc))) (reverse procs))
    (display "};\n")
    (display "#ifdef ENABLE_PROFILER\n")
    (display "static const ucs4char* cProcNames[] = {\n")
    (for-each (lambda (proc) (format #t "     UC(~s),\n" proc)) (reverse procs))
    (display "};\n")
    (display "#endif\n")
    0))
