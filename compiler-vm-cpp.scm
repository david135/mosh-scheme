;; Do not edit this file generated by ./scripts/gen-compiler.scm.
(define dd display)(define pp print)(define *free-vars-decl* '(number? cons car cdr null? set-car! set-cdr! sys-display rxmatch regexp? regexp->string rxmatch-start rxmatch-end rxmatch-after rxmatch-before rxmatch-substring make-string string-set! string-length string->symbol string->number string-append string-split number->string reverse eof-object? read-char char=? string? sys-getenv equal? open-string-input-port sys-open-output-string sys-port-seek open-output-file close-output-port digit->integer get-remaining-input-string sys-readdir file-exists? sys-get-output-string string->regexp char->integer integer->char format current-input-port current-output-port set-current-input-port! set-current-output-port! char? write gensym string=? vector? list? memq eq? member boolean? symbol->string string-ref error get-timeofday make-eq-hashtable hashtable-set! hashtable-ref hashtable-keys current-error-port values vm/apply pair? init-library-table map10 find10 make-custom-binary-input-port get-u8 bytevector-u8-set! transcoded-port utf-8-codec make-transcoder eof-object sys-open-bytevector-output-port sys-get-bytevector bytevector-length bytevector-u8-ref standard-input-port get-bytevector-n utf8->string open-file-output-port open-file-input-port close-input-port vector regexp-replace regexp-replace-all source-info errorf eval raise raise-continuable with-exception-handler make-vector-type vector-type? vector-type-data vector-type-instance-of? make-typed-vector typed-vector-get-nth typed-vector-set-nth typed-vector? typed-vector-type apply mod div assq exit macroexpand-1 memv procedure? load symbol? dynamic-wind char<=? char<? char>=? char>? read vector->list set-source-info! call-process %get-closure-name append append2 appendA append! pass3/find-free pass3/find-sets %set-union))(define-macro (make-list-with-src-slot lst) lst)(define (command-line) *command-line-args*)(define-macro
  (first o)
  (quasiquote (car (unquote o))))

(define-macro
  (second o)
  (quasiquote (cadr (unquote o))))

(define-macro
  (third o)
  (quasiquote (caddr (unquote o))))

(define-macro
  (dolist a . body)
  (quasiquote
    (begin (for-each
             (lambda
               ((unquote (first a)))
               (unquote-splicing body))
             (unquote (second a)))
           (quote ()))))

(define-macro
  (do . sexp)
  (match sexp
         ((((var init step ...) ...)
           (test expr ...)
           command
           ...)
          (quasiquote
            (letrec
              ((loop (lambda
                       ((unquote-splicing var))
                       (if (unquote test)
                           (begin #f (unquote-splicing expr))
                           (begin (unquote-splicing command)
                                  (loop (unquote-splicing
                                          (map (lambda
                                                 (v s)
                                                 (quasiquote
                                                   (do "step"
                                                       (unquote v)
                                                       (unquote-splicing s))))
                                               var
                                               step))))))))
              (loop (unquote-splicing init)))))
         (("step" x) x)
         (("step" x y) y)
         (else (syntax-error "malformed do"))))

(define-macro
  (acond . clauses)
  (if (null? clauses)
      (quote ())
      (let ((cl1 (car clauses)) (sym (gensym)))
           (quasiquote
             (let (((unquote sym) (unquote (car cl1))))
                  (if (unquote sym)
                      (let ((it (unquote sym)))
                           (unquote-splicing (cdr cl1)))
                      (acond (unquote-splicing (cdr clauses)))))))))

(define-macro
  (aif test-form then-form . else-form)
  (quasiquote
    (let ((it (unquote test-form)))
         (if it
             (unquote then-form)
             (unquote-splicing else-form)))))

(define
  (syntax-error msg)
  (raise (format "syntax error: ~a" msg)))

(define
  (acons obj1 obj2 obj3)
  (cons (cons obj1 obj2) obj3))

(define
  (libname->symbol name)
  (let loop
       ((name name) (ret ""))
       (if (null? name)
           (string->symbol ret)
           (loop (cdr name)
                 (string-append
                   ret
                   (symbol->string (car name))
                   " ")))))

(define
  (make-gensym)
  (let1 i
        0
        (lambda
          ()
          (set! i (+ i 1))
          (string->symbol (format "G~d" i)))))

(define-macro
  with-gensym
  (lambda
    body
    (let ((org (gensym)) (ret (gensym)))
         (quasiquote
           (let1 (unquote org)
                 gensym
                 (set! gensym (unquote (make-gensym)))
                 (let (((unquote ret) (begin (unquote-splicing body))))
                      (set! gensym (unquote org))
                      (unquote ret)))))))

(define
  (%set-union l1 l2)
  (define
    (set-cons x lst)
    (if (memq x lst) lst (cons x lst)))
  (define
    (rec lst1 lst2)
    (cond ((null? lst1) lst2)
          ((null? lst2) lst1)
          (else (rec (cdr lst1) (set-cons (car lst1) lst2)))))
  (rec l1 l2))

(define
  (set-minus lst1 lst2)
  (if (null? lst1)
      (quote ())
      (if (memq (car lst1) lst2)
          (set-minus (cdr lst1) lst2)
          (cons (car lst1) (set-minus (cdr lst1) lst2)))))

(define
  (set-intersect lst1 lst2)
  (if (null? lst1)
      (quote ())
      (if (memq (car lst1) lst2)
          (cons (car lst1) (set-intersect (cdr lst1) lst2))
          (set-intersect (cdr lst1) lst2))))

(define
  (log . msg)
  (display msg (current-error-port)))

(define
  ($map1 f l)
  (if (null? l)
      l
      (cons (f (car l)) ($map1 f (cdr l)))))

(define
  ($filter-map1 f l)
  (if (null? l)
      l
      (aif (f (car l))
           (cons it ($filter-map1 f (cdr l)))
           ($filter-map1 f (cdr l)))))

(define
  ($map1-with-tail f l)
  (if (null? l)
      l
      (cons (f (car l) (null? (cdr l)))
            ($map1-with-tail f (cdr l)))))

(define
  ($map1-with-rindex f l)
  (define
    (iter f l i)
    (if (null? l)
        l
        (cons (f (car l) i) (iter f (cdr l) (- i 1)))))
  (iter f l (- (length l) 1)))

(define
  ($map1-with-index f l)
  (define
    (iter f l i)
    (if (null? l)
        l
        (cons (f (car l) i) (iter f (cdr l) (+ i 1)))))
  (iter f l 0))

(define
  ($reverse-append-map1 proc l)
  (let loop
       ((l l))
       (if (null? l)
           (quote ())
           (append2 (loop (cdr l)) (proc (car l))))))

(define
  ($append-map1-with-rindex proc l)
  (let loop
       ((l l) (i (- (length l) 1)))
       (if (null? l)
           (quote ())
           (append2 (proc (car l) i) (loop (cdr l) (- i 1))))))

(define
  ($append-map1-with-tail proc l)
  (apply append ($map1-with-tail proc l)))

(define-macro
  ($append-map1 f l)
  (quasiquote
    (apply append ($map1 (unquote f) (unquote l)))))

(define-macro
  ($append!-map1 f l)
  (quasiquote
    (apply append! ($map1 (unquote f) (unquote l)))))

(define
  (uniq lst)
  (let loop
       ((lst lst) (ret (quote ())))
       (cond ((null? lst) ret)
             (else (if (memq (car lst) ret)
                       (loop (cdr lst) ret)
                       (loop (cdr lst) (cons (car lst) ret)))))))

(define
  (apply-each-pair proc lst)
  (if (null? (cdr lst))
      (quote ())
      (cons (list proc (car lst) (cadr lst))
            (apply-each-pair proc (cdr lst)))))

(define
  (remove-tail lst pred)
  (let loop
       ((lst lst) (ret (quote ())))
       (cond ((null? (cdr lst))
              (reverse
                (if (pred (car lst)) ret (cons (car lst) ret))))
             (else (loop (cdr lst) (cons (car lst) ret))))))

(define $CONST 0)

(define
  ($const val)
  (let1 v
        (make-vector 2)
        (vector-set! v 0 $CONST)
        (vector-set! v 1 val)
        v))

(define-macro
  ($const.val iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($const.set-val! iform val)
  (quasiquote
    (vector-set! (unquote iform) 1 (unquote val))))

(define $LVAR 1)

(define
  ($lvar sym init-val ref-count set-count)
  (let1 v
        (make-vector 5)
        (vector-set! v 0 $LVAR)
        (vector-set! v 1 sym)
        (vector-set! v 2 init-val)
        (vector-set! v 3 ref-count)
        (vector-set! v 4 set-count)
        v))

(define-macro
  ($lvar.sym iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($lvar.init-val iform)
  (quasiquote (vector-ref (unquote iform) 2)))

(define-macro
  ($lvar.ref-count iform)
  (quasiquote (vector-ref (unquote iform) 3)))

(define-macro
  ($lvar.set-count iform)
  (quasiquote (vector-ref (unquote iform) 4)))

(define-macro
  ($lvar.set-sym! iform sym)
  (quasiquote
    (vector-set! (unquote iform) 1 (unquote sym))))

(define-macro
  ($lvar.set-init-val! iform init-val)
  (quasiquote
    (vector-set!
      (unquote iform)
      2
      (unquote init-val))))

(define-macro
  ($lvar.set-ref-count! iform ref-count)
  (quasiquote
    (vector-set!
      (unquote iform)
      3
      (unquote ref-count))))

(define-macro
  ($lvar.set-set-count! iform set-count)
  (quasiquote
    (vector-set!
      (unquote iform)
      4
      (unquote set-count))))

(define
  (pp-lvars lvars)
  (print (map (lambda (x) ($lvar.sym x)) lvars)))

(define $LET 2)

(define
  ($let type lvars inits body tail? src)
  (let1 v
        (make-vector 7)
        (vector-set! v 0 $LET)
        (vector-set! v 1 type)
        (vector-set! v 2 lvars)
        (vector-set! v 3 inits)
        (vector-set! v 4 body)
        (vector-set! v 5 tail?)
        (vector-set! v 6 src)
        v))

(define-macro
  ($let.type iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($let.lvars iform)
  (quasiquote (vector-ref (unquote iform) 2)))

(define-macro
  ($let.inits iform)
  (quasiquote (vector-ref (unquote iform) 3)))

(define-macro
  ($let.body iform)
  (quasiquote (vector-ref (unquote iform) 4)))

(define-macro
  ($let.tail? iform)
  (quasiquote (vector-ref (unquote iform) 5)))

(define-macro
  ($let.src iform)
  (quasiquote (vector-ref (unquote iform) 6)))

(define-macro
  ($let.set-type! iform type)
  (quasiquote
    (vector-set! (unquote iform) 1 (unquote type))))

(define-macro
  ($let.set-lvars! iform lvars)
  (quasiquote
    (vector-set! (unquote iform) 2 (unquote lvars))))

(define-macro
  ($let.set-inits! iform inits)
  (quasiquote
    (vector-set! (unquote iform) 3 (unquote inits))))

(define-macro
  ($let.set-body! iform body)
  (quasiquote
    (vector-set! (unquote iform) 4 (unquote body))))

(define-macro
  ($let.set-tail?! iform tail?)
  (quasiquote
    (vector-set! (unquote iform) 5 (unquote tail?))))

(define-macro
  ($let.set-src! iform src)
  (quasiquote
    (vector-set! (unquote iform) 6 (unquote src))))

(define $SEQ 3)

(define
  ($seq body tail?)
  (let1 v
        (make-vector 3)
        (vector-set! v 0 $SEQ)
        (vector-set! v 1 body)
        (vector-set! v 2 tail?)
        v))

(define-macro
  ($seq.body iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($seq.tail? iform)
  (quasiquote (vector-ref (unquote iform) 2)))

(define-macro
  ($seq.set-body! iform body)
  (quasiquote
    (vector-set! (unquote iform) 1 (unquote body))))

(define-macro
  ($seq.set-tail?! iform tail?)
  (quasiquote
    (vector-set! (unquote iform) 2 (unquote tail?))))

(define $LAMBDA 4)

(define
  ($lambda
    src
    name
    reqargs
    optarg
    lvars
    body
    flag
    calls)
  (let1 v
        (make-vector 9)
        (vector-set! v 0 $LAMBDA)
        (vector-set! v 1 src)
        (vector-set! v 2 name)
        (vector-set! v 3 reqargs)
        (vector-set! v 4 optarg)
        (vector-set! v 5 lvars)
        (vector-set! v 6 body)
        (vector-set! v 7 flag)
        (vector-set! v 8 calls)
        v))

(define-macro
  ($lambda.src iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($lambda.name iform)
  (quasiquote (vector-ref (unquote iform) 2)))

(define-macro
  ($lambda.reqargs iform)
  (quasiquote (vector-ref (unquote iform) 3)))

(define-macro
  ($lambda.optarg iform)
  (quasiquote (vector-ref (unquote iform) 4)))

(define-macro
  ($lambda.lvars iform)
  (quasiquote (vector-ref (unquote iform) 5)))

(define-macro
  ($lambda.body iform)
  (quasiquote (vector-ref (unquote iform) 6)))

(define-macro
  ($lambda.flag iform)
  (quasiquote (vector-ref (unquote iform) 7)))

(define-macro
  ($lambda.calls iform)
  (quasiquote (vector-ref (unquote iform) 8)))

(define-macro
  ($lambda.set-src! iform src)
  (quasiquote
    (vector-set! (unquote iform) 1 (unquote src))))

(define-macro
  ($lambda.set-name! iform name)
  (quasiquote
    (vector-set! (unquote iform) 2 (unquote name))))

(define-macro
  ($lambda.set-reqargs! iform reqargs)
  (quasiquote
    (vector-set! (unquote iform) 3 (unquote reqargs))))

(define-macro
  ($lambda.set-optarg! iform optarg)
  (quasiquote
    (vector-set! (unquote iform) 4 (unquote optarg))))

(define-macro
  ($lambda.set-lvars! iform lvars)
  (quasiquote
    (vector-set! (unquote iform) 5 (unquote lvars))))

(define-macro
  ($lambda.set-body! iform body)
  (quasiquote
    (vector-set! (unquote iform) 6 (unquote body))))

(define-macro
  ($lambda.set-flag! iform flag)
  (quasiquote
    (vector-set! (unquote iform) 7 (unquote flag))))

(define-macro
  ($lambda.set-calls! iform calls)
  (quasiquote
    (vector-set! (unquote iform) 8 (unquote calls))))

(define $LOCAL-REF 5)

(define
  ($local-ref lvar)
  (let1 v
        (make-vector 2)
        (vector-set! v 0 $LOCAL-REF)
        (vector-set! v 1 lvar)
        v))

(define-macro
  ($local-ref.lvar iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($local-ref.set-lvar! iform lvar)
  (quasiquote
    (vector-set! (unquote iform) 1 (unquote lvar))))

(define $LOCAL-ASSIGN 6)

(define
  ($local-assign lvar val)
  (let1 v
        (make-vector 3)
        (vector-set! v 0 $LOCAL-ASSIGN)
        (vector-set! v 1 lvar)
        (vector-set! v 2 val)
        v))

(define-macro
  ($local-assign.lvar iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($local-assign.val iform)
  (quasiquote (vector-ref (unquote iform) 2)))

(define-macro
  ($local-assign.set-lvar! iform lvar)
  (quasiquote
    (vector-set! (unquote iform) 1 (unquote lvar))))

(define-macro
  ($local-assign.set-val! iform val)
  (quasiquote
    (vector-set! (unquote iform) 2 (unquote val))))

(define $GLOBAL-REF 7)

(define
  ($global-ref libname sym)
  (let1 v
        (make-vector 3)
        (vector-set! v 0 $GLOBAL-REF)
        (vector-set! v 1 libname)
        (vector-set! v 2 sym)
        v))

(define-macro
  ($global-ref.libname iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($global-ref.sym iform)
  (quasiquote (vector-ref (unquote iform) 2)))

(define-macro
  ($global-ref.set-libname! iform libname)
  (quasiquote
    (vector-set! (unquote iform) 1 (unquote libname))))

(define-macro
  ($global-ref.set-sym! iform sym)
  (quasiquote
    (vector-set! (unquote iform) 2 (unquote sym))))

(define $GLOBAL-ASSIGN 8)

(define
  ($global-assign libname sym val)
  (let1 v
        (make-vector 4)
        (vector-set! v 0 $GLOBAL-ASSIGN)
        (vector-set! v 1 libname)
        (vector-set! v 2 sym)
        (vector-set! v 3 val)
        v))

(define-macro
  ($global-assign.libname iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($global-assign.sym iform)
  (quasiquote (vector-ref (unquote iform) 2)))

(define-macro
  ($global-assign.val iform)
  (quasiquote (vector-ref (unquote iform) 3)))

(define-macro
  ($global-assign.set-libname! iform libname)
  (quasiquote
    (vector-set! (unquote iform) 1 (unquote libname))))

(define-macro
  ($global-assign.set-sym! iform sym)
  (quasiquote
    (vector-set! (unquote iform) 2 (unquote sym))))

(define-macro
  ($global-assign.set-val! iform val)
  (quasiquote
    (vector-set! (unquote iform) 3 (unquote val))))

(define $UNDEF 9)

(define ($undef) (make-vector 1 $UNDEF))

(define $IF 10)

(define
  ($if test then else)
  (let1 v
        (make-vector 4)
        (vector-set! v 0 $IF)
        (vector-set! v 1 test)
        (vector-set! v 2 then)
        (vector-set! v 3 else)
        v))

(define-macro
  ($if.test iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($if.then iform)
  (quasiquote (vector-ref (unquote iform) 2)))

(define-macro
  ($if.else iform)
  (quasiquote (vector-ref (unquote iform) 3)))

(define-macro
  ($if.set-test! iform test)
  (quasiquote
    (vector-set! (unquote iform) 1 (unquote test))))

(define-macro
  ($if.set-then! iform then)
  (quasiquote
    (vector-set! (unquote iform) 2 (unquote then))))

(define-macro
  ($if.set-else! iform else)
  (quasiquote
    (vector-set! (unquote iform) 3 (unquote else))))

(define $ASM 11)

(define
  ($asm insn args)
  (let1 v
        (make-vector 3)
        (vector-set! v 0 $ASM)
        (vector-set! v 1 insn)
        (vector-set! v 2 args)
        v))

(define-macro
  ($asm.insn iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($asm.args iform)
  (quasiquote (vector-ref (unquote iform) 2)))

(define-macro
  ($asm.set-insn! iform insn)
  (quasiquote
    (vector-set! (unquote iform) 1 (unquote insn))))

(define-macro
  ($asm.set-args! iform args)
  (quasiquote
    (vector-set! (unquote iform) 2 (unquote args))))

(define $DEFINE 12)

(define
  ($define libname sym val)
  (let1 v
        (make-vector 4)
        (vector-set! v 0 $DEFINE)
        (vector-set! v 1 libname)
        (vector-set! v 2 sym)
        (vector-set! v 3 val)
        v))

(define-macro
  ($define.libname iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($define.sym iform)
  (quasiquote (vector-ref (unquote iform) 2)))

(define-macro
  ($define.val iform)
  (quasiquote (vector-ref (unquote iform) 3)))

(define-macro
  ($define.set-libname! iform libname)
  (quasiquote
    (vector-set! (unquote iform) 1 (unquote libname))))

(define-macro
  ($define.set-sym! iform sym)
  (quasiquote
    (vector-set! (unquote iform) 2 (unquote sym))))

(define-macro
  ($define.set-val! iform val)
  (quasiquote
    (vector-set! (unquote iform) 3 (unquote val))))

(define $CALL-CC 13)

(define
  ($call-cc proc tail?)
  (let1 v
        (make-vector 3)
        (vector-set! v 0 $CALL-CC)
        (vector-set! v 1 proc)
        (vector-set! v 2 tail?)
        v))

(define-macro
  ($call-cc.proc iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($call-cc.tail? iform)
  (quasiquote (vector-ref (unquote iform) 2)))

(define-macro
  ($call-cc.set-proc! iform proc)
  (quasiquote
    (vector-set! (unquote iform) 1 (unquote proc))))

(define-macro
  ($call-cc.set-tail?! iform tail?)
  (quasiquote
    (vector-set! (unquote iform) 2 (unquote tail?))))

(define $CALL 14)

(define
  ($call proc args tail? type)
  (let1 v
        (make-vector 5)
        (vector-set! v 0 $CALL)
        (vector-set! v 1 proc)
        (vector-set! v 2 args)
        (vector-set! v 3 tail?)
        (vector-set! v 4 type)
        v))

(define-macro
  ($call.proc iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($call.args iform)
  (quasiquote (vector-ref (unquote iform) 2)))

(define-macro
  ($call.tail? iform)
  (quasiquote (vector-ref (unquote iform) 3)))

(define-macro
  ($call.type iform)
  (quasiquote (vector-ref (unquote iform) 4)))

(define-macro
  ($call.set-proc! iform proc)
  (quasiquote
    (vector-set! (unquote iform) 1 (unquote proc))))

(define-macro
  ($call.set-args! iform args)
  (quasiquote
    (vector-set! (unquote iform) 2 (unquote args))))

(define-macro
  ($call.set-tail?! iform tail?)
  (quasiquote
    (vector-set! (unquote iform) 3 (unquote tail?))))

(define-macro
  ($call.set-type! iform type)
  (quasiquote
    (vector-set! (unquote iform) 4 (unquote type))))

(define $LABEL 15)

(define
  ($label label body)
  (let1 v
        (make-vector 3)
        (vector-set! v 0 $LABEL)
        (vector-set! v 1 label)
        (vector-set! v 2 body)
        v))

(define-macro
  ($label.label iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($label.body iform)
  (quasiquote (vector-ref (unquote iform) 2)))

(define-macro
  ($label.set-label! iform label)
  (quasiquote
    (vector-set! (unquote iform) 1 (unquote label))))

(define-macro
  ($label.set-body! iform body)
  (quasiquote
    (vector-set! (unquote iform) 2 (unquote body))))

(define-macro
  (make-label)
  (quasiquote ($label #f #f)))

(define-macro (ref-label l) l)

(define $LIST 16)

(define
  ($list args)
  (let1 v
        (make-vector 2)
        (vector-set! v 0 $LIST)
        (vector-set! v 1 args)
        v))

(define-macro
  ($list.args iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($list.set-args! iform args)
  (quasiquote
    (vector-set! (unquote iform) 1 (unquote args))))

(define $LIBRARY 17)

(define
  ($library
    name
    export-syms
    import-syms
    import
    macro
    body
    compiled-body)
  (let1 v
        (make-vector 8)
        (vector-set! v 0 $LIBRARY)
        (vector-set! v 1 (libname->symbol name))
        (vector-set! v 2 export-syms)
        (vector-set! v 3 import-syms)
        (vector-set! v 4 import)
        (vector-set! v 5 macro)
        (vector-set! v 6 body)
        (vector-set! v 7 compiled-body)
        v))

(define-macro
  ($library.name iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($library.export-syms iform)
  (quasiquote (vector-ref (unquote iform) 2)))

(define-macro
  ($library.import-syms iform)
  (quasiquote (vector-ref (unquote iform) 3)))

(define-macro
  ($library.import iform)
  (quasiquote (vector-ref (unquote iform) 4)))

(define-macro
  ($library.macro iform)
  (quasiquote (vector-ref (unquote iform) 5)))

(define-macro
  ($library.body iform)
  (quasiquote (vector-ref (unquote iform) 6)))

(define-macro
  ($library.compiled-body iform)
  (quasiquote (vector-ref (unquote iform) 7)))

(define-macro
  ($library.set-name! iform name)
  (quasiquote
    (vector-set! (unquote iform) 1 (unquote name))))

(define-macro
  ($library.set-export-syms! iform export-syms)
  (quasiquote
    (vector-set!
      (unquote iform)
      2
      (unquote export-syms))))

(define-macro
  ($library.set-import-syms! iform import-syms)
  (quasiquote
    (vector-set!
      (unquote iform)
      3
      (unquote import-syms))))

(define-macro
  ($library.set-import! iform import)
  (quasiquote
    (vector-set! (unquote iform) 4 (unquote import))))

(define-macro
  ($library.set-macro! iform macro)
  (quasiquote
    (vector-set! (unquote iform) 5 (unquote macro))))

(define-macro
  ($library.set-body! iform body)
  (quasiquote
    (vector-set! (unquote iform) 6 (unquote body))))

(define-macro
  ($library.set-compiled-body! iform compiled-body)
  (quasiquote
    (vector-set!
      (unquote iform)
      7
      (unquote compiled-body))))

(define $IMPORT 18)

(define
  ($import import-specs)
  (let1 v
        (make-vector 2)
        (vector-set! v 0 $IMPORT)
        (vector-set! v 1 import-specs)
        v))

(define-macro
  ($import.import-specs iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($import.set-import-specs! iform import-specs)
  (quasiquote
    (vector-set!
      (unquote iform)
      1
      (unquote import-specs))))

(define $IMPORT-SPEC 19)

(define
  ($import-spec libname level)
  (let1 v
        (make-vector 3)
        (vector-set! v 0 $IMPORT-SPEC)
        (vector-set! v 1 libname)
        (vector-set! v 2 level)
        v))

(define-macro
  ($import-spec.libname iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($import-spec.level iform)
  (quasiquote (vector-ref (unquote iform) 2)))

(define-macro
  ($import-spec.set-libname! iform libname)
  (quasiquote
    (vector-set! (unquote iform) 1 (unquote libname))))

(define-macro
  ($import-spec.set-level! iform level)
  (quasiquote
    (vector-set! (unquote iform) 2 (unquote level))))

(define $IT 20)

(define ($it) (make-vector 1 $IT))

(define $RECEIVE 21)

(define
  ($receive lvars reqargs optarg vals body tail?)
  (let1 v
        (make-vector 7)
        (vector-set! v 0 $RECEIVE)
        (vector-set! v 1 lvars)
        (vector-set! v 2 reqargs)
        (vector-set! v 3 optarg)
        (vector-set! v 4 vals)
        (vector-set! v 5 body)
        (vector-set! v 6 tail?)
        v))

(define-macro
  ($receive.lvars iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($receive.reqargs iform)
  (quasiquote (vector-ref (unquote iform) 2)))

(define-macro
  ($receive.optarg iform)
  (quasiquote (vector-ref (unquote iform) 3)))

(define-macro
  ($receive.vals iform)
  (quasiquote (vector-ref (unquote iform) 4)))

(define-macro
  ($receive.body iform)
  (quasiquote (vector-ref (unquote iform) 5)))

(define-macro
  ($receive.tail? iform)
  (quasiquote (vector-ref (unquote iform) 6)))

(define-macro
  ($receive.set-lvars! iform lvars)
  (quasiquote
    (vector-set! (unquote iform) 1 (unquote lvars))))

(define-macro
  ($receive.set-vals! iform body)
  (quasiquote
    (vector-set! (unquote iform) 4 (unquote body))))

(define-macro
  ($receive.set-body! iform body)
  (quasiquote
    (vector-set! (unquote iform) 5 (unquote body))))

(define-macro
  ($receive.set-tail?! iform tail?)
  (quasiquote
    (vector-set! (unquote iform) 6 (unquote tail?))))

(define $INSN-NUM 22)

(define-macro
  (tag iform)
  (quasiquote (vector-ref (unquote iform) 0)))

(define-macro
  (tag? iform t)
  (quasiquote
    (= (unquote t) (tag (unquote iform)))))

(define-macro
  (set-tag! iform t)
  (quasiquote
    (vector-set! (unquote iform) 0 (unquote t))))

(define-macro
  (make-lvar sym)
  (quasiquote ($lvar (unquote sym) (quote ()) 0 0)))

(define-macro
  ($lvar.ref-count++! lvar)
  (quasiquote
    ($lvar.set-ref-count!
      (unquote lvar)
      (+ ($lvar.ref-count (unquote lvar)) 1))))

(define-macro
  ($lvar.ref-count--! lvar)
  (quasiquote
    ($lvar.set-ref-count!
      (unquote lvar)
      (- ($lvar.ref-count (unquote lvar)) 1))))

(define-macro
  ($lvar.set-count++! lvar)
  (quasiquote
    ($lvar.set-set-count!
      (unquote lvar)
      (+ 1 ($lvar.set-count (unquote lvar))))))

(define-macro
  ($local-ref.copy dst src)
  (quasiquote
    ($local-ref.set-lvar!
      (unquote dst)
      ($local-ref.lvar (unquote src)))))

(define-macro
  ($library.add-import-syms! library import-syms)
  (quasiquote
    ($library.set-import-syms!
      (unquote library)
      (append2
        ($library.import-syms (unquote library))
        (unquote import-syms)))))

(define-macro
  ($library.add-import! library import)
  (quasiquote
    ($library.set-import!
      (unquote library)
      (append2
        ($library.import (unquote library))
        (list (unquote import))))))

(define
  (make-empty-library name)
  ($library
    name
    (quote ())
    (quote ())
    (quote ())
    (quote ())
    (quote ())
    #f))

(define
  top-level-library
  (make-empty-library (quote (top level))))

(define
  (parse-lambda-vars vars)
  (cond ((pair? vars)
         (let loop
              ((p vars) (ret (quote ())))
              (cond ((null? p) (list #f vars))
                    ((pair? p) (loop (cdr p) (cons (car p) ret)))
                    (else (list #t (reverse (cons p ret)))))))
        ((null? vars) (list #f (quote ())))
        (else (list #t (list vars)))))

(define
  (parse-lambda-args formals)
  (let loop
       ((formals formals) (args (quote ())))
       (cond ((null? formals)
              (values (reverse args) (length args) 0))
             ((pair? formals)
              (loop (cdr formals) (cons (car formals) args)))
             (else (values
                     (reverse (cons formals args))
                     (length args)
                     1)))))

(define-macro
  ($src x sexp)
  (quasiquote
    (set-source-info!
      (make-list-with-src-slot (unquote x))
      (source-info (unquote sexp)))))

(define
  (pass1/expand sexp)
  (define
    (lambda-has-define? sexp)
    (and (not (null? (cddr sexp)))
         (pair? (third sexp))
         (eq? (car (third sexp)) (quote define))))
  (define
    (let1->let sexp)
    (quasiquote
      (let (((unquote (second sexp)) (unquote (third sexp))))
           (unquote-splicing (cdddr sexp)))))
  (define
    (expand-let vars body)
    (let1 expanded-vars
          (fold-right
            (lambda
              (x y)
              (cons (list (first x) (pass1/expand (second x)))
                    y))
            (quote ())
            vars)
          (quasiquote
            (let (unquote expanded-vars)
                 (unquote-splicing (pass1/expand body))))))
  (cond ((pair? sexp)
         (case (first sexp)
               ((quote) sexp)
               ((define-macro) sexp)
               ((define)
                (if (define-is-lambda? sexp)
                    (pass1/expand (define->lambda sexp))
                    ($src ($map1 (lambda (s) (pass1/expand s)) sexp)
                          sexp)))
               ((let1)
                ($src (pass1/expand (let1->let sexp)) sexp))
               ((let)
                (if (let-is-named? sexp)
                    ($src (pass1/expand (named-let->letrec sexp))
                          sexp)
                    ($src (expand-let (second sexp) (cddr sexp))
                          sexp)))
               ((let*)
                ($src (pass1/expand (let*->let sexp)) sexp))
               ((cond)
                ($src (pass1/expand (cond->if sexp)) sexp))
               ((lambda)
                (cond ((lambda-has-define? sexp)
                       ($src (pass1/expand
                               ($src (internal-define->letrec sexp) sexp))
                             sexp))
                      (else ($src (append!
                                    (list (quote lambda) (cadr sexp))
                                    (pass1/expand (cddr sexp)))
                                  sexp))))
               ((when)
                (match sexp
                       (((quote when) pred body . more)
                        ($src (pass1/expand
                                (quasiquote
                                  (cond ((unquote pred)
                                         (unquote body)
                                         (unquote-splicing more)))))
                              sexp))
                       (else (syntax-error "malformed when"))))
               ((unless)
                (match sexp
                       (((quote unless) pred body . more)
                        ($src (pass1/expand
                                (quasiquote
                                  (cond ((not (unquote pred))
                                         (unquote body)
                                         (unquote-splicing more)))))
                              sexp))
                       (else (syntax-error "malformed unless"))))
               ((aif)
                ($src (pass1/expand (aif->let sexp)) sexp))
               ((case)
                ($src (pass1/expand (case->cond sexp)) sexp))
               ((quasiquote) (expand-quasiquote (cadr sexp) 0))
               (else sexp)))
        (else sexp)))

(define
  (define-is-lambda? sexp)
  (pair? (cadr sexp)))

(define
  (conditions->if conditions)
  (if (null? (cdr conditions))
      (car conditions)
      (list (quote if)
            (car conditions)
            (conditions->if (cdr conditions))
            #f)))

(define
  (find-serial-from-head pred lst)
  (let loop
       ((found (quote ())) (lst lst))
       (cond ((null? lst)
              (if (null? found)
                  (list (quote ()) lst)
                  (values found (quote ()))))
             ((pred (car lst))
              (loop (append2 found (list (car lst))) (cdr lst)))
             (else (if (null? found)
                       (list (quote ()) lst)
                       (list found lst))))))

(define
  (internal-define->letrec sexp)
  (let* ((body (cddr sexp))
         (args (second sexp))
         (ret (find-serial-from-head
                (lambda
                  (s)
                  (and (pair? s) (eq? (quote define) (car s))))
                body))
         (defines (first ret))
         (rest (second ret))
         (letrec-body
           ($src (quasiquote
                   (letrec
                     (unquote
                       (map (lambda (d) (list (second d) (third d)))
                            (map pass1/expand defines)))
                     (unquote-splicing rest)))
                 sexp)))
        ($src (quasiquote
                (lambda (unquote args) (unquote letrec-body)))
              sexp)))

(define
  (define->lambda sexp)
  (let ((args (cadr sexp)) (body (cddr sexp)))
       (quasiquote
         (define
           (unquote (car args))
           (unquote
             ($src (append! (list (quote lambda) (cdr args)) body)
                   sexp))))))

(define
  (unless->cond sexp)
  (quasiquote
    (cond ((not (unquote (cadr sexp)))
           (unquote-splicing (cddr sexp))))))

(define
  (let*->let sexp)
  (let ((args (cadr sexp)) (body (cddr sexp)))
       (car (let loop
                 ((args args))
                 (if (null? args)
                     body
                     ($src (quasiquote
                             ((let ((unquote (car args)))
                                   (unquote-splicing (loop (cdr args))))))
                           sexp))))))

(define
  (cond->if sexp)
  (define
    (make-if test then else)
    (let ((then (if (> (length then) 1)
                    (cons (quote begin) then)
                    (car then))))
         (quasiquote
           (if (unquote test) (unquote then) (unquote else)))))
  (let loop
       ((clauses (cdr sexp)))
       (if (null? clauses)
           (quote #f)
           (cond ((and (null? (cdr clauses))
                       (eq? (quote else) (caar clauses)))
                  (if (> (length (cdar clauses)) 1)
                      (cons (quote begin) (cdar clauses))
                      (cadar clauses)))
                 ((and (= 3 (length (car clauses)))
                       (eq? (quote =>) (cadar clauses)))
                  (let ((tmp (gensym)))
                       (quasiquote
                         (let (((unquote tmp) (unquote (caar clauses))))
                              (if (unquote tmp)
                                  ((unquote (caddar clauses)) (unquote tmp))
                                  (unquote (loop (cdr clauses))))))))
                 ((= 1 (length (car clauses)))
                  (let ((tmp (gensym)))
                       (quasiquote
                         (let (((unquote tmp) (unquote (caar clauses))))
                              (if (unquote tmp)
                                  (unquote tmp)
                                  (unquote (loop (cdr clauses))))))))
                 (else (make-if
                         (caar clauses)
                         (cdar clauses)
                         (loop (cdr clauses))))))))

(define
  (case->cond sexp)
  (define
    (expand-clauses clauses tmpname)
    (let loop
         ((clauses clauses))
         (if (null? clauses)
             (quote ())
             (if (eq? (quote else) (caar clauses))
                 clauses
                 (if (= 1 (length (caar clauses)))
                     (cons (quasiquote
                             ((eqv? (quote (unquote (caaar clauses)))
                                    (unquote tmpname))
                              (unquote-splicing (cdar clauses))))
                           (loop (cdr clauses)))
                     (cons (quasiquote
                             ((memv (unquote tmpname)
                                    (quote (unquote (caar clauses))))
                              (unquote-splicing (cdar clauses))))
                           (loop (cdr clauses))))))))
  (let* ((pred (cadr sexp))
         (clauses (cddr sexp))
         (tmpname (gensym))
         (expanded-clauses
           (expand-clauses clauses tmpname)))
        (quasiquote
          (let (((unquote tmpname) (unquote pred)))
               (cond (unquote-splicing expanded-clauses))))))

(define
  (named-let->let sexp)
  (let* ((name (cadr sexp))
         (args (caddr sexp))
         (vars ($map1 car args))
         (vals ($map1 cadr args))
         (temp-name (gensym))
         (body (replace-proc (cdddr sexp) name temp-name)))
        (quasiquote
          (let1 (unquote temp-name)
                (quote ())
                (set! (unquote temp-name)
                      (lambda (unquote vars) (unquote-splicing body)))
                ((unquote temp-name) (unquote-splicing vals))))))

(define
  (named-let->letrec sexp)
  (let* ((name (cadr sexp))
         (args (caddr sexp))
         (vars ($map1 car args))
         (vals ($map1 cadr args))
         (body (cdddr sexp))
         (lambda-body
           ($src (quasiquote
                   (lambda (unquote vars) (unquote-splicing body)))
                 sexp)))
        ($src (quasiquote
                (letrec
                  (((unquote name) (unquote lambda-body)))
                  ((unquote name) (unquote-splicing vals))))
              sexp)))

(define
  (replace-proc sexp a b)
  (cond ((pair? sexp)
         (if (eq? (car sexp) a) (set-car! sexp b) #f)
         ($map1 (lambda (s) (replace-proc s a b)) sexp))
        (else sexp)))

(define
  (aif->let sexp)
  (quasiquote
    (let ((it (unquote (cadr sexp))))
         (if it
             (unquote (caddr sexp))
             (unquote (cadddr sexp))))))

(define
  (let-is-named? sexp)
  (symbol? (cadr sexp)))

(define
  (expand-quasiquote x level)
  (define
    (finalize-quasiquote mode arg)
    (cond ((eq? mode (quote quote))
           (list (quote quote) arg))
          ((eq? mode (quote unquote)) arg)
          ((eq? mode (quote unquote-splicing))
           (error ",@ in invalid context" arg))
          (else (cons mode arg))))
  (define
    (descend-quasiquote x level return)
    (cond ((vector? x)
           (descend-quasiquote-vector x level return))
          ((not (pair? x)) (return (quote quote) x))
          ((interesting-to-quasiquote? x (quote quasiquote))
           (descend-quasiquote-pair x (+ level 1) return))
          ((interesting-to-quasiquote? x (quote unquote))
           (cond ((= level 0) (return (quote unquote) (cadr x)))
                 (else (descend-quasiquote-pair x (- level 1) return))))
          ((interesting-to-quasiquote?
             x
             (quote unquote-splicing))
           (cond ((= level 0)
                  (return (quote unquote-splicing) (cadr x)))
                 (else (descend-quasiquote-pair x (- level 1) return))))
          (else (descend-quasiquote-pair x level return))))
  (define
    (descend-quasiquote-pair x level return)
    (descend-quasiquote
      (car x)
      level
      (lambda
        (car-mode car-arg)
        (descend-quasiquote
          (cdr x)
          level
          (lambda
            (cdr-mode cdr-arg)
            (cond ((and (eq? car-mode (quote quote))
                        (eq? cdr-mode (quote quote)))
                   (return (quote quote) x))
                  ((eq? car-mode (quote unquote-splicing))
                   (cond ((and (eq? cdr-mode (quote quote))
                               (null? cdr-arg))
                          (return (quote unquote) car-arg))
                         (else (return
                                 (quote append2)
                                 (list car-arg
                                       (finalize-quasiquote
                                         cdr-mode
                                         cdr-arg))))))
                  (else (return
                          (quote cons)
                          (list (finalize-quasiquote car-mode car-arg)
                                (finalize-quasiquote cdr-mode cdr-arg))))))))))
  (define
    (descend-quasiquote-vector x level return)
    (descend-quasiquote
      (vector->list x)
      level
      (lambda
        (mode arg)
        (if (equal? mode (quote quote))
            (return (quote quote) x)
            (return
              (quote list->vector)
              (list (finalize-quasiquote mode arg)))))))
  (define
    (interesting-to-quasiquote? x marker)
    (and (pair? x) (eq? (car x) marker)))
  (descend-quasiquote x level finalize-quasiquote))

(define
  (pass1/lib-refer->iform symbol library)
  (let1 import-syms
        ($library.import-syms library)
        (aif (find10
               (lambda (import) (eq? symbol (first import)))
               import-syms)
             ($global-ref (second it) (third it))
             ($global-ref ($library.name library) symbol))))

(define
  (pass1/lib-assign->iform symbol library val)
  (let1 import-syms
        ($library.import-syms library)
        (aif (find10
               (lambda (import) (eq? symbol (first import)))
               import-syms)
             ($global-assign (second it) (third it) val)
             ($global-assign
               ($library.name library)
               symbol
               val))))

(define
  (pass1/refer->iform symbol library lvars)
  (acond ((find10
            (lambda (lvar) (eq? ($lvar.sym lvar) symbol))
            lvars)
          ($lvar.ref-count++! it)
          ($local-ref it))
         ((pass1/lib-refer->iform symbol library) it)
         (#t ($global-ref (quote (top level)) symbol))))

(define
  (pass1/assign->iform sexp library lvars tail?)
  (let* ((symbol (second sexp))
         (val (third sexp))
         (iform (pass1/sexp->iform val library lvars tail?)))
        (acond ((find10
                  (lambda (lvar) (eq? ($lvar.sym lvar) symbol))
                  lvars)
                ($lvar.set-count++! it)
                ($local-assign it iform))
               ((pass1/lib-assign->iform symbol library iform)
                it)
               (#t
                ($global-assign (quote (top level)) symbol iform)))))

(define
  (pass1/body->iform body library lvars tail?)
  (let1 iforms
        ($map1-with-tail
          (lambda
            (b t?)
            (pass1/sexp->iform
              (pass1/expand b)
              library
              lvars
              (and t? tail?)))
          body)
        (if (= 1 (length iforms))
            (car iforms)
            ($seq iforms tail?))))

(define
  ($take lis k)
  (if (< (length lis) k)
      lis
      (let recur
           ((lis lis) (k k))
           (if (zero? k)
               (quote ())
               (cons (car lis) (recur (cdr lis) (- k 1)))))))

(define
  ($drop x i)
  (let loop
       ((n i) (l x))
       (if (<= n 0) l (loop (- n 1) (cdr l)))))

(define
  (pass1/lambda->iform name sexp library lvars)
  (define
    (dotpair->list p)
    (let loop
         ((p p))
         (cond ((and (not (pair? p)) (not (null? p)))
                (cons p (quote ())))
               ((null? p) (quote ()))
               (else (cons (car p) (loop (cdr p)))))))
  (let* ((vars (second sexp))
         (body (cddr sexp))
         (parsed-vars (parse-lambda-vars vars))
         (optional-arg? (first parsed-vars))
         (vars (second parsed-vars))
         (this-lvars
           ($map1 (lambda (sym) ($lvar sym #f 0 0)) vars)))
        ($lambda
          (cons (source-info sexp)
                (cons (quote name) (dotpair->list (second sexp))))
          name
          (if optional-arg?
              (- (length vars) 1)
              (length vars))
          (if optional-arg? 1 0)
          this-lvars
          (pass1/body->iform
            body
            library
            (append2 this-lvars lvars)
            #t)
          (quote ())
          (quote ()))))

(define libraries (make-eq-hashtable))

(define-macro
  (make-identifier alias libname name)
  (quasiquote
    (list (unquote alias)
          (unquote libname)
          (unquote name))))

(define
  (copy-identifier i)
  (list (first i) (second i) (third i)))

(define
  (library-name form)
  (remove-tail (second form) pair?))

(define
  (pass1/and->iform sexp library lvars tail?)
  (define
    (rec s)
    (match s
           (() ($const #t))
           ((s)
            (pass1/sexp->iform
              (pass1/expand s)
              library
              lvars
              tail?))
           ((e . more)
            ($if (pass1/sexp->iform
                   (pass1/expand e)
                   library
                   lvars
                   tail?)
                 (rec more)
                 ($it)))
           (else (error "syntax-error: malformed and:" sexp))))
  (rec (cdr sexp)))

(define
  (pass1/or->iform sexp library lvars tail?)
  (define
    (rec s)
    (match s
           (() ($const #f))
           ((s)
            (pass1/sexp->iform
              (pass1/expand s)
              library
              lvars
              tail?))
           ((e . more)
            ($if (pass1/sexp->iform
                   (pass1/expand e)
                   library
                   lvars
                   tail?)
                 ($it)
                 (rec more)))
           (else (error "syntax-error: malformed or:" sexp))))
  (rec (cdr sexp)))

(define
  (pass1/library->iform sexp library lvars)
  (define
    (get-identifier symbol libname imports)
    (aif (find10
           (lambda (import) (eq? symbol (first import)))
           imports)
         (copy-identifier it)
         (make-identifier symbol libname symbol)))
  (define
    (get-rename-identifier
      rename-set
      libname
      imports)
    (aif (find10
           (lambda
             (import)
             (eq? (first rename-set) (first import)))
           imports)
         (let1 identifier
               (copy-identifier it)
               (set-car! identifier (second rename-set))
               identifier)
         (make-identifier
           (second rename-set)
           libname
           (first rename-set))))
  (define
    (extract-exports imports libname form)
    (let loop
         ((export (cdr form)) (ret (quote ())))
         (cond ((null? export) ret)
               ((and (pair? (car export))
                     (eq? (caar export) (quote rename)))
                (loop (cdr export)
                      (append2
                        ret
                        ($map1 (lambda
                                 (p)
                                 (get-rename-identifier p libname imports))
                               (cdar export)))))
               (else (loop (cdr export)
                           (cons (get-identifier (car export) libname imports)
                                 ret))))))
  (let1 lib
        ($library
          (library-name sexp)
          (quote ())
          (quote ())
          (quote ())
          (quote ())
          (quote ())
          #f)
        ($library.set-import!
          lib
          (pass1/import->iform (fourth sexp) lib))
        ($library.set-export-syms!
          lib
          (extract-exports
            ($library.import-syms lib)
            ($library.name lib)
            (third sexp)))
        ($library.set-body! lib (cddddr sexp))
        (hashtable-set!
          libraries
          ($library.name lib)
          lib)
        lib))

(define
  (pass1/import->iform sexp library)
  (define
    (library-name form)
    (libname->symbol (remove-tail form pair?)))
  (define
    (parse-level form)
    (cond ((symbol? form)
           (case form
                 ((expand) 1)
                 ((run) 0)
                 (else (error "unknown for"))))
          ((and (pair? form)
                (= (length form) 2)
                (eq? (first form) (quote meta)))
           (second form))
          (else (error "unknown level on meta"))))
  (define
    (import-iter form level)
    (case (first form)
          ((for)
           (import-iter
             (second form)
             (parse-level (third form))))
          ((only)
           (let1 only-binds
                 (cddr form)
                 (acond ((hashtable-ref
                           libraries
                           (library-name (second form))
                           #f)
                         ($library.add-import-syms!
                           library
                           ($filter-map1
                             (lambda
                               (x)
                               (if (memq (car x) only-binds)
                                   (copy-identifier x)
                                   #f))
                             ($library.export-syms it)))
                         ($import-spec ($library.name it) level))
                        (#t
                         (error "library "
                                (library-name (second form))
                                " not found")))))
          ((except)
           (let1 except-binds
                 (cddr form)
                 (acond ((hashtable-ref
                           libraries
                           (library-name (second form))
                           #f)
                         ($library.add-import-syms!
                           library
                           ($filter-map1
                             (lambda
                               (x)
                               (if (memq (car x) except-binds)
                                   #f
                                   (copy-identifier x)))
                             ($library.export-syms it)))
                         ($import-spec ($library.name it) level))
                        (#t
                         (error "library "
                                (library-name (second form))
                                " not found")))))
          ((rename)
           (let1 renames
                 (cddr form)
                 (acond ((hashtable-ref
                           libraries
                           (library-name (second form))
                           #f)
                         ($library.add-import-syms!
                           library
                           ($filter-map1
                             (lambda
                               (x)
                               (aif (find10
                                      (lambda
                                        (rename)
                                        (eq? (first x) (first rename)))
                                      renames)
                                    (make-identifier
                                      (second it)
                                      (second x)
                                      (third x))
                                    (copy-identifier x)))
                             ($library.export-syms it)))
                         ($import-spec ($library.name it) level))
                        (#t
                         (error "library "
                                (library-name (second form))
                                " not found")))))
          ((prefix)
           (let1 prefix
                 (symbol->string (third form))
                 (acond ((hashtable-ref
                           libraries
                           (library-name (second form))
                           #f)
                         ($library.add-import-syms!
                           library
                           ($filter-map1
                             (lambda
                               (x)
                               (make-identifier
                                 (string->symbol
                                   (string-append
                                     prefix
                                     (symbol->string (first x))))
                                 (second x)
                                 (third x)))
                             ($library.export-syms it)))
                         ($import-spec ($library.name it) level))
                        (#t
                         (error "library "
                                (library-name (second form))
                                " not found")))))
          (else (acond ((hashtable-ref libraries (library-name form) #f)
                        ($library.add-import-syms!
                          library
                          ($map1 copy-identifier ($library.export-syms it)))
                        ($import-spec ($library.name it) level))
                       (#t
                        (error "library "
                               (library-name form)
                               " not found"))))))
  ($import
    ($map1 (lambda (i) (import-iter i 0)) (cdr sexp))))

(define
  (pass1/macroexpand sexp)
  (let1 proc
        (first sexp)
        (acond ((and (symbol? proc)
                     (assoc proc ($library.macro top-level-library)))
                (pass1/expand (vm/apply (cdr it) (cdr sexp))))
               (#t sexp))))

(define
  (pass1/sexp->iform sexp library lvars tail?)
  (define
    (sexp->iform sexp)
    (pass1/sexp->iform
      (pass1/expand sexp)
      library
      lvars
      tail?))
  (define
    (operator-nargs->iform op tag)
    (let* ((args (cdr sexp)) (len (length args)))
          (cond ((= 0 len)
                 (case op
                       ((+) (sexp->iform 0))
                       ((*) (sexp->iform 1))
                       (else (error op " got too few argment"))))
                ((= 1 len)
                 (case op
                       ((-) (sexp->iform (* -1 (car args))))
                       ((/)
                        (sexp->iform
                          (quasiquote (/ 1 (unquote (car args))))))
                       (else (sexp->iform (car args)))))
                ((= 2 len)
                 ($asm tag
                       (list (sexp->iform (first args))
                             (sexp->iform (second args)))))
                (else (let1 args-iform
                            ($map1 sexp->iform args)
                            (fold (lambda (x y) ($asm tag (list y x)))
                                  (car args-iform)
                                  (cdr args-iform)))))))
  (define
    (call-1arg->iform tag)
    ($asm tag
          (list (pass1/sexp->iform
                  (pass1/expand (second sexp))
                  library
                  lvars
                  tail?))))
  (define
    (call-1arg-optional->iform tag)
    ($asm tag
          (list (pass1/sexp->iform
                  (if (null? (cdr sexp))
                      (quote ())
                      (pass1/expand (second sexp)))
                  library
                  lvars
                  tail?))))
  (define
    (call-2args->iform tag)
    ($asm tag
          (list (pass1/sexp->iform
                  (pass1/expand (second sexp))
                  library
                  lvars
                  tail?)
                (pass1/sexp->iform
                  (pass1/expand (third sexp))
                  library
                  lvars
                  tail?))))
  (define
    (call-3args->iform tag)
    ($asm tag
          (list (pass1/sexp->iform
                  (pass1/expand (second sexp))
                  library
                  lvars
                  tail?)
                (pass1/sexp->iform
                  (pass1/expand (third sexp))
                  library
                  lvars
                  tail?)
                (pass1/sexp->iform
                  (pass1/expand (fourth sexp))
                  library
                  lvars
                  tail?))))
  (define
    (numcmp->iform operator args tag)
    (let1 len
          (length args)
          (cond ((> 2 len)
                 (error operator " got too few argument"))
                ((= 2 len)
                 ($asm tag
                       (list (sexp->iform (first args))
                             (sexp->iform (second args)))))
                (else (sexp->iform
                        (conditions->if (apply-each-pair operator args)))))))
  (cond ((pair? sexp)
         (case (car sexp)
               ((cons)
                ($asm (quote CONS)
                      ($map1 sexp->iform (cdr sexp))))
               ((and)
                (pass1/and->iform sexp library lvars tail?))
               ((or) (pass1/or->iform sexp library lvars tail?))
               ((begin)
                (pass1/body->iform
                  (pass1/expand (cdr sexp))
                  library
                  lvars
                  tail?))
               ((values)
                ($asm (quote VALUES)
                      ($map1 sexp->iform (cdr sexp))))
               ((define)
                (match sexp
                       (((quote define) name ((quote lambda) . more))
                        (let1 closure
                              (make-list-with-src-slot
                                (cons (quote lambda) more))
                              (set-source-info!
                                closure
                                (source-info (third sexp)))
                              ($define
                                ($library.name library)
                                name
                                (pass1/lambda->iform
                                  name
                                  closure
                                  library
                                  lvars))))
                       (else ($define
                               ($library.name library)
                               (second sexp)
                               (sexp->iform (third sexp))))))
               ((define-macro)
                (if (pair? (second sexp))
                    ($library.set-macro!
                      library
                      (acons (caadr sexp)
                             (compile-partial
                               (quasiquote
                                 (lambda
                                   (unquote (cdadr sexp))
                                   (unquote (third sexp))))
                               library)
                             ($library.macro library)))
                    ($library.set-macro!
                      library
                      (acons (second sexp)
                             (compile-partial (third sexp))
                             ($library.macro library))))
                ($undef))
               ((receive)
                (match sexp
                       (((quote receive) vars vals . body)
                        (receive
                          (vars reqargs optarg)
                          (parse-lambda-args vars)
                          (let1 this-lvars
                                ($map1 (lambda (sym) ($lvar sym #f 0 0)) vars)
                                ($receive
                                  this-lvars
                                  reqargs
                                  optarg
                                  (sexp->iform vals)
                                  (pass1/body->iform
                                    (pass1/expand body)
                                    library
                                    (append2 this-lvars lvars)
                                    tail?)
                                  tail?))))
                       (else (syntax-error "malformed receive"))))
               ((let)
                (let* ((vars ($map1 car (second sexp)))
                       (vals ($map1 cadr (second sexp)))
                       (body (cddr sexp))
                       (inits ($map1 sexp->iform vals))
                       (this-lvars
                         (map (lambda (sym init) ($lvar sym init 0 0))
                              vars
                              inits)))
                      ($let (quote let)
                            this-lvars
                            inits
                            (pass1/body->iform
                              (pass1/expand body)
                              library
                              (append2 this-lvars lvars)
                              tail?)
                            tail?
                            (source-info sexp))))
               ((letrec)
                (let* ((vars ($map1 car (second sexp)))
                       (vals ($map1 cadr (second sexp)))
                       (body (cddr sexp))
                       (this-lvars
                         ($map1 (lambda (sym) ($lvar sym ($undef) 0 0))
                                vars))
                       (inits ($map1 (lambda
                                       (x)
                                       (pass1/sexp->iform
                                         x
                                         library
                                         (append2 this-lvars lvars)
                                         tail?))
                                     vals)))
                      (for-each
                        (lambda
                          (lvar init)
                          ($lvar.set-init-val! lvar init))
                        this-lvars
                        inits)
                      ($let (quote rec)
                            this-lvars
                            inits
                            (pass1/body->iform
                              (pass1/expand body)
                              library
                              (append2 this-lvars lvars)
                              tail?)
                            tail?
                            (source-info sexp))))
               ((lambda)
                (pass1/lambda->iform
                  (quote lambda)
                  sexp
                  library
                  lvars))
               ((library)
                (pass1/library->iform sexp library lvars))
               ((import) (pass1/import->iform sexp library))
               ((set!)
                (pass1/assign->iform
                  (quasiquote
                    (set! (unquote (second sexp))
                          (unquote (pass1/expand (third sexp)))))
                  library
                  lvars
                  tail?))
               ((if)
                (let ((test (second sexp)) (then (third sexp)))
                     ($if (pass1/sexp->iform
                            (pass1/expand test)
                            library
                            lvars
                            #f)
                          (pass1/sexp->iform
                            (pass1/expand then)
                            library
                            lvars
                            tail?)
                          (if (null? (cdddr sexp))
                              ($undef)
                              (pass1/sexp->iform
                                (pass1/expand (fourth sexp))
                                library
                                lvars
                                tail?)))))
               ((call/cc)
                ($call-cc (sexp->iform (second sexp)) tail?))
               ((call-with-current-continuation)
                ($call-cc (sexp->iform (second sexp)) tail?))
               ((quote) ($const (second sexp)))
               ((make-vector)
                (if (null? (cddr sexp))
                    ($asm (quote MAKE_VECTOR)
                          (list (pass1/sexp->iform
                                  (pass1/expand (second sexp))
                                  library
                                  lvars
                                  tail?)
                                (pass1/sexp->iform
                                  (pass1/expand (quote ()))
                                  library
                                  lvars
                                  tail?)))
                    (call-2args->iform (quote MAKE_VECTOR))))
               ((+)
                (operator-nargs->iform
                  (quote +)
                  (quote NUMBER_ADD)))
               ((-)
                (operator-nargs->iform
                  (quote -)
                  (quote NUMBER_SUB)))
               ((*)
                (operator-nargs->iform
                  (quote *)
                  (quote NUMBER_MUL)))
               ((/)
                (operator-nargs->iform
                  (quote /)
                  (quote NUMBER_DIV)))
               ((=)
                (numcmp->iform
                  (quote =)
                  (cdr sexp)
                  (quote NUMBER_EQUAL)))
               ((>=)
                (numcmp->iform
                  (quote >=)
                  (cdr sexp)
                  (quote NUMBER_GE)))
               ((>)
                (numcmp->iform
                  (quote >)
                  (cdr sexp)
                  (quote NUMBER_GT)))
               ((<)
                (numcmp->iform
                  (quote <)
                  (cdr sexp)
                  (quote NUMBER_LT)))
               ((<=)
                (numcmp->iform
                  (quote <=)
                  (cdr sexp)
                  (quote NUMBER_LE)))
               ((vector?) (call-1arg->iform (quote VECTOR_P)))
               ((vector-length)
                (call-1arg->iform (quote VECTOR_LENGTH)))
               ((vector-set!)
                (call-3args->iform (quote VECTOR_SET)))
               ((vector-ref)
                (call-2args->iform (quote VECTOR_REF)))
               ((car) (call-1arg->iform (quote CAR)))
               ((cdr) (call-1arg->iform (quote CDR)))
               ((caar) (call-1arg->iform (quote CAAR)))
               ((cadr) (call-1arg->iform (quote CADR)))
               ((cdar) (call-1arg->iform (quote CDAR)))
               ((cddr) (call-1arg->iform (quote CDDR)))
               ((set-car!) (call-2args->iform (quote SET_CAR)))
               ((set-cdr!) (call-2args->iform (quote SET_CDR)))
               ((eq?) (call-2args->iform (quote EQ)))
               ((eqv?) (call-2args->iform (quote EQV)))
               ((equal?) (call-2args->iform (quote EQUAL)))
               ((not) (call-1arg->iform (quote NOT)))
               ((null?) (call-1arg->iform (quote NULL_P)))
               ((pair?) (call-1arg->iform (quote PAIR_P)))
               ((symbol?) (call-1arg->iform (quote SYMBOL_P)))
               ((read) (call-1arg-optional->iform (quote READ)))
               ((read-char)
                (call-1arg-optional->iform (quote READ_CHAR)))
               (else (let1 proc
                           (first sexp)
                           (acond ((and (symbol? proc)
                                        (assoc proc ($library.macro library)))
                                   (sexp->iform
                                     (vm/apply (cdr it) (cdr sexp))))
                                  ((and (symbol? proc)
                                        (find10
                                          (lambda (sym) (eq? (first sym) proc))
                                          ($library.import-syms library)))
                                   (let* ((lib (hashtable-ref
                                                 libraries
                                                 (second it)
                                                 #f))
                                          (mac (assoc (third it)
                                                      ($library.macro lib))))
                                         (if mac
                                             (sexp->iform
                                               (pass1/expand
                                                 (vm/apply
                                                   (cdr mac)
                                                   (cdr sexp))))
                                             ($call (sexp->iform proc)
                                                    ($map1 sexp->iform
                                                           (cdr sexp))
                                                    tail?
                                                    #f))))
                                  (#t
                                   ($call (sexp->iform proc)
                                          ($map1 sexp->iform (cdr sexp))
                                          tail?
                                          #f)))))))
        ((symbol? sexp)
         (pass1/refer->iform sexp library lvars))
        (else ($const sexp))))

(define
  (pretty-iform iform)
  (define labels (quote ()))
  (define
    (indent count)
    (dotimes (i count) (write-char #\space)))
  (define (nl ind) (newline) (indent ind))
  (define
    (lvar->string lvar)
    (format
      "~a[~a ~a]"
      ($lvar.sym lvar)
      ($lvar.ref-count lvar)
      ($lvar.set-count lvar)))
  (define
    (rec ind iform)
    (cond ((tag? iform $CONST)
           (format #t "($CONST ~s)" ($const.val iform)))
          ((tag? iform $UNDEF) (display "($UNDEF)"))
          ((tag? iform $LAMBDA)
           (format
             #t
             "($LAMBDA[~a ~a ~a]"
             ($lambda.name iform)
             (map lvar->string ($lambda.lvars iform))
             ($lambda.flag iform))
           (nl (+ ind 2))
           (rec (+ ind 2) ($lambda.body iform))
           (display ")"))
          ((tag? iform $SEQ)
           (format #t "($SEQ")
           (for-each
             (lambda
               (node)
               (nl (+ ind 2))
               (rec (+ ind 2) node))
             ($seq.body iform))
           (display ")"))
          ((tag? iform $LIBRARY)
           (format
             #t
             "($LIBRARY ~a export [~a] import [~a]"
             ($library.name iform)
             ($library.export-syms iform)
             ($library.import-syms iform))
           (nl (+ ind 2))
           (display ")"))
          ((tag? iform $LOCAL-REF)
           (format
             #t
             "($LOCAL-REF ~a)"
             (lvar->string ($local-ref.lvar iform))))
          ((tag? iform $GLOBAL-REF)
           (format
             #t
             "($GLOBAL-REF ~a ~a)"
             ($global-ref.libname iform)
             ($global-ref.sym iform)))
          ((tag? iform $LOCAL-ASSIGN)
           (format
             #t
             "($LOCAL-ASSIGN ~a"
             (lvar->string ($local-assign.lvar iform)))
           (nl (+ ind 2))
           (rec (+ ind 2) ($local-assign.val iform))
           (display ")"))
          ((tag? iform $GLOBAL-ASSIGN)
           (format
             #t
             "($GLOBAL-ASSIGN ~a ~a)"
             ($global-assign.sym iform)
             ($global-assign.val iform)))
          ((tag? iform $LET)
           (let* ((hdr (format "($LET ("))
                  (xind (+ ind (string-length hdr))))
                 (display hdr)
                 (for-each
                   (lambda
                     (var init)
                     (let1 z
                           (format "(~a " (lvar->string var))
                           (display z)
                           (rec (+ xind (string-length z)) init)
                           (display ")")
                           (nl xind)))
                   ($let.lvars iform)
                   ($let.inits iform))
                 (display ")")
                 (nl (+ ind 2))
                 (rec (+ ind 2) ($let.body iform))
                 (display ")")))
          ((tag? iform $IF)
           (display "($IF ")
           (rec (+ ind 5) ($if.test iform))
           (nl (+ ind 2))
           (rec (+ ind 2) ($if.then iform))
           (nl (+ ind 2))
           (rec (+ ind 2) ($if.else iform))
           (display ")"))
          ((tag? iform $LABEL)
           (cond ((assq iform labels)
                  =>
                  (lambda (p) (format #t "label#~a" (cdr p))))
                 (else (let1 num
                             (length labels)
                             (push! labels (cons iform num))
                             (format #t "($label #~a" num)
                             (nl (+ ind 2))
                             (rec (+ ind 2) ($label.body iform))
                             (display ")")))))
          ((tag? iform $ASM)
           (let1 insn
                 ($asm.insn iform)
                 (format #t "($asm ~a" insn))
           (for-each
             (lambda
               (node)
               (nl (+ ind 2))
               (rec (+ ind 2) node))
             ($asm.args iform))
           (display ")"))
          ((tag? iform $DEFINE)
           (format
             #t
             "($DEFINE ~a:~a"
             ($define.libname iform)
             ($define.sym iform))
           (nl (+ ind 2))
           (rec (+ ind 2) ($define.val iform))
           (display ")"))
          ((tag? iform $CALL-CC)
           (display "($CALL-CC ")
           (rec 0 ($call-cc.proc iform))
           (display ")"))
          ((tag? iform $LABEL)
           (display "($LABEL ")
           (rec 0 ($label.body iform))
           (display ")"))
          ((tag? iform $CALL)
           (let1 pre
                 (cond (($call.tail? iform)
                        =>
                        (lambda (x) "($call[tail] "))
                       (else "($call "))
                 (format #t pre)
                 (format #t "[~a]" ($call.type iform))
                 (rec (+ ind (string-length pre))
                      ($call.proc iform))
                 (for-each
                   (lambda
                     (node)
                     (nl (+ ind 2))
                     (rec (+ ind 2) node))
                   ($call.args iform))
                 (display ")")))
          (else (error "pretty-iform: unknown tag:" (tag iform)))))
  (rec 0 iform)
  (newline))

(define SMALL_LAMBDA_SIZE 12)

(define
  pass2/dispatch-table
  (make-vector $INSN-NUM))

(define
  (pass2/$let iform closures)
  ($let.set-body!
    iform
    (pass2/optimize ($let.body iform) closures))
  ($let.set-inits!
    iform
    ($map1 (lambda (i) (pass2/optimize i closures))
           ($let.inits iform)))
  (let1 o
        (pass2/eliminate-let iform)
        (if (eq? o iform) o (pass2/optimize o closures))))

(define
  (pass2/$receive iform closures)
  ($receive.set-body!
    iform
    (pass2/optimize ($receive.body iform) closures))
  ($receive.set-vals!
    iform
    (pass2/optimize ($receive.vals iform) closures))
  iform)

(define
  (pass2/$local-ref iform closures)
  (pass2/optimize-local-ref iform)
  iform)

(define
  (pass2/$seq iform closures)
  ($seq.set-body!
    iform
    ($map1 (lambda (x) (pass2/optimize x closures))
           ($seq.body iform)))
  iform)

(define
  (pass2/const-inliner iform)
  (let ((insn ($asm.insn iform))
        (args ($asm.args iform)))
       (case insn
             ((NUMBER_ADD)
              (when (and (tag? (first args) $CONST)
                         (tag? (second args) $CONST))
                    (vector-set! iform 0 $CONST)
                    ($const.set-val!
                      iform
                      (+ ($const.val (first args))
                         ($const.val (second args))))))
             ((NUMBER_MUL)
              (when (and (tag? (first args) $CONST)
                         (tag? (second args) $CONST))
                    (vector-set! iform 0 $CONST)
                    ($const.set-val!
                      iform
                      (* ($const.val (first args))
                         ($const.val (second args))))))
             ((NUMBER_MINUS)
              (when (and (tag? (first args) $CONST)
                         (tag? (second args) $CONST))
                    (vector-set! iform 0 $CONST)
                    ($const.set-val!
                      iform
                      (- ($const.val (first args))
                         ($const.val (second args))))))
             (else #f))))

(define
  (pass2/$asm iform closures)
  ($asm.set-args!
    iform
    ($map1 (lambda (x) (pass2/optimize x closures))
           ($asm.args iform)))
  (pass2/const-inliner iform)
  iform)

(define
  (pass2/$lambda iform closures)
  ($lambda.set-body!
    iform
    (pass2/optimize
      ($lambda.body iform)
      (cons iform closures)))
  iform)

(define
  (pass2/$if iform closures)
  (let ((test-c
          (pass2/optimize ($if.test iform) closures))
        (then-c
          (pass2/optimize ($if.then iform) closures))
        (else-c
          (pass2/optimize ($if.else iform) closures)))
       ($if test-c then-c else-c)))

(define
  (pass2/$call iform closures)
  (pass2/collect-call iform closures))

(define (pass2/empty iform closures) iform)

(define
  (pass2/register insn proc)
  (vector-set! pass2/dispatch-table insn proc))

(pass2/register $CONST pass2/empty)

(pass2/register $LAMBDA pass2/$lambda)

(pass2/register $LOCAL-REF pass2/$local-ref)

(pass2/register $LOCAL-ASSIGN pass2/empty)

(pass2/register $GLOBAL-ASSIGN pass2/empty)

(pass2/register $GLOBAL-REF pass2/empty)

(pass2/register $SEQ pass2/$seq)

(pass2/register $UNDEF pass2/empty)

(pass2/register $IF pass2/$if)

(pass2/register $ASM pass2/$asm)

(pass2/register $DEFINE pass2/empty)

(pass2/register $CALL pass2/$call)

(pass2/register $CALL-CC pass2/empty)

(pass2/register $LET pass2/$let)

(pass2/register $LIST pass2/empty)

(pass2/register $LIBRARY pass2/empty)

(pass2/register $IMPORT pass2/empty)

(pass2/register $IT pass2/empty)

(pass2/register $RECEIVE pass2/$receive)

(define
  (pass2/optimize iform closures)
  ((vector-ref
     pass2/dispatch-table
     (vector-ref iform 0))
   iform
   closures))

(define
  (pv v)
  (let loop
       ((i 0))
       (if (>= i (vector-length v))
           (begin (cond ((vector? (vector-ref v i)) (dd "<iform> "))
                        ((pair? (vector-ref v i)) (dd "<pair> "))
                        (else (dd (vector-ref v i)) (dd " ")))
                  (loop (+ i 1))))))

(define
  (pass2/optimize-local-ref iform)
  (let* ((lvar ($local-ref.lvar iform))
         (init-val ($lvar.init-val lvar)))
        (cond ((and init-val
                    (zero? ($lvar.set-count lvar))
                    (tag? init-val $CONST))
               (set-tag! iform $CONST)
               ($lvar.ref-count--! lvar)
               ($const.set-val! iform ($const.val init-val)))
              ((and init-val
                    (tag? init-val $LOCAL-REF)
                    (zero? ($lvar.set-count ($local-ref.lvar init-val))))
               ($lvar.ref-count--! lvar)
               ($lvar.ref-count++! ($local-ref.lvar init-val))
               ($local-ref.copy iform init-val)
               (pass2/optimize-local-ref iform))
              (else iform))))

(define
  (pass2/eliminate-let iform)
  (let ((vars ($let.lvars iform))
        (inits ($let.inits iform))
        (body ($let.body iform)))
       (for-each pass2/optimize-closure vars inits)
       (let* ((v (pass2/remove-vars vars inits))
              (new-vars (vector-ref v 0))
              (new-inits (vector-ref v 1))
              (removed-inits (vector-ref v 2)))
             (cond ((null? new-vars)
                    (if (null? removed-inits)
                        body
                        ($seq (append2 removed-inits (list body))
                              ($let.tail? iform))))
                   (else ($let.set-lvars! iform new-vars)
                         ($let.set-inits! iform new-inits)
                         ($let.set-body! iform body)
                         (unless
                           (null? removed-inits)
                           (if (tag? body $SEQ)
                               ($seq.set-body!
                                 body
                                 (append2 removed-inits ($seq.body body)))
                               ($let.set-body!
                                 iform
                                 ($seq (append2 removed-inits (list body))
                                       ($let.tail? iform)))))
                         iform)))))

(define
  (iform-copy-zip-lvs orig-lvars lv-alist)
  (let1 new-lvars
        ($map1 (lambda (lv) (make-lvar ($lvar.sym lv)))
               orig-lvars)
        (cons new-lvars
              (foldr2 acons lv-alist orig-lvars new-lvars))))

(define
  (iform-copy-lvar lvar lv-alist)
  (cond ((assq lvar lv-alist) => (lambda (p) (cdr p)))
        (else lvar)))

(define
  (iform-copy iform lv-alist)
  (let1 t
        (tag iform)
        (cond ((= $DEFINE t)
               ($define
                 ($define.libname iform)
                 ($define.sym iform)
                 (iform-copy ($define.val iform) lv-alist)))
              ((= $LOCAL-REF t)
               ($local-ref
                 (iform-copy-lvar
                   ($local-ref.lvar iform)
                   lv-alist)))
              ((= $LOCAL-ASSIGN t)
               ($local-assign
                 (iform-copy-lvar
                   ($local-assign.lvar iform)
                   lv-alist)
                 (iform-copy ($local-assign.val iform) lv-alist)))
              ((= $GLOBAL-REF t)
               ($global-ref
                 ($global-ref.libname iform)
                 ($global-ref.sym iform)))
              ((= $GLOBAL-ASSIGN t)
               ($global-assign
                 ($global-assign.libname iform)
                 ($global-assign.sym iform)
                 (iform-copy ($global-assign.val iform) lv-alist)))
              ((= $CONST t) ($const ($const.val iform)))
              ((= $IF t)
               ($if (iform-copy ($if.test iform) lv-alist)
                    (iform-copy ($if.then iform) lv-alist)
                    (iform-copy ($if.else iform) lv-alist)))
              ((= $LET t)
               (let* ((ret (iform-copy-zip-lvs ($let.lvars iform) lv-alist))
                      (newlvs (car ret))
                      (newalist (cdr ret)))
                     ($let ($let.type iform)
                           newlvs
                           (let1 al
                                 (case ($let.type iform)
                                       ((let) lv-alist)
                                       ((rec) newalist))
                                 ($map1 (lambda (x) (iform-copy x al))
                                        ($let.inits iform)))
                           (iform-copy ($let.body iform) newalist)
                           ($let.tail? iform)
                           ($let.src iform))))
              ((= $LAMBDA t)
               (let* ((ret (iform-copy-zip-lvs
                             ($lambda.lvars iform)
                             lv-alist))
                      (newlvs (car ret))
                      (newalist (cdr ret)))
                     ($lambda
                       ($lambda.src iform)
                       ($lambda.name iform)
                       ($lambda.reqargs iform)
                       ($lambda.optarg iform)
                       newlvs
                       (iform-copy ($lambda.body iform) newalist)
                       ($lambda.flag iform)
                       ($lambda.calls iform))))
              ((= $SEQ t)
               ($seq ($map1 (lambda (x) (iform-copy x lv-alist))
                            ($seq.body iform))
                     ($seq.tail? iform)))
              ((= $CALL t)
               ($call (iform-copy ($call.proc iform) lv-alist)
                      ($map1 (lambda (x) (iform-copy x lv-alist))
                             ($call.args iform))
                      #f
                      ($call.type iform)))
              ((= $ASM t)
               ($asm ($asm.insn iform)
                     ($map1 (lambda (x) (iform-copy x lv-alist))
                            ($asm.args iform))))
              (else iform))))

(define
  (pass2/optimize-closure lvar lambda-node)
  (when (and (zero? ($lvar.set-count lvar))
             (> ($lvar.ref-count lvar) 0)
             (tag? lambda-node $LAMBDA))
        (or (and (= ($lvar.ref-count lvar)
                    (length ($lambda.calls lambda-node)))
                 (let* ((ret (pass2/classify-calls
                               ($lambda.calls lambda-node)
                               lambda-node))
                        (locals (first ret))
                        (recs (second ret))
                        (tail-recs (third ret)))
                       (and (null? recs)
                            (pair? locals)
                            (or (and (null? (cdr locals))
                                     (pass2/local-call-embedder
                                       lvar
                                       lambda-node
                                       (car locals)
                                       tail-recs))
                                (and (null? tail-recs)
                                     (< (iform-count-size-upto
                                          lambda-node
                                          SMALL_LAMBDA_SIZE)
                                        SMALL_LAMBDA_SIZE)
                                     (pass2/local-call-inliner
                                       lvar
                                       lambda-node
                                       locals))))))
            (pass2/local-call-optimizer lvar lambda-node))))

(define-macro
  (sum-items cnt . items)
  (if (null? items)
      cnt
      (let1 target-list?
            (and (pair? (car items))
                 (eq? (caar items) (quote *)))
            (quasiquote
              (let1 s1
                    ((unquote
                       (if target-list? (quote rec-list) (quote rec)))
                     (unquote
                       (if target-list? (cadar items) (car items)))
                     (unquote cnt))
                    (if (>= s1 limit)
                        limit
                        (sum-items s1 (unquote-splicing (cdr items)))))))))

(define
  (iform-count-size-upto iform limit)
  (define
    (rec iform cnt)
    (let1 t
          (tag iform)
          (cond ((= $DEFINE t)
                 (sum-items (+ cnt 1) ($define.val iform)))
                ((= $LOCAL-REF t) (+ cnt 1))
                ((= $GLOBAL-REF t) (+ cnt 1))
                ((= $CONST t) (+ cnt 1))
                ((= $LOCAL-ASSIGN t)
                 (sum-items (+ cnt 1) ($local-assign.val iform)))
                ((= $GLOBAL-ASSIGN t)
                 (sum-items (+ cnt 1) ($global-assign.val iform)))
                ((= $IF t)
                 (sum-items
                   (+ cnt 1)
                   ($if.test iform)
                   ($if.then iform)
                   ($if.else iform)))
                ((= $LET t)
                 (sum-items
                   (+ cnt 1)
                   (* ($let.inits iform))
                   ($let.body iform)))
                ((= $LAMBDA t)
                 (sum-items (+ cnt 1) ($lambda.body iform)))
                ((= $LABEL t)
                 (sum-items cnt ($label.body iform)))
                ((= $SEQ t)
                 (sum-items cnt (* ($seq.body iform))))
                ((= $CALL t)
                 (sum-items
                   (+ cnt 1)
                   ($call.proc iform)
                   (* ($call.args iform))))
                ((= $ASM t)
                 (sum-items (+ cnt 1) (* ($asm.args iform))))
                (else (error "[internal error] iform-count-size-upto: unknown iform tag:"
                             (tag iform))))))
  (define
    (rec-list iform-list cnt)
    (cond ((null? iform-list) cnt)
          ((>= cnt limit) limit)
          (else (rec-list
                  (cdr iform-list)
                  (rec (car iform-list) cnt)))))
  (rec iform 0))

(define
  (adjust-arglist reqargs optarg iargs name)
  (unless
    (argcount-ok? iargs reqargs (> optarg 0))
    (errorf
      "wrong number of arguments: ~a requires ~a, but got ~a at ~a"
      name
      reqargs
      (length iargs)
      (source-info iargs)))
  (if (zero? optarg)
      iargs
      (receive
        (reqs opts)
        (split-at iargs reqargs)
        (append2 reqs (list ($list opts))))))

(define
  (argcount-ok? args reqargs optarg?)
  (let1 nargs
        (length args)
        (or (and (not optarg?) (= nargs reqargs))
            (and optarg? (>= nargs reqargs)))))

(define
  (pass2/local-call-inliner lvar lambda-node calls)
  (define
    (inline-it call-node lambda-node)
    (let1 inlined
          (pass2/expand-inlined-procedure
            lambda-node
            ($call.args call-node))
          (vector-set! call-node 0 $SEQ)
          (if (tag? inlined $SEQ)
              ($seq.set-body! call-node ($seq.body inlined))
              ($seq.set-body! call-node (list inlined)))))
  ($lvar.set-ref-count! lvar 0)
  ($lambda.set-flag! lambda-node (quote dissolved))
  (let loop
       ((calls calls))
       (cond ((null? (cdr calls))
              (inline-it (car calls) lambda-node))
             (else (inline-it
                     (car calls)
                     (iform-copy lambda-node (quote ())))
                   (loop (cdr calls))))))

(define
  (pass2/local-call-embedder
    lvar
    lambda-node
    call
    rec-calls)
  (let ((reqargs ($lambda.reqargs lambda-node))
        (optarg ($lambda.optarg lambda-node))
        (name ($lambda.name lambda-node)))
       ($call.set-args!
         call
         (adjust-arglist
           reqargs
           optarg
           ($call.args call)
           name))
       ($lvar.ref-count--! lvar)
       ($call.set-type! call (quote embed))
       ($call.set-proc! call lambda-node)
       ($lambda.set-flag! lambda-node (quote dissolved))
       (unless
         (null? rec-calls)
         (let1 body
               ($label #f ($lambda.body lambda-node))
               ($lambda.set-body! lambda-node body)
               (dolist
                 (jcall rec-calls)
                 ($lvar.ref-count--! lvar)
                 ($call.set-args!
                   jcall
                   (adjust-arglist
                     reqargs
                     optarg
                     ($call.args jcall)
                     name))
                 ($call.set-proc! jcall call)
                 ($call.set-type! jcall (quote jump)))))))

(define
  (pass2/local-call-optimizer lvar lambda-node)
  (let ((reqargs ($lambda.reqargs lambda-node))
        (optarg ($lambda.optarg lambda-node))
        (name ($lambda.name lambda-node))
        (calls ($lambda.calls lambda-node)))
       (dolist
         (call calls)
         ($call.set-args!
           (car call)
           (adjust-arglist
             reqargs
             optarg
             ($call.args (car call))
             name))
         ($call.set-type! (car call) (quote local)))
       ($lambda.set-calls! lambda-node (quote ()))))

(define
  (pass2/classify-calls call&envs lambda-node)
  (define
    (direct-call? env)
    (let loop
         ((env env))
         (cond ((null? env) #t)
               ((eq? (car env) lambda-node) #t)
               ((eq? ($lambda.flag (car env)) (quote dissolved))
                (loop (cdr env)))
               (else #f))))
  (let loop
       ((call&envs call&envs)
        (local (quote ()))
        (rec (quote ()))
        (trec (quote ())))
       (match call&envs
              (() (list local rec trec))
              (((call . env) . more)
               (case ($call.type call)
                     ((tail-rec)
                      (if (direct-call? env)
                          (loop more local rec (cons call trec))
                          (loop more local (cons call rec) trec)))
                     ((rec) (loop more local (cons call rec) trec))
                     (else (loop more (cons call local) rec trec)))))))

(define
  (pass2/remove-vars vars init-iforms)
  (let loop
       ((vars vars)
        (init-iforms init-iforms)
        (rl (quote ()))
        (ri (quote ()))
        (rr (quote ())))
       (cond ((null? vars)
              (quasiquote
                #((unquote (reverse rl))
                  (unquote (reverse ri))
                  (unquote (reverse rr)))))
             ((and (= 0 ($lvar.ref-count (car vars)))
                   (zero? ($lvar.set-count (car vars))))
              (cond ((tag? (car init-iforms) $LOCAL-REF)
                     ($lvar.ref-count--!
                       ($local-ref.lvar (car init-iforms)))))
              (loop (cdr vars)
                    (cdr init-iforms)
                    rl
                    ri
                    (if (memq (tag (car init-iforms))
                              (quasiquote
                                ((unquote $CONST)
                                 (unquote $LOCAL-REF)
                                 (unquote $LAMBDA))))
                        rr
                        (cons (car init-iforms) rr))))
             (else (loop (cdr vars)
                         (cdr init-iforms)
                         (cons (car vars) rl)
                         (cons (car init-iforms) ri)
                         rr)))))

(define
  (pass2/self-recursing? closure closures)
  (find10 (lambda (c) (eq? closure c)) closures))

(define
  (pass2/classify-local-ref-call
    iform
    closures
    tail?)
  (let1 lvar
        ($local-ref.lvar iform)
        (if (> ($lvar.set-count lvar) 0) (quote local))
        (let1 init-val
              ($lvar.init-val lvar)
              (cond ((and init-val (tag? init-val $LAMBDA))
                     (cond ((pass2/self-recursing? init-val closures)
                            (if tail? (quote tail-rec) (quote rec)))
                           ((= ($lvar.ref-count lvar) 1)
                            ($lvar.ref-count--! lvar)
                            ($lvar.set-init-val! lvar (quote ()))
                            init-val)
                           (else (quote local))))
                    (else #f)))))

(define
  (pass2/expand-inlined-procedure iform iargs)
  (let ((lvars ($lambda.lvars iform))
        (args (pass2/adjust-arglist
                ($lambda.reqargs iform)
                ($lambda.optarg iform)
                iargs
                ($lambda.name iform))))
       (for-each
         (lambda (lv a) ($lvar.set-init-val! lv a))
         lvars
         args)
       ($let (quote let)
             lvars
             args
             ($lambda.body iform)
             #f
             #f)))

(define
  (pass2/argcount-ok? args reqargs optarg?)
  (let1 nargs
        (length args)
        (or (and (not optarg?) (= nargs reqargs))
            (and optarg? (>= nargs reqargs)))))

(define
  (pass2/adjust-arglist reqargs optarg iargs name)
  (unless
    (pass2/argcount-ok? iargs reqargs (> optarg 0))
    (errorf
      "wrong number of arguments: ~a requires ~a, but got ~a at ~a"
      name
      reqargs
      (length iargs)
      (source-info iargs)))
  (if (zero? optarg)
      iargs
      (let* ((ret-args (pass2/split-args iargs reqargs))
             (reqs (car ret-args))
             (opts (cdr ret-args)))
            (append2 reqs (list ($list opts))))))

(define
  (pass2/split-args args reqargs)
  (let loop
       ((i reqargs) (rest args) (r (quote ())))
       (cond ((= i 0) (cons (reverse r) rest))
             ((null? rest)
              (error "given list is too short:" args))
             (else (loop (- i 1) (cdr rest) (cons (car rest) r))))))

(define
  (pass2/collect-call iform closures)
  (cond (($call.type iform) iform)
        (else (let ((proc ($call.proc iform))
                    (args ($call.args iform)))
                   (cond ((tag? proc $LAMBDA)
                          (pass2/optimize
                            (pass2/expand-inlined-procedure proc args)
                            closures))
                         ((and (tag? proc $LOCAL-REF)
                               (pass2/classify-local-ref-call
                                 proc
                                 closures
                                 ($call.tail? iform)))
                          =>
                          (lambda
                            (type)
                            (cond ((vector? type)
                                   ($call.set-proc! iform type)
                                   (let1 o
                                         (pass2/expand-inlined-procedure
                                           type
                                           args)
                                         (pass2/optimize o closures)
                                         o))
                                  ((not type) iform)
                                  (else (let1 lambda-iform
                                              ($lvar.init-val
                                                ($local-ref.lvar proc))
                                              ($call.set-type! iform type)
                                              ($lambda.set-calls!
                                                lambda-iform
                                                (cons (cons iform closures)
                                                      ($lambda.calls
                                                        lambda-iform)))
                                              ($call.set-args!
                                                iform
                                                ($map1 (lambda
                                                         (x)
                                                         (pass2/optimize
                                                           x
                                                           closures))
                                                       args))
                                              iform)))))
                         (else ($call.set-args!
                                 iform
                                 ($map1 (lambda
                                          (x)
                                          (pass2/optimize x closures))
                                        args))
                               iform))))))

(define test-table (make-eq-hashtable))

(define
  (get table a b c)
  (aif (hashtable-ref table a #f)
       (aif (hashtable-ref it b #f)
            (hashtable-ref it c #f)
            #f)
       #f))

(define
  (set table a b c v)
  (aif (hashtable-ref table a #f)
       (let1 it2
             (hashtable-ref it b #f)
             (if it2
                 (hashtable-set! it2 c v)
                 (let1 t
                       (make-eq-hashtable)
                       (hashtable-set! it b t)
                       (hashtable-set! t c v))))
       (let1 t
             (make-eq-hashtable)
             (hashtable-set! table a t)
             (let1 t2
                   (make-eq-hashtable)
                   (hashtable-set! t b t2)
                   (hashtable-set! t2 c v)))))

(define
  (pass3/find-free iform locals can-frees)
  (define
    (rec i l labels-seen)
    (let1 t
          (tag i)
          (cond ((= $CONST t) (quote ()))
                ((= $LET t)
                 (append2
                   ($append-map1
                     (lambda (fm) (rec fm l labels-seen))
                     ($let.inits i))
                   (rec ($let.body i)
                        (append2 l ($let.lvars i))
                        labels-seen)))
                ((= $RECEIVE t)
                 (append2
                   (rec ($receive.vals i) l labels-seen)
                   (rec ($receive.body i)
                        (append2 l ($receive.lvars i))
                        labels-seen)))
                ((= $SEQ t)
                 ($append-map1
                   (lambda (fm) (rec fm l labels-seen))
                   ($seq.body i)))
                ((= $LAMBDA t)
                 (rec ($lambda.body i)
                      (append2 l ($lambda.lvars i))
                      labels-seen))
                ((= $LOCAL-ASSIGN t)
                 (let1 lvar
                       ($local-assign.lvar i)
                       (append2
                         (if (memq lvar can-frees) (list lvar) (quote ()))
                         (rec ($local-assign.val i) l labels-seen))))
                ((= $LOCAL-REF t)
                 (let1 lvar
                       ($local-ref.lvar i)
                       (cond ((memq lvar l) (quote ()))
                             ((memq lvar can-frees) (list lvar))
                             (else (quote ())))))
                ((= $GLOBAL-REF t)
                 (let* ((sym ($global-ref.sym i))
                        (found (find10
                                 (lambda (x) (eq? ($lvar.sym x) sym))
                                 can-frees)))
                       (if found (list found) (quote ()))))
                ((= $UNDEF t) (quote ()))
                ((= $IF t)
                 (append2
                   (rec ($if.test i) l labels-seen)
                   (append2
                     (rec ($if.then i) l labels-seen)
                     (rec ($if.else i) l labels-seen))))
                ((= $ASM t)
                 ($append-map1
                   (lambda (fm) (rec fm l labels-seen))
                   ($asm.args i)))
                ((= $DEFINE t)
                 (rec ($define.val i) l labels-seen))
                ((= $CALL t)
                 (append2
                   ($append-map1
                     (lambda (fm) (rec fm l labels-seen))
                     ($call.args i))
                   (rec ($call.proc i) l labels-seen)))
                ((= $CALL-CC t)
                 (rec ($call-cc.proc i) l labels-seen))
                ((= $GLOBAL-ASSIGN t)
                 (rec ($global-assign.val i) l labels-seen))
                ((= $LIST t)
                 ($append-map1
                   (lambda (fm) (rec fm l labels-seen))
                   ($list.args i)))
                ((= $LABEL t)
                 (if (memq i labels-seen)
                     (quote ())
                     (rec ($label.body i) l (cons i labels-seen))))
                ((= $IMPORT t) (quote ()))
                ((= $LIBRARY t) (quote ()))
                ((= $IT t) (quote ()))
                (else (error "pass3/find-free unknown iform:" (tag i))))))
  (uniq (rec iform locals (quote ()))))

(define
  (pass3/find-sets iform lvars)
  (define
    (rec i)
    (let1 t
          (tag i)
          (cond ((= $CONST t) (quote ()))
                ((= $LET t)
                 (append
                   ($append-map1 rec ($let.inits i))
                   (rec ($let.body i))))
                ((= $RECEIVE t)
                 (append
                   (rec ($receive.vals i))
                   (rec ($receive.body i))))
                ((= $SEQ t) ($append-map1 rec ($seq.body i)))
                ((= $LAMBDA t) (rec ($lambda.body i)))
                ((= $LOCAL-ASSIGN t)
                 (let1 lvar
                       ($local-assign.lvar i)
                       (append
                         (if (memq lvar lvars) (list lvar) (quote ()))
                         (rec ($local-assign.val i)))))
                ((= $LOCAL-REF t) (quote ()))
                ((= $GLOBAL-REF t) (quote ()))
                ((= $UNDEF t) (quote ()))
                ((= $IF t)
                 (append
                   (rec ($if.test i))
                   (rec ($if.then i))
                   (rec ($if.else i))))
                ((= $ASM t) ($append-map1 rec ($asm.args i)))
                ((= $DEFINE t) (rec ($define.val i)))
                ((= $CALL t)
                 (append
                   ($append-map1 rec ($call.args i))
                   (rec ($call.proc i))))
                ((= $CALL-CC t) (rec ($call-cc.proc i)))
                ((= $GLOBAL-ASSIGN t)
                 (rec ($global-assign.val i)))
                ((= $LIST t) ($append-map1 rec ($list.args i)))
                ((= $LABEL t) (quote ()))
                ((= $IMPORT t) (quote ()))
                ((= $LIBRARY t) (quote ()))
                ((= $IT t) (quote ()))
                (else (error "pass3/find-sets unknown iform:" i)))))
  (uniq (rec iform)))

(define
  ($append-map1-sum proc lst)
  (fold (lambda
          (x y)
          (cons (+ (car y) (car x))
                (append2 (cdr y) (cdr x))))
        (quote (0))
        ($map1 proc lst)))

(define
  ($append-map1-with-tail-sum proc lst)
  (fold (lambda
          (x y)
          (cons (+ (car y) (car x))
                (append! (cdr y) (cdr x))))
        (quote (0))
        ($map1-with-tail proc lst)))

(define
  ($append-map1-with-rindex-sum proc lst)
  (fold (lambda
          (x y)
          (cons (+ (car y) (car x))
                (append2 (cdr y) (cdr x))))
        (quote (0))
        ($map1-with-rindex proc lst)))

(define
  ($append-map1-with-index-sum proc lst)
  (fold (lambda
          (x y)
          (cons (+ (car y) (car x))
                (append2 (cdr y) (cdr x))))
        (quote (0))
        ($map1-with-index proc lst)))

(define-macro
  (code-stack-sum . code)
  (quasiquote
    (+ (unquote-splicing
         (map (lambda (x) (quasiquote (car (unquote x))))
              code)))))

(define-macro
  (code-stack code)
  (quasiquote (car (unquote code))))

(define-macro
  (code-body code)
  (quasiquote (cdr (unquote code))))

(define
  (pass3/collect-free frees-here locals frees)
  ($append-map1-sum
    (lambda
      (x)
      (append2
        (pass3/compile-refer x locals frees)
        (quote (PUSH))))
    (reverse frees-here)))

(define
  (pass3/symbol-lookup
    lvar
    locals
    frees
    return-local
    return-free)
  (let next-local
       ((locals locals) (n 0))
       (if (null? locals)
           (let next-free
                ((free frees) (n 0))
                (cond ((null? free)
                       (error "pass3/symbol-lookup bug? Unknown lvar:"
                              lvar))
                      ((eq? (car free) lvar) (return-free n))
                      (else (next-free (cdr free) (+ n 1)))))
           (if (eq? (car locals) lvar)
               (return-local n)
               (next-local (cdr locals) (+ n 1))))))

(define
  (pass3/compile-refer lvar locals frees)
  (pass3/symbol-lookup
    lvar
    locals
    frees
    (lambda
      (n)
      (quasiquote (0 REFER_LOCAL (unquote n))))
    (lambda
      (n)
      (quasiquote (0 REFER_FREE (unquote n))))))

(define
  (pass3/compile-assign lvar locals frees)
  (pass3/symbol-lookup
    lvar
    locals
    frees
    (lambda
      (n)
      (quasiquote (0 ASSIGN_LOCAL (unquote n))))
    (lambda
      (n)
      (quasiquote (0 ASSIGN_FREE (unquote n))))))

(define
  (pass3/make-boxes sets vars)
  ($append-map1-with-rindex
    (lambda
      (x n)
      (if (memq x sets)
          (quasiquote (BOX (unquote n)))
          (quote ())))
    vars))

(define
  pass3/dispatch-table
  (make-vector $INSN-NUM))

(define
  (pass3/register insn proc)
  (vector-set! pass3/dispatch-table insn proc))

(define
  (pass3/$const
    iform
    locals
    frees
    can-frees
    sets
    tail)
  (quasiquote
    (0 CONSTANT (unquote ($const.val iform)))))

(define
  (pass3/$it
    iform
    locals
    frees
    can-frees
    sets
    tail)
  (quasiquote (0)))

(define
  (pass3/$list
    iform
    locals
    frees
    can-frees
    sets
    tail)
  (let1 args
        ($list.args iform)
        (quasiquote
          ((unquote-splicing
             ($append-map1-sum
               (lambda
                 (i)
                 (quasiquote
                   ((unquote-splicing
                      (pass3 i locals frees can-frees sets tail))
                    PUSH)))
               args))
           LIST
           (unquote (length args))))))

(define
  (pass3/$local-ref
    iform
    locals
    frees
    can-frees
    sets
    tail)
  (append2
    (pass3/compile-refer
      ($local-ref.lvar iform)
      locals
      frees)
    (if (memq ($local-ref.lvar iform) sets)
        (quote (INDIRECT))
        (quote ()))))

(define
  (pass3/$local-assign
    iform
    locals
    frees
    can-frees
    sets
    tail)
  (let ((valc (pass3 ($local-assign.val iform)
                     locals
                     frees
                     can-frees
                     sets
                     #f))
        (varc (pass3/compile-assign
                ($local-ref.lvar iform)
                locals
                frees)))
       (quasiquote
         ((unquote (code-stack-sum valc varc))
          (unquote-splicing (code-body valc))
          (unquote-splicing (code-body varc))))))

(define
  top-level-sym
  (string->symbol "top level "))

(define
  (merge-libname-sym libname sym)
  (string->symbol
    (string-append
      (symbol->string libname)
      ":$:"
      (symbol->string sym))))

(define
  (pass3/$global-ref
    iform
    locals
    frees
    can-frees
    sets
    tail)
  (let1 sym
        ($global-ref.sym iform)
        (let next-free
             ((free frees) (n 0))
             (cond ((null? free)
                    (quasiquote
                      (0
                       REFER_GLOBAL
                       (unquote
                         (merge-libname-sym
                           ($global-ref.libname iform)
                           sym)))))
                   ((eq? ($lvar.sym (car free)) sym)
                    (quasiquote (0 REFER_FREE (unquote n))))
                   (else (next-free (cdr free) (+ n 1)))))))

(define
  (pass3/$global-assign
    iform
    locals
    frees
    can-frees
    sets
    tail)
  (let1 sym
        ($global-assign.sym iform)
        (let next-free
             ((free frees) (n 0))
             (cond ((null? free)
                    (quasiquote
                      ((unquote-splicing
                         (pass3 ($global-assign.val iform)
                                locals
                                frees
                                can-frees
                                sets
                                #f))
                       ASSIGN_GLOBAL
                       (unquote
                         (merge-libname-sym
                           ($global-assign.libname iform)
                           sym)))))
                   ((eq? ($lvar.sym (car free)) sym)
                    (quasiquote
                      ((unquote-splicing
                         (pass3 ($global-assign.val iform)
                                locals
                                frees
                                can-frees
                                sets
                                #f))
                       ASSIGN_FREE
                       (unquote n))))
                   (else (next-free (cdr free) (+ n 1)))))))

(define
  (pass3/$seq
    iform
    locals
    frees
    can-frees
    sets
    tail)
  ($append-map1-with-tail-sum
    (lambda
      (i tail?)
      (pass3 i
             locals
             frees
             can-frees
             sets
             (if tail? tail #f)))
    ($seq.body iform)))

(define
  (pass3/$undef
    iform
    locals
    frees
    can-frees
    sets
    tail)
  (quote (0 UNDEF)))

(define
  (pass3/$asm
    iform
    locals
    frees
    can-frees
    sets
    tail)
  (define
    (sum lst)
    (if (null? lst) 0 (+ (car lst) (sum (cdr lst)))))
  (define
    (push-arg i)
    (pass3/compile-arg
      i
      locals
      frees
      can-frees
      sets
      tail))
  (define
    (compile-1arg insn args)
    (quasiquote
      ((unquote-splicing
         (pass3 (first args)
                locals
                frees
                can-frees
                sets
                #f))
       (unquote insn))))
  (define
    (compile-2arg insn args)
    (let ((x (push-arg (first args)))
          (y (pass3 (second args)
                    locals
                    frees
                    can-frees
                    sets
                    #f)))
         (let1 val
               (quasiquote
                 ((unquote (code-stack-sum x y))
                  (unquote-splicing (code-body x))
                  (unquote-splicing (code-body y))
                  (unquote insn)))
               val)))
  (define
    (compile-3arg insn args)
    (let ((x (push-arg (first args)))
          (y (push-arg (second args)))
          (z (pass3 (third args)
                    locals
                    frees
                    can-frees
                    sets
                    #f)))
         (quasiquote
           ((unquote (code-stack-sum x y z))
            (unquote-splicing (code-body x))
            (unquote-splicing (code-body y))
            (unquote-splicing (code-body z))
            (unquote insn)))))
  (define
    (compile-n-args args)
    (if (null? args)
        (quote (0))
        (let1 code
              (let loop
                   ((args args))
                   (if (null? (cdr args))
                       (list (pass3 (car args) locals frees can-frees sets #f))
                       (cons (push-arg (car args)) (loop (cdr args)))))
              (quasiquote
                ((unquote (sum ($map1 car code)))
                 (unquote-splicing ($append-map1 cdr code)))))))
  (let1 args
        ($asm.args iform)
        (case ($asm.insn iform)
              ((NUMBER_ADD)
               (compile-2arg (quote NUMBER_ADD) args))
              ((NUMBER_SUB)
               (compile-2arg (quote NUMBER_SUB) args))
              ((NUMBER_MUL)
               (compile-2arg (quote NUMBER_MUL) args))
              ((NUMBER_DIV)
               (compile-2arg (quote NUMBER_DIV) args))
              ((NUMBER_EQUAL)
               (compile-2arg (quote NUMBER_EQUAL) args))
              ((NUMBER_GE)
               (compile-2arg (quote NUMBER_GE) args))
              ((NUMBER_GT)
               (compile-2arg (quote NUMBER_GT) args))
              ((NUMBER_LT)
               (compile-2arg (quote NUMBER_LT) args))
              ((NUMBER_LE)
               (compile-2arg (quote NUMBER_LE) args))
              ((CONS) (compile-2arg (quote CONS) args))
              ((CAR) (compile-1arg (quote CAR) args))
              ((CDR) (compile-1arg (quote CDR) args))
              ((CAAR) (compile-1arg (quote CAAR) args))
              ((CADR) (compile-1arg (quote CADR) args))
              ((CDAR) (compile-1arg (quote CDAR) args))
              ((CDDR) (compile-1arg (quote CDDR) args))
              ((SET_CDR) (compile-2arg (quote SET_CDR) args))
              ((SET_CAR) (compile-2arg (quote SET_CAR) args))
              ((MAKE_VECTOR)
               (compile-2arg (quote MAKE_VECTOR) args))
              ((VECTOR_LENGTH)
               (compile-1arg (quote VECTOR_LENGTH) args))
              ((VECTOR_SET)
               (compile-3arg (quote VECTOR_SET) args))
              ((VECTOR_REF)
               (compile-2arg (quote VECTOR_REF) args))
              ((EQ) (compile-2arg (quote EQ) args))
              ((EQV) (compile-2arg (quote EQV) args))
              ((EQUAL) (compile-2arg (quote EQUAL) args))
              ((PAIR_P) (compile-1arg (quote PAIR_P) args))
              ((NULL_P) (compile-1arg (quote NULL_P) args))
              ((SYMBOL_P) (compile-1arg (quote SYMBOL_P) args))
              ((VECTOR_P) (compile-1arg (quote VECTOR_P) args))
              ((NOT) (compile-1arg (quote NOT) args))
              ((OPEN_INPUT_FILE)
               (compile-1arg (quote OPEN_INPUT_FILE) args))
              ((READ) (compile-1arg (quote READ) args))
              ((READ_CHAR)
               (compile-1arg (quote READ_CHAR) args))
              ((VALUES)
               (quasiquote
                 ((unquote-splicing (compile-n-args args))
                  VALUES
                  (unquote (length args)))))
              ((APPLY)
               (let ((arg1-c
                       (pass3 (first args)
                              locals
                              frees
                              can-frees
                              sets
                              #f))
                     (arg2-c
                       (pass3 (second args)
                              locals
                              frees
                              can-frees
                              sets
                              #f))
                     (end-of-frame (make-label)))
                    (quasiquote
                      ((unquote (code-stack-sum arg1-c arg2-c))
                       FRAME
                       (unquote (ref-label end-of-frame))
                       (unquote-splicing (code-body arg2-c))
                       PUSH
                       (unquote-splicing (code-body arg1-c))
                       APPLY
                       (unquote end-of-frame)))))
              (else (print "unknown insn on pass3/$asm")))))

(define
  (pass3/$if
    iform
    locals
    frees
    can-frees
    sets
    tail)
  (define
    (push-arg i)
    (let1 code
          (pass3 i locals frees can-frees sets #f)
          (quasiquote
            ((unquote (+ (code-stack code) 1))
             (unquote-splicing (code-body code))
             PUSH))))
  (define
    (pass3/test i)
    (define
      (gen-test1 op)
      (quasiquote
        ((unquote-splicing
           (pass3 (first ($asm.args i))
                  locals
                  frees
                  can-frees
                  sets
                  #f))
         (unquote op))))
    (define
      (gen-test2 op)
      (let ((x (push-arg (first ($asm.args i))))
            (y (pass3 (second ($asm.args i))
                      locals
                      frees
                      can-frees
                      sets
                      #f)))
           (quasiquote
             ((unquote (code-stack-sum x y))
              (unquote-splicing (code-body x))
              (unquote-splicing (code-body y))
              (unquote op)))))
    (if (tag? i $ASM)
        (case ($asm.insn i)
              (else (quasiquote
                      ((unquote-splicing
                         (pass3 i locals frees can-frees sets #f))
                       TEST))))
        (quasiquote
          ((unquote-splicing
             (pass3 i locals frees can-frees sets #f))
           TEST))))
  (let ((thenc (pass3 ($if.then iform)
                      locals
                      frees
                      can-frees
                      sets
                      tail))
        (elsec (pass3 ($if.else iform)
                      locals
                      frees
                      can-frees
                      sets
                      tail))
        (testc (pass3/test ($if.test iform)))
        (end-of-else (make-label))
        (begin-of-else (make-label)))
       (quasiquote
         ((unquote (code-stack-sum thenc elsec testc))
          (unquote-splicing (code-body testc))
          (unquote (ref-label begin-of-else))
          (unquote-splicing (code-body thenc))
          UNFIXED_JUMP
          (unquote (ref-label end-of-else))
          (unquote begin-of-else)
          (unquote-splicing (code-body elsec))
          (unquote end-of-else)))))

(define
  (pass3/$define
    iform
    locals
    frees
    can-frees
    sets
    tail)
  (quasiquote
    ((unquote-splicing
       (pass3 ($define.val iform)
              locals
              frees
              can-frees
              sets
              #f))
     DEFINE_GLOBAL
     (unquote
       (merge-libname-sym
         ($define.libname iform)
         ($define.sym iform))))))

(define
  (pass3/compile-arg
    arg
    locals
    frees
    can-frees
    sets
    tail)
  (cond ((tag? arg $ASM)
         (quasiquote
           ((unquote-splicing
              (pass3 arg locals frees can-frees sets #f))
            PUSH)))
        (else (let* ((code (pass3 arg locals frees can-frees sets #f))
                     (compiled (code-body code)))
                    (quasiquote
                      ((unquote (code-stack code))
                       (unquote-splicing compiled)
                       PUSH))))))

(define
  (pass3/compile-args
    args
    locals
    frees
    can-frees
    sets
    tail)
  ($append-map1-sum
    (lambda
      (arg)
      (pass3/compile-arg
        arg
        locals
        frees
        can-frees
        sets
        tail))
    args))

(define (pass3/merge-insn sexp) sexp)

(define
  (pass3/$call
    iform
    locals
    frees
    can-frees
    sets
    tail)
  (define
    (compile-apply i code)
    (let1 procc
          (code-body code)
          (quasiquote
            ((unquote (code-stack code))
             (unquote-splicing procc)
             (unquote-splicing
               (if tail
                   (list (quote SHIFT) (length ($call.args i)) tail)
                   (quote ())))
             CALL
             (unquote (length ($call.args i)))))))
  (case ($call.type iform)
        ((jump)
         (let ((argsc (pass3/compile-args
                        ($call.args iform)
                        locals
                        frees
                        can-frees
                        sets
                        #f))
               (label ($lambda.body ($call.proc ($call.proc iform)))))
              (quasiquote
                ((unquote (code-stack argsc))
                 (unquote-splicing
                   (list (quote REDUCE) (length ($call.args iform))))
                 (unquote-splicing (code-body argsc))
                 SHIFT
                 (unquote (length ($call.args iform)))
                 (unquote (length ($call.args iform)))
                 UNFIXED_JUMP
                 (unquote label)))))
        ((embed)
         (let* ((label ($lambda.body ($call.proc iform)))
                (body ($label.body label))
                (vars ($lambda.lvars ($call.proc iform)))
                (frees-here
                  (pass3/find-free
                    body
                    vars
                    (append2 locals (append2 frees can-frees))))
                (args-code
                  (pass3/compile-args
                    ($call.args iform)
                    locals
                    frees-here
                    can-frees
                    sets
                    #f))
                (sets-here
                  (append2 (pass3/find-sets body vars) sets))
                (boxes-code (pass3/make-boxes sets-here vars))
                (body-code
                  (pass3 body
                         vars
                         frees-here
                         (%set-union can-frees vars)
                         (%set-union
                           sets-here
                           (set-intersect sets frees-here))
                         (if tail (+ tail (length vars) 2) #f)))
                (free-code
                  (if (> (length frees-here) 0)
                      (pass3/collect-free frees-here locals frees)
                      (quote (0)))))
               (quasiquote
                 ((unquote
                    (code-stack-sum args-code body-code free-code))
                  LET_FRAME
                  (unquote-splicing (code-body free-code))
                  (unquote-splicing
                    (if (> (length frees-here) 0)
                        (list (quote DISPLAY) (length frees-here))
                        (quote ())))
                  (unquote-splicing (code-body args-code))
                  (unquote-splicing boxes-code)
                  (unquote-splicing
                    (list (quote ENTER) (length ($call.args iform))))
                  (unquote label)
                  (unquote-splicing (code-body body-code))
                  (unquote-splicing
                    (list (quote LEAVE) (length ($call.args iform))))))))
        (else (let* ((procc (pass3 ($call.proc iform)
                                   locals
                                   frees
                                   can-frees
                                   sets
                                   #f))
                     (argsc (pass3/compile-args
                              ($call.args iform)
                              locals
                              frees
                              can-frees
                              sets
                              #f))
                     (applyc (compile-apply iform procc))
                     (end-of-frame (make-label)))
                    (quasiquote
                      ((unquote (code-stack-sum argsc applyc))
                       (unquote-splicing
                         (if tail
                             (quote ())
                             (list (quote FRAME) (ref-label end-of-frame))))
                       (unquote-splicing (code-body argsc))
                       (unquote-splicing (code-body applyc))
                       (unquote-splicing
                         (if tail (quote ()) (list end-of-frame)))))))))

(define
  (pass3/$call-cc
    iform
    locals
    frees
    can-frees
    sets
    tail)
  (let ((argc (pass3 ($call-cc.proc iform)
                     locals
                     frees
                     can-frees
                     sets
                     #f))
        (end-of-frame (make-label)))
       (quasiquote
         ((unquote (code-stack argc))
          (unquote-splicing
            (if tail
                (quote ())
                (list (quote FRAME) (ref-label end-of-frame))))
          MAKE_CONTINUATION
          (unquote (if tail 1 0))
          PUSH
          (unquote-splicing (code-body argc))
          (unquote-splicing
            (if tail (list (quote SHIFT) 1 tail) (quote ())))
          CALL
          1
          (unquote-splicing
            (if tail (quote ()) (list end-of-frame)))))))

(define (pass3/$lambda iform locals frees can-frees sets tail) (let* ((vars ($lambda.lvars iform)) (body ($lambda.body iform)) (frees-here (pass3/find-free body vars (append2 locals (append2 frees can-frees)))) (sets-here (append2 (pass3/find-sets body vars) sets)) (boxes-code (pass3/make-boxes sets-here vars)) (body-code (pass3 body vars frees-here (%set-union can-frees vars) (%set-union sets-here (set-intersect sets frees-here)) (length vars))) (free-code (if (> (length frees-here) 0) (pass3/collect-free frees-here locals frees) '(0))) (end-of-closure (make-label))) `(0 ,@(code-body free-code) CLOSURE ,(ref-label end-of-closure) ,(length vars) ,(> ($lambda.optarg iform) 0) ,(length frees-here) ,(+ (code-stack-sum body-code free-code) (length vars) 4) ,($lambda.src iform) ,@boxes-code) ,@(code-body body-code) RETURN ,(length vars) ,end-of-closure))(define
  (pass3/$receive
    iform
    locals
    frees
    can-frees
    sets
    tail)
  (let* ((vars ($receive.lvars iform))
         (body ($receive.body iform))
         (frees-here
           (append2
             (pass3/find-free
               ($receive.vals iform)
               locals
               (append2 locals (append2 frees can-frees)))
             (pass3/find-free
               body
               vars
               (append2 locals (append2 frees can-frees)))))
         (sets-here
           (append2 (pass3/find-sets body vars) sets))
         (boxes-code (pass3/make-boxes sets-here vars))
         (body-code
           (pass3 body
                  vars
                  frees-here
                  (%set-union can-frees vars)
                  (%set-union
                    sets-here
                    (set-intersect sets frees-here))
                  (if tail (+ tail (length vars) 2) #f)))
         (vals-code
           (pass3 ($receive.vals iform)
                  locals
                  frees-here
                  can-frees
                  sets
                  #f))
         (free-code
           (if (> (length frees-here) 0)
               (pass3/collect-free frees-here locals frees)
               (quote (0)))))
        (quasiquote
          ((unquote
             (code-stack-sum body-code vals-code free-code))
           LET_FRAME
           (unquote-splicing (code-body free-code))
           (unquote-splicing
             (if (> (length frees-here) 0)
                 (list (quote DISPLAY) (length frees-here))
                 (quote ())))
           (unquote-splicing (code-body vals-code))
           RECEIVE
           (unquote ($receive.reqargs iform))
           (unquote ($receive.optarg iform))
           (unquote-splicing boxes-code)
           (unquote-splicing
             (list (quote ENTER) (length vars)))
           (unquote-splicing (code-body body-code))
           (unquote-splicing
             (list (quote LEAVE) (length vars)))))))

(define
  (pass3/$let
    iform
    locals
    frees
    can-frees
    sets
    tail)
  (if (eq? ($let.type iform) (quote rec))
      (pass3/letrec
        iform
        locals
        frees
        can-frees
        sets
        tail)
      (let* ((vars ($let.lvars iform))
             (body ($let.body iform))
             (frees-here
               (append2
                 ($append-map1
                   (lambda
                     (i)
                     (pass3/find-free
                       i
                       locals
                       (append2 locals (append2 frees can-frees))))
                   ($let.inits iform))
                 (pass3/find-free
                   body
                   vars
                   (append2 locals (append2 frees can-frees)))))
             (sets-here
               (append2 (pass3/find-sets body vars) sets))
             (boxes-code (pass3/make-boxes sets-here vars))
             (body-code
               (pass3 body
                      vars
                      frees-here
                      (%set-union can-frees vars)
                      (%set-union
                        sets-here
                        (set-intersect sets frees-here))
                      (if tail (+ tail (length vars) 2) #f)))
             (args-code
               (pass3/compile-args
                 ($let.inits iform)
                 locals
                 frees-here
                 can-frees
                 sets
                 tail))
             (free-code
               (if (> (length frees-here) 0)
                   (pass3/collect-free frees-here locals frees)
                   (quote (0)))))
            (quasiquote
              ((unquote
                 (code-stack-sum body-code args-code free-code))
               LET_FRAME
               (unquote-splicing (code-body free-code))
               (unquote-splicing
                 (if (> (length frees-here) 0)
                     (list (quote DISPLAY) (length frees-here))
                     (quote ())))
               (unquote-splicing (code-body args-code))
               (unquote-splicing boxes-code)
               (unquote-splicing
                 (list (quote ENTER) (length vars)))
               (unquote-splicing (code-body body-code))
               (unquote-splicing
                 (list (quote LEAVE) (length vars))))))))

(define
  (pass3/letrec
    iform
    locals
    frees
    can-frees
    sets
    tail)
  (let* ((vars ($let.lvars iform))
         (body ($let.body iform))
         (frees-here
           (append2
             ($append-map1
               (lambda
                 (i)
                 (pass3/find-free
                   i
                   vars
                   (append2 locals (append2 frees can-frees))))
               ($let.inits iform))
             (pass3/find-free
               body
               vars
               (append2 locals (append2 frees can-frees)))))
         (sets-here
           (append
             vars
             (pass3/find-sets body vars)
             ($append-map1
               (lambda (i) (pass3/find-sets i vars))
               ($let.inits iform))
             sets))
         (boxes-code (pass3/make-boxes sets-here vars))
         (body-code
           (pass3 body
                  vars
                  frees-here
                  (%set-union can-frees vars)
                  (%set-union
                    sets-here
                    (set-intersect sets frees-here))
                  (if tail (+ tail (length vars) 2) #f)))
         (args ($let.inits iform))
         (init-code
           ($append-map1
             (lambda (x) (quote (UNDEF PUSH)))
             args))
         (assign-code
           ($append-map1-with-index-sum
             (lambda
               (x n)
               (append
                 (pass3 x
                        vars
                        frees-here
                        (%set-union can-frees vars)
                        (%set-union
                          sets-here
                          (set-intersect sets frees-here))
                        #f)
                 (list (quote ASSIGN_LOCAL) n)))
             args))
         (free-code
           (if (> (length frees-here) 0)
               (pass3/collect-free frees-here locals frees)
               (quote (0)))))
        (quasiquote
          ((unquote
             (code-stack-sum free-code assign-code body-code))
           LET_FRAME
           (unquote-splicing (code-body free-code))
           (unquote-splicing
             (if (> (length frees-here) 0)
                 (list (quote DISPLAY) (length frees-here))
                 (quote ())))
           (unquote-splicing init-code)
           (unquote-splicing boxes-code)
           (unquote-splicing
             (list (quote ENTER) (length vars)))
           (unquote-splicing (code-body assign-code))
           (unquote-splicing (code-body body-code))
           (unquote-splicing
             (list (quote LEAVE) (length vars)))))))

(define
  (pass3/$import
    iform
    locals
    frees
    can-frees
    sets
    tail)
  (define
    (rec i)
    ($append-map1
      (lambda
        (s)
        (let* ((libname ($import-spec.libname s))
               (lib (hashtable-ref libraries libname))
               (end-of-frame (make-label)))
              (quasiquote
                ((unquote-splicing (rec ($library.import lib)))
                 FRAME
                 (unquote (ref-label end-of-frame))
                 IMPORT
                 (unquote libname)
                 (unquote end-of-frame)))))
      ($import.import-specs i)))
  (cons 0 (rec iform)))

(define
  (pass3/$library
    iform
    locals
    frees
    can-frees
    sets
    tail)
  (quasiquote
    (0
     LIBRARY
     (unquote ($library.name iform))
     (unquote iform))))

(pass3/register $CONST pass3/$const)

(pass3/register $LAMBDA pass3/$lambda)

(pass3/register $LOCAL-REF pass3/$local-ref)

(pass3/register
  $LOCAL-ASSIGN
  pass3/$local-assign)

(pass3/register
  $GLOBAL-ASSIGN
  pass3/$global-assign)

(pass3/register $GLOBAL-REF pass3/$global-ref)

(pass3/register $SEQ pass3/$seq)

(pass3/register $UNDEF pass3/$undef)

(pass3/register $IF pass3/$if)

(pass3/register $ASM pass3/$asm)

(pass3/register $DEFINE pass3/$define)

(pass3/register $CALL pass3/$call)

(pass3/register $CALL-CC pass3/$call-cc)

(pass3/register $LET pass3/$let)

(pass3/register $LIST pass3/$list)

(pass3/register $LIBRARY pass3/$library)

(pass3/register $IMPORT pass3/$import)

(pass3/register $IT pass3/$it)

(pass3/register $RECEIVE pass3/$receive)

(define
  (pass3 iform locals frees can-frees sets tail)
  ((vector-ref
     pass3/dispatch-table
     (vector-ref iform 0))
   iform
   locals
   frees
   can-frees
   sets
   tail))

(define
  (pass4 lst)
  (pass4/fixup-labels
    (list->vector (append2 lst (quote (HALT))))))

(define
  (compile-library-body! lib)
  (let1 body
        ($append-map1
          (lambda
            (sexp)
            (code-body
              (pass3 (pass2/optimize
                       (pass1/sexp->iform
                         (pass1/expand sexp)
                         lib
                         (quote ())
                         #f)
                       (quote ()))
                     (quote ())
                     *free-lvars*
                     (quote ())
                     (quote ())
                     #f)))
          ($library.body lib))
        ($library.set-compiled-body!
          lib
          (pass4 (quasiquote ((unquote-splicing body) RETURN 0))))))

(define
  (compile-partial sexp . lib)
  (let1 ss
        (pass1/expand sexp)
        (vector->list
          (pass4/fixup-labels
            (list->vector
              (merge-insn
                (code-body
                  (pass3 (pass2/optimize
                           (pass1/sexp->iform
                             ss
                             (if (null? lib) top-level-library (car lib))
                             (quote ())
                             #f)
                           (quote ()))
                         (quote ())
                         *free-lvars*
                         (quote ())
                         (quote ())
                         #f))))))))

(define-macro
  (pass4/fixup-labels-clollect insn)
  (quasiquote
    (begin (vector-set! ret j (unquote insn))
           (vector-set! ret (+ j 1) (vector-ref v (+ i 1)))
           (loop (+ i 2) (+ j 2)))))

(define-macro
  (pass4/fixup-labels-insn insn)
  (quasiquote
    (let1 label
          (hashtable-ref
            labels
            (vector-ref code (+ i 1))
            #f)
          (cond (label (vector-set! code i (unquote insn))
                       (vector-set! code (+ i 1) (- label i 1))
                       (loop (+ i 2)))
                (else (loop (+ i 1)))))))

(define
  (pass4/fixup-labels v)
  (define
    (collect-labels)
    (let* ((len (vector-length v))
           (ret (make-vector len (quote NOP)))
           (labels (make-eq-hashtable)))
          (let loop
               ((i 0) (j 0))
               (cond ((= i len) (values ret labels))
                     (else (let1 insn
                                 (vector-ref v i)
                                 (cond ((eq? insn (quote UNFIXED_JUMP))
                                        (pass4/fixup-labels-clollect
                                          (quote UNFIXED_JUMP)))
                                       ((eq? insn (quote TEST))
                                        (pass4/fixup-labels-clollect
                                          (quote TEST)))
                                       ((eq? insn (quote NUMBER_LE_TEST))
                                        (pass4/fixup-labels-clollect
                                          (quote NUMBER_LE_TEST)))
                                       ((eq? insn (quote NOT_TEST))
                                        (pass4/fixup-labels-clollect
                                          (quote NOT_TEST)))
                                       ((eq? insn
                                             (quote REFER_LOCAL0_EQV_TEST))
                                        (pass4/fixup-labels-clollect
                                          (quote REFER_LOCAL0_EQV_TEST)))
                                       ((eq? insn (quote FRAME))
                                        (pass4/fixup-labels-clollect
                                          (quote FRAME)))
                                       ((eq? insn (quote PUSH_FRAME))
                                        (pass4/fixup-labels-clollect
                                          (quote PUSH_FRAME)))
                                       ((eq? insn (quote CLOSURE))
                                        (pass4/fixup-labels-clollect
                                          (quote CLOSURE)))
                                       ((and (vector? insn)
                                             (> (vector-length insn) 0)
                                             (tag? insn $LABEL))
                                        (hashtable-set! labels insn j)
                                        (loop (+ i 1) j))
                                       (else (vector-set! ret j insn)
                                             (loop (+ i 1) (+ j 1))))))))))
  (receive
    (code labels)
    (collect-labels)
    (let1 len
          (vector-length code)
          (let loop
               ((i 0))
               (cond ((= i len) code)
                     (else (let1 insn
                                 (vector-ref code i)
                                 (cond ((eq? insn (quote UNFIXED_JUMP))
                                        (pass4/fixup-labels-insn
                                          (quote LOCAL_JMP)))
                                       ((eq? insn (quote CLOSURE))
                                        (pass4/fixup-labels-insn
                                          (quote CLOSURE)))
                                       ((eq? insn (quote TEST))
                                        (pass4/fixup-labels-insn (quote TEST)))
                                       ((eq? insn (quote NUMBER_LE_TEST))
                                        (pass4/fixup-labels-insn
                                          (quote NUMBER_LE_TEST)))
                                       ((eq? insn (quote NOT_TEST))
                                        (pass4/fixup-labels-insn
                                          (quote NOT_TEST)))
                                       ((eq? insn
                                             (quote REFER_LOCAL0_EQV_TEST))
                                        (pass4/fixup-labels-insn
                                          (quote REFER_LOCAL0_EQV_TEST)))
                                       ((eq? insn (quote FRAME))
                                        (pass4/fixup-labels-insn
                                          (quote FRAME)))
                                       ((eq? insn (quote PUSH_FRAME))
                                        (pass4/fixup-labels-insn
                                          (quote PUSH_FRAME)))
                                       (else (loop (+ i 1)))))))))))

(define
  *free-lvars*
  ($map1 (lambda (p) ($lvar p (quote ()) 0 0))
         *free-vars-decl*))

(define
  (merge-insn sexp)
  (define
    (iter s)
    (cond ((null? s) (quote ()))
          (else (match s
                       (((quote REFER_LOCAL0_PUSH)
                         (quote CONSTANT)
                         .
                         rest)
                        (iter (quasiquote
                                (REFER_LOCAL0_PUSH_CONSTANT
                                  (unquote-splicing rest)))))
                       (((quote REFER_LOCAL1_PUSH)
                         (quote CONSTANT)
                         .
                         rest)
                        (iter (quasiquote
                                (REFER_LOCAL1_PUSH_CONSTANT
                                  (unquote-splicing rest)))))
                       (((quote REFER_LOCAL) 1 (quote PUSH) . rest)
                        (iter (quasiquote
                                (REFER_LOCAL1_PUSH (unquote-splicing rest)))))
                       (((quote REFER_LOCAL) 0 (quote PUSH) . rest)
                        (iter (quasiquote
                                (REFER_LOCAL0_PUSH (unquote-splicing rest)))))
                       (((quote REFER_LOCAL) 0 . rest)
                        (iter (quasiquote
                                (REFER_LOCAL0 (unquote-splicing rest)))))
                       (((and x (not (quote CONSTANT)))
                         (quote NUMBER_SUB)
                         (quote PUSH)
                         .
                         rest)
                        (iter (quasiquote
                                ((unquote x)
                                 NUMBER_SUB_PUSH
                                 (unquote-splicing rest)))))
                       (((quote PUSH) (quote ENTER) . rest)
                        (iter (cons (quote PUSH_ENTER) rest)))
                       (((quote CONSTANT) v (quote PUSH) . rest)
                        (iter (quasiquote
                                (CONSTANT_PUSH
                                  (unquote v)
                                  (unquote-splicing rest)))))
                       (((quote REFER_FREE) 0 (quote PUSH) . rest)
                        (iter (quasiquote
                                (REFER_FREE0_PUSH (unquote-splicing rest)))))
                       (((quote REFER_FREE) 1 (quote PUSH) . rest)
                        (iter (quasiquote
                                (REFER_FREE1_PUSH (unquote-splicing rest)))))
                       (((quote REFER_FREE) 2 (quote PUSH) . rest)
                        (iter (quasiquote
                                (REFER_FREE2_PUSH (unquote-splicing rest)))))
                       (((quote REFER_FREE) n (quote PUSH) . rest)
                        (iter (quasiquote
                                (REFER_FREE_PUSH
                                  (unquote n)
                                  (unquote-splicing rest)))))
                       (((quote REFER_FREE) 0 . rest)
                        (iter (quasiquote
                                (REFER_FREE0 (unquote-splicing rest)))))
                       (((quote REFER_FREE) 1 . rest)
                        (iter (quasiquote
                                (REFER_FREE1 (unquote-splicing rest)))))
                       (((quote REFER_FREE) 2 . rest)
                        (iter (quasiquote
                                (REFER_FREE2 (unquote-splicing rest)))))
                       (((quote REFER_LOCAL) 1 . rest)
                        (iter (quasiquote
                                (REFER_LOCAL1 (unquote-splicing rest)))))
                       (((quote REFER_LOCAL) 2 . rest)
                        (iter (quasiquote
                                (REFER_LOCAL2 (unquote-splicing rest)))))
                       (((quote LEAVE) 1 . rest)
                        (iter (quasiquote (LEAVE1 (unquote-splicing rest)))))
                       (((quote NUMBER_LE) (quote TEST) . rest)
                        (iter (quasiquote
                                (NUMBER_LE_TEST (unquote-splicing rest)))))
                       (((quote NUMBER_ADD) (quote PUSH) . rest)
                        (iter (quasiquote
                                (NUMBER_ADD_PUSH (unquote-splicing rest)))))
                       (((quote RETURN) 1 . rest)
                        (iter (quasiquote (RETURN1 (unquote-splicing rest)))))
                       (((quote RETURN) 2 . rest)
                        (iter (quasiquote (RETURN2 (unquote-splicing rest)))))
                       (((quote RETURN) 3 . rest)
                        (iter (quasiquote (RETURN3 (unquote-splicing rest)))))
                       (((quote CALL) 2 . rest)
                        (iter (quasiquote (CALL2 (unquote-splicing rest)))))
                       (((quote REFER_LOCAL0)
                         (quote EQV)
                         (quote TEST)
                         .
                         rest)
                        (iter (quasiquote
                                (REFER_LOCAL0_EQV_TEST
                                  (unquote-splicing rest)))))
                       (((quote PUSH) (quote CONSTANT) . rest)
                        (iter (quasiquote
                                (PUSH_CONSTANT (unquote-splicing rest)))))
                       (((quote PUSH) (quote FRAME) . rest)
                        (iter (quasiquote
                                (PUSH_FRAME (unquote-splicing rest)))))
                       (((and x (not (quote CONSTANT_PUSH)))
                         (quote PUSH)
                         (quote FRAME)
                         .
                         rest)
                        (iter (quasiquote
                                ((unquote x)
                                 PUSH_FRAME
                                 (unquote-splicing rest)))))
                       (((quote REFER_FREE) 3 . rest)
                        (iter (quasiquote
                                (REFER_FREE3 (unquote-splicing rest)))))
                       (((quote REFER_LOCAL) 3 . rest)
                        (iter (quasiquote
                                (REFER_LOCAL3 (unquote-splicing rest)))))
                       (((quote CAR) (quote PUSH) . rest)
                        (iter (quasiquote (CAR_PUSH (unquote-splicing rest)))))
                       (((quote CDR) (quote PUSH) . rest)
                        (iter (quasiquote (CDR_PUSH (unquote-splicing rest)))))
                       (((quote REFER_FREE0) (quote INDIRECT) . rest)
                        (iter (quasiquote
                                (REFER_FREE0_INDIRECT
                                  (unquote-splicing rest)))))
                       (((quote REFER_LOCAL2) (quote PUSH) . rest)
                        (iter (quasiquote
                                (REFER_LOCAL2_PUSH (unquote-splicing rest)))))
                       (((quote SHIFT) m n (quote CALL) o . rest)
                        (iter (quasiquote
                                (SHIFT_CALL
                                  (unquote m)
                                  (unquote n)
                                  (unquote o)
                                  (unquote-splicing rest)))))
                       (((quote CALL) 3 . rest)
                        (iter (quasiquote (CALL3 (unquote-splicing rest)))))
                       (((quote REFER_FREE1) (quote INDIRECT) . rest)
                        (iter (quasiquote
                                (REFER_FREE1_INDIRECT
                                  (unquote-splicing rest)))))
                       (((quote NOT) (quote TEST) . rest)
                        (iter (quasiquote (NOT_TEST (unquote-splicing rest)))))
                       (((quote REFER_GLOBAL)
                         lib-id
                         (quote CALL)
                         n
                         .
                         rest)
                        (iter (quasiquote
                                (REFER_GLOBAL_CALL
                                  (unquote lib-id)
                                  (unquote n)
                                  (unquote-splicing rest)))))
                       (((quote REFER_LOCAL0)
                         (quote NUMBER_ADD_PUSH)
                         .
                         rest)
                        (iter (cons (quote REFER_LOCAL0_NUMBER_ADD_PUSH)
                                    rest)))
                       (((quote REFER_LOCAL0) (quote VECTOR_SET) . rest)
                        (iter (cons (quote REFER_LOCAL0_VECTOR_SET) rest)))
                       (((quote REFER_LOCAL0) (quote VECTOR_REF) . rest)
                        (iter (cons (quote REFER_LOCAL0_VECTOR_REF) rest)))
                       (((quote REFER_LOCAL) n (quote PUSH) . rest)
                        (iter (quasiquote
                                (REFER_LOCAL_PUSH
                                  (unquote n)
                                  (unquote-splicing rest)))))
                       (else (cons (car s) (iter (cdr s))))))))
  sexp)

(define
  (compile sexp)
  (pass4 (merge-insn
           (cdr (pass3 (let1 x
                             (pass2/optimize
                               (pass1/sexp->iform
                                 (pass1/expand sexp)
                                 top-level-library
                                 (quote ())
                                 #f)
                               (quote ()))
                             x)
                       (quote ())
                       *free-lvars*
                       (quote ())
                       (quote ())
                       #f)))))

(define
  (compile-no-optimize sexp)
  (pass4 (code-body
           (pass3 (pass1/sexp->iform
                    (pass1/expand sexp)
                    top-level-library
                    (quote ())
                    #f)
                  (quote ())
                  *free-lvars*
                  (quote ())
                  (quote ())
                  #f))))

#f