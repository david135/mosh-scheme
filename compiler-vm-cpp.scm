;; Do not edit this file generated by ./scripts/gen-compiler.scm.
(define dd display)(define pp print)(define *free-vars-decl* '(number? cons car cdr null? set-car! set-cdr! sys-display rxmatch regexp? regexp->string rxmatch-start rxmatch-end rxmatch-after rxmatch-before rxmatch-substring make-string string-set! string-length string->symbol string->number string-append string-split string number->string reverse eof-object? read-char char=? string? get-environment-variable get-environment-variables equal? open-string-input-port sys-open-output-string sys-port-seek open-output-file close-output-port digit->integer get-remaining-input-string readdir file-exists? sys-get-output-string string->regexp char->integer integer->char format current-input-port current-output-port set-current-input-port! set-current-output-port! char? write gensym string=? vector? list? memq eq? eqv? member boolean? symbol->string string-ref error get-timeofday make-eq-hashtable make-eqv-hashtable hashtable-set! hashtable-ref hashtable-keys string-hash string-ci-hash symbol-hash equal-hash eq-hashtable-copy current-error-port values vm/apply pair? init-library-table find10 make-custom-binary-input-port get-u8 bytevector-u8-set! transcoded-port utf-8-codec make-transcoder eof-object sys-open-bytevector-output-port sys-get-bytevector bytevector-length bytevector-u8-ref standard-input-port get-bytevector-n utf8->string open-file-output-port open-file-input-port close-input-port vector regexp-replace regexp-replace-all source-info errorf eval raise raise-continuable with-exception-handler make-vector-type vector-type? vector-type-data vector-type-instance-of? make-typed-vector typed-vector-get-nth typed-vector-set-nth typed-vector? typed-vector-type apply mod div assq exit macroexpand-1 memv procedure? load symbol? dynamic-wind char<=? char<? char>=? char>? read vector->list set-source-info! call-process %get-closure-name append append2 appendA append! pass3/find-free pass3/find-sets pass4/fixup-labels make-code-builder code-builder-put-extra1! code-builder-put-extra2! code-builder-put-extra3! code-builder-put-extra4! code-builder-put-extra5! code-builder-append! code-builder-emit code-builder-put-insn-arg0! code-builder-put-insn-arg1! length list->vector pass3/compile-refer pass1/find-symbol-in-lvars $label $local-ref symbol-value set-symbol-value! make-hashtable hashtable? hashtable-size hashtable-delete! hashtable-contains? hashtable-copy hashtable-mutable? hashtable-clear! hashtable-keys hashtable-equivalence-function hashtable-hash-function test test2 make-record-type-descriptor make-record-constructor-descriptor record-predicate record-constructor record-accessor record-mutator))(define-macro (make-list-with-src-slot lst) lst)(define (command-line) *command-line-args*)(define
  (eq-hashtable-copy ht)
  (let1 ret
        (make-eq-hashtable)
        (hashtable-for-each
          (lambda
            (key value)
            (hashtable-set! ret key value))
          ht)
        ret))

(define
  (hashtable-set-true! ht keys)
  (let loop
       ((keys keys))
       (cond ((null? keys) ht)
             (else (hashtable-set! ht (car keys) #t)
                   (loop (cdr keys))))))

(define
  ($for-each1-with-rindex proc lst)
  (let loop
       ((i (- (length lst) 1)) (lst lst))
       (cond ((null? lst) (quote ()))
             (else (proc i (car lst))
                   (loop (- i 1) (cdr lst))))))

(define-macro
  (begin0 form . forms)
  (let ((var (gensym)))
       (quasiquote
         (let (((unquote var) (unquote form)))
              (unquote-splicing forms)
              (unquote var)))))

(define-macro
  (first o)
  (quasiquote (car (unquote o))))

(define-macro
  (second o)
  (quasiquote (cadr (unquote o))))

(define-macro
  (third o)
  (quasiquote (caddr (unquote o))))

(define-macro
  (dolist a . body)
  (quasiquote
    (begin (for-each
             (lambda
               ((unquote (first a)))
               (unquote-splicing body))
             (unquote (second a)))
           (quote ()))))

(define-macro
  (do . sexp)
  (match sexp
         ((((var init step ...) ...)
           (test expr ...)
           command
           ...)
          (quasiquote
            (letrec
              ((loop (lambda
                       ((unquote-splicing var))
                       (if (unquote test)
                           (begin #f (unquote-splicing expr))
                           (begin (unquote-splicing command)
                                  (loop (unquote-splicing
                                          (map (lambda
                                                 (v s)
                                                 (quasiquote
                                                   (do "step"
                                                       (unquote v)
                                                       (unquote-splicing s))))
                                               var
                                               step))))))))
              (loop (unquote-splicing init)))))
         (("step" x) x)
         (("step" x y) y)
         (else (syntax-error "malformed do"))))

(define-macro
  (acond . clauses)
  (if (null? clauses)
      (quote ())
      (let ((cl1 (car clauses)) (sym (gensym)))
           (quasiquote
             (let (((unquote sym) (unquote (car cl1))))
                  (if (unquote sym)
                      (let ((it (unquote sym)))
                           (unquote-splicing (cdr cl1)))
                      (acond (unquote-splicing (cdr clauses)))))))))

(define-macro
  (aif test-form then-form . else-form)
  (quasiquote
    (let ((it (unquote test-form)))
         (if it
             (unquote then-form)
             (unquote-splicing else-form)))))

(define
  (syntax-error msg)
  (raise (format "syntax error: ~a" msg)))

(define
  (alist-cons obj1 obj2 obj3)
  (cons (cons obj1 obj2) obj3))

(define
  (libname->symbol name)
  (let loop
       ((name name) (ret ""))
       (if (null? name)
           (string->symbol ret)
           (loop (cdr name)
                 (string-append
                   ret
                   (symbol->string (car name))
                   " ")))))

(define
  ($map1 f l)
  (if (null? l)
      l
      (cons (f (car l)) ($map1 f (cdr l)))))

(define
  ($filter-map1 f l)
  (if (null? l)
      l
      (aif (f (car l))
           (cons it ($filter-map1 f (cdr l)))
           ($filter-map1 f (cdr l)))))

(define
  ($map1-with-tail f l)
  (if (null? l)
      l
      (cons (f (car l) (null? (cdr l)))
            ($map1-with-tail f (cdr l)))))

(define-macro
  ($append-map1 f l)
  (quasiquote
    (apply append ($map1 (unquote f) (unquote l)))))

(define
  (uniq lst)
  (let loop
       ((lst lst) (ret (quote ())))
       (cond ((null? lst) ret)
             (else (if (memq (car lst) ret)
                       (loop (cdr lst) ret)
                       (loop (cdr lst) (cons (car lst) ret)))))))

(define
  (apply-each-pair proc lst)
  (if (null? (cdr lst))
      (quote ())
      (cons (list proc (car lst) (cadr lst))
            (apply-each-pair proc (cdr lst)))))

(define
  (remove-tail lst pred)
  (let loop
       ((lst lst) (ret (quote ())))
       (cond ((null? (cdr lst))
              (reverse
                (if (pred (car lst)) ret (cons (car lst) ret))))
             (else (loop (cdr lst) (cons (car lst) ret))))))

(define $CONST 0)

(define
  ($const val)
  (let1 v
        (make-vector 2)
        (vector-set! v 0 $CONST)
        (vector-set! v 1 val)
        v))

(define-macro
  ($const.val iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($const.set-val! iform val)
  (quasiquote
    (vector-set! (unquote iform) 1 (unquote val))))

(define $LVAR 1)

(define
  ($lvar sym init-val ref-count set-count)
  (let1 v
        (make-vector 5)
        (vector-set! v 0 $LVAR)
        (vector-set! v 1 sym)
        (vector-set! v 2 init-val)
        (vector-set! v 3 ref-count)
        (vector-set! v 4 set-count)
        v))

(define
  ($lvar.sym-proc iform)
  (vector-ref iform 1))

(define-macro
  ($lvar.sym iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($lvar.init-val iform)
  (quasiquote (vector-ref (unquote iform) 2)))

(define-macro
  ($lvar.ref-count iform)
  (quasiquote (vector-ref (unquote iform) 3)))

(define-macro
  ($lvar.set-count iform)
  (quasiquote (vector-ref (unquote iform) 4)))

(define-macro
  ($lvar.set-sym! iform sym)
  (quasiquote
    (vector-set! (unquote iform) 1 (unquote sym))))

(define-macro
  ($lvar.set-init-val! iform init-val)
  (quasiquote
    (vector-set!
      (unquote iform)
      2
      (unquote init-val))))

(define-macro
  ($lvar.set-ref-count! iform ref-count)
  (quasiquote
    (vector-set!
      (unquote iform)
      3
      (unquote ref-count))))

(define-macro
  ($lvar.set-set-count! iform set-count)
  (quasiquote
    (vector-set!
      (unquote iform)
      4
      (unquote set-count))))

(define
  (pp-lvars lvars)
  (print (map (lambda (x) ($lvar.sym x)) lvars)))

(define $LET 2)

(define
  ($let type lvars inits body tail? src)
  (let1 v
        (make-vector 7)
        (vector-set! v 0 $LET)
        (vector-set! v 1 type)
        (vector-set! v 2 lvars)
        (vector-set! v 3 inits)
        (vector-set! v 4 body)
        (vector-set! v 5 tail?)
        (vector-set! v 6 src)
        v))

(define-macro
  ($let.type iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($let.lvars iform)
  (quasiquote (vector-ref (unquote iform) 2)))

(define-macro
  ($let.inits iform)
  (quasiquote (vector-ref (unquote iform) 3)))

(define-macro
  ($let.body iform)
  (quasiquote (vector-ref (unquote iform) 4)))

(define-macro
  ($let.tail? iform)
  (quasiquote (vector-ref (unquote iform) 5)))

(define-macro
  ($let.src iform)
  (quasiquote (vector-ref (unquote iform) 6)))

(define-macro
  ($let.set-type! iform type)
  (quasiquote
    (vector-set! (unquote iform) 1 (unquote type))))

(define-macro
  ($let.set-lvars! iform lvars)
  (quasiquote
    (vector-set! (unquote iform) 2 (unquote lvars))))

(define-macro
  ($let.set-inits! iform inits)
  (quasiquote
    (vector-set! (unquote iform) 3 (unquote inits))))

(define-macro
  ($let.set-body! iform body)
  (quasiquote
    (vector-set! (unquote iform) 4 (unquote body))))

(define-macro
  ($let.set-tail?! iform tail?)
  (quasiquote
    (vector-set! (unquote iform) 5 (unquote tail?))))

(define-macro
  ($let.set-src! iform src)
  (quasiquote
    (vector-set! (unquote iform) 6 (unquote src))))

(define $SEQ 3)

(define
  ($seq body tail?)
  (let1 v
        (make-vector 3)
        (vector-set! v 0 $SEQ)
        (vector-set! v 1 body)
        (vector-set! v 2 tail?)
        v))

(define-macro
  ($seq.body iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($seq.tail? iform)
  (quasiquote (vector-ref (unquote iform) 2)))

(define-macro
  ($seq.set-body! iform body)
  (quasiquote
    (vector-set! (unquote iform) 1 (unquote body))))

(define-macro
  ($seq.set-tail?! iform tail?)
  (quasiquote
    (vector-set! (unquote iform) 2 (unquote tail?))))

(define $LAMBDA 4)

(define
  ($lambda
    src
    name
    reqargs
    optarg
    lvars
    body
    flag
    calls)
  (let1 v
        (make-vector 9)
        (vector-set! v 0 $LAMBDA)
        (vector-set! v 1 src)
        (vector-set! v 2 name)
        (vector-set! v 3 reqargs)
        (vector-set! v 4 optarg)
        (vector-set! v 5 lvars)
        (vector-set! v 6 body)
        (vector-set! v 7 flag)
        (vector-set! v 8 calls)
        v))

(define-macro
  ($lambda.src iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($lambda.name iform)
  (quasiquote (vector-ref (unquote iform) 2)))

(define-macro
  ($lambda.reqargs iform)
  (quasiquote (vector-ref (unquote iform) 3)))

(define-macro
  ($lambda.optarg iform)
  (quasiquote (vector-ref (unquote iform) 4)))

(define-macro
  ($lambda.lvars iform)
  (quasiquote (vector-ref (unquote iform) 5)))

(define-macro
  ($lambda.body iform)
  (quasiquote (vector-ref (unquote iform) 6)))

(define-macro
  ($lambda.flag iform)
  (quasiquote (vector-ref (unquote iform) 7)))

(define-macro
  ($lambda.calls iform)
  (quasiquote (vector-ref (unquote iform) 8)))

(define-macro
  ($lambda.set-src! iform src)
  (quasiquote
    (vector-set! (unquote iform) 1 (unquote src))))

(define-macro
  ($lambda.set-name! iform name)
  (quasiquote
    (vector-set! (unquote iform) 2 (unquote name))))

(define-macro
  ($lambda.set-reqargs! iform reqargs)
  (quasiquote
    (vector-set! (unquote iform) 3 (unquote reqargs))))

(define-macro
  ($lambda.set-optarg! iform optarg)
  (quasiquote
    (vector-set! (unquote iform) 4 (unquote optarg))))

(define-macro
  ($lambda.set-lvars! iform lvars)
  (quasiquote
    (vector-set! (unquote iform) 5 (unquote lvars))))

(define-macro
  ($lambda.set-body! iform body)
  (quasiquote
    (vector-set! (unquote iform) 6 (unquote body))))

(define-macro
  ($lambda.set-flag! iform flag)
  (quasiquote
    (vector-set! (unquote iform) 7 (unquote flag))))

(define-macro
  ($lambda.set-calls! iform calls)
  (quasiquote
    (vector-set! (unquote iform) 8 (unquote calls))))

(define $LOCAL-REF 5)

(define
  ($local-ref lvar)
  (let1 v
        (make-vector 2)
        (vector-set! v 0 $LOCAL-REF)
        (vector-set! v 1 lvar)
        v))

(define-macro
  ($local-ref.lvar iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($local-ref.set-lvar! iform lvar)
  (quasiquote
    (vector-set! (unquote iform) 1 (unquote lvar))))

(define $LOCAL-ASSIGN 6)

(define
  ($local-assign lvar val)
  (let1 v
        (make-vector 3)
        (vector-set! v 0 $LOCAL-ASSIGN)
        (vector-set! v 1 lvar)
        (vector-set! v 2 val)
        v))

(define-macro
  ($local-assign.lvar iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($local-assign.val iform)
  (quasiquote (vector-ref (unquote iform) 2)))

(define-macro
  ($local-assign.set-lvar! iform lvar)
  (quasiquote
    (vector-set! (unquote iform) 1 (unquote lvar))))

(define-macro
  ($local-assign.set-val! iform val)
  (quasiquote
    (vector-set! (unquote iform) 2 (unquote val))))

(define $GLOBAL-REF 7)

(define
  ($global-ref libname sym)
  (let1 v
        (make-vector 3)
        (vector-set! v 0 $GLOBAL-REF)
        (vector-set! v 1 libname)
        (vector-set! v 2 sym)
        v))

(define-macro
  ($global-ref.libname iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($global-ref.sym iform)
  (quasiquote (vector-ref (unquote iform) 2)))

(define-macro
  ($global-ref.set-libname! iform libname)
  (quasiquote
    (vector-set! (unquote iform) 1 (unquote libname))))

(define-macro
  ($global-ref.set-sym! iform sym)
  (quasiquote
    (vector-set! (unquote iform) 2 (unquote sym))))

(define $GLOBAL-ASSIGN 8)

(define
  ($global-assign libname sym val)
  (let1 v
        (make-vector 4)
        (vector-set! v 0 $GLOBAL-ASSIGN)
        (vector-set! v 1 libname)
        (vector-set! v 2 sym)
        (vector-set! v 3 val)
        v))

(define-macro
  ($global-assign.libname iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($global-assign.sym iform)
  (quasiquote (vector-ref (unquote iform) 2)))

(define-macro
  ($global-assign.val iform)
  (quasiquote (vector-ref (unquote iform) 3)))

(define-macro
  ($global-assign.set-libname! iform libname)
  (quasiquote
    (vector-set! (unquote iform) 1 (unquote libname))))

(define-macro
  ($global-assign.set-sym! iform sym)
  (quasiquote
    (vector-set! (unquote iform) 2 (unquote sym))))

(define-macro
  ($global-assign.set-val! iform val)
  (quasiquote
    (vector-set! (unquote iform) 3 (unquote val))))

(define $UNDEF 9)

(define ($undef) (make-vector 1 $UNDEF))

(define $IF 10)

(define
  ($if test then else)
  (let1 v
        (make-vector 4)
        (vector-set! v 0 $IF)
        (vector-set! v 1 test)
        (vector-set! v 2 then)
        (vector-set! v 3 else)
        v))

(define-macro
  ($if.test iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($if.then iform)
  (quasiquote (vector-ref (unquote iform) 2)))

(define-macro
  ($if.else iform)
  (quasiquote (vector-ref (unquote iform) 3)))

(define-macro
  ($if.set-test! iform test)
  (quasiquote
    (vector-set! (unquote iform) 1 (unquote test))))

(define-macro
  ($if.set-then! iform then)
  (quasiquote
    (vector-set! (unquote iform) 2 (unquote then))))

(define-macro
  ($if.set-else! iform else)
  (quasiquote
    (vector-set! (unquote iform) 3 (unquote else))))

(define $ASM 11)

(define
  ($asm insn args)
  (let1 v
        (make-vector 3)
        (vector-set! v 0 $ASM)
        (vector-set! v 1 insn)
        (vector-set! v 2 args)
        v))

(define-macro
  ($asm.insn iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($asm.args iform)
  (quasiquote (vector-ref (unquote iform) 2)))

(define-macro
  ($asm.set-insn! iform insn)
  (quasiquote
    (vector-set! (unquote iform) 1 (unquote insn))))

(define-macro
  ($asm.set-args! iform args)
  (quasiquote
    (vector-set! (unquote iform) 2 (unquote args))))

(define $DEFINE 12)

(define
  ($define libname sym val)
  (let1 v
        (make-vector 4)
        (vector-set! v 0 $DEFINE)
        (vector-set! v 1 libname)
        (vector-set! v 2 sym)
        (vector-set! v 3 val)
        v))

(define-macro
  ($define.libname iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($define.sym iform)
  (quasiquote (vector-ref (unquote iform) 2)))

(define-macro
  ($define.val iform)
  (quasiquote (vector-ref (unquote iform) 3)))

(define-macro
  ($define.set-libname! iform libname)
  (quasiquote
    (vector-set! (unquote iform) 1 (unquote libname))))

(define-macro
  ($define.set-sym! iform sym)
  (quasiquote
    (vector-set! (unquote iform) 2 (unquote sym))))

(define-macro
  ($define.set-val! iform val)
  (quasiquote
    (vector-set! (unquote iform) 3 (unquote val))))

(define $CALL-CC 13)

(define
  ($call-cc proc tail?)
  (let1 v
        (make-vector 3)
        (vector-set! v 0 $CALL-CC)
        (vector-set! v 1 proc)
        (vector-set! v 2 tail?)
        v))

(define-macro
  ($call-cc.proc iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($call-cc.tail? iform)
  (quasiquote (vector-ref (unquote iform) 2)))

(define-macro
  ($call-cc.set-proc! iform proc)
  (quasiquote
    (vector-set! (unquote iform) 1 (unquote proc))))

(define-macro
  ($call-cc.set-tail?! iform tail?)
  (quasiquote
    (vector-set! (unquote iform) 2 (unquote tail?))))

(define $CALL 14)

(define
  ($call proc args tail? type)
  (let1 v
        (make-vector 5)
        (vector-set! v 0 $CALL)
        (vector-set! v 1 proc)
        (vector-set! v 2 args)
        (vector-set! v 3 tail?)
        (vector-set! v 4 type)
        v))

(define-macro
  ($call.proc iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($call.args iform)
  (quasiquote (vector-ref (unquote iform) 2)))

(define-macro
  ($call.tail? iform)
  (quasiquote (vector-ref (unquote iform) 3)))

(define-macro
  ($call.type iform)
  (quasiquote (vector-ref (unquote iform) 4)))

(define-macro
  ($call.set-proc! iform proc)
  (quasiquote
    (vector-set! (unquote iform) 1 (unquote proc))))

(define-macro
  ($call.set-args! iform args)
  (quasiquote
    (vector-set! (unquote iform) 2 (unquote args))))

(define-macro
  ($call.set-tail?! iform tail?)
  (quasiquote
    (vector-set! (unquote iform) 3 (unquote tail?))))

(define-macro
  ($call.set-type! iform type)
  (quasiquote
    (vector-set! (unquote iform) 4 (unquote type))))

(define $LABEL 15)

(define
  ($label body)
  (let1 v
        (make-vector 2)
        (vector-set! v 0 $LABEL)
        (vector-set! v 1 body)
        v))

(define-macro
  ($label.body iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($label.set-body! iform body)
  (quasiquote
    (vector-set! (unquote iform) 1 (unquote body))))

(define-macro
  (make-label)
  (quasiquote ($label #f)))

(define-macro (ref-label l) l)

(define $LIST 16)

(define
  ($list args)
  (let1 v
        (make-vector 2)
        (vector-set! v 0 $LIST)
        (vector-set! v 1 args)
        v))

(define-macro
  ($list.args iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($list.set-args! iform args)
  (quasiquote
    (vector-set! (unquote iform) 1 (unquote args))))

(define $LIBRARY 17)

(define
  ($library
    name
    export-syms
    import-syms
    import
    macro
    body
    compiled-body)
  (let1 v
        (make-vector 8)
        (vector-set! v 0 $LIBRARY)
        (vector-set! v 1 (libname->symbol name))
        (vector-set! v 2 export-syms)
        (vector-set! v 3 import-syms)
        (vector-set! v 4 import)
        (vector-set! v 5 macro)
        (vector-set! v 6 body)
        (vector-set! v 7 compiled-body)
        v))

(define-macro
  ($library.name iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($library.export-syms iform)
  (quasiquote (vector-ref (unquote iform) 2)))

(define-macro
  ($library.import-syms iform)
  (quasiquote (vector-ref (unquote iform) 3)))

(define-macro
  ($library.import iform)
  (quasiquote (vector-ref (unquote iform) 4)))

(define-macro
  ($library.macro iform)
  (quasiquote (vector-ref (unquote iform) 5)))

(define-macro
  ($library.body iform)
  (quasiquote (vector-ref (unquote iform) 6)))

(define-macro
  ($library.compiled-body iform)
  (quasiquote (vector-ref (unquote iform) 7)))

(define-macro
  ($library.set-name! iform name)
  (quasiquote
    (vector-set! (unquote iform) 1 (unquote name))))

(define-macro
  ($library.set-export-syms! iform export-syms)
  (quasiquote
    (vector-set!
      (unquote iform)
      2
      (unquote export-syms))))

(define-macro
  ($library.set-import-syms! iform import-syms)
  (quasiquote
    (vector-set!
      (unquote iform)
      3
      (unquote import-syms))))

(define-macro
  ($library.set-import! iform import)
  (quasiquote
    (vector-set! (unquote iform) 4 (unquote import))))

(define-macro
  ($library.set-macro! iform macro)
  (quasiquote
    (vector-set! (unquote iform) 5 (unquote macro))))

(define-macro
  ($library.append-macro! iform macro)
  (quasiquote
    (vector-set!
      (unquote iform)
      5
      (append
        ($library.macro (unquote iform))
        (unquote macro)))))

(define-macro
  ($library.set-body! iform body)
  (quasiquote
    (vector-set! (unquote iform) 6 (unquote body))))

(define-macro
  ($library.set-compiled-body! iform compiled-body)
  (quasiquote
    (vector-set!
      (unquote iform)
      7
      (unquote compiled-body))))

(define $IMPORT 18)

(define
  ($import import-specs)
  (let1 v
        (make-vector 2)
        (vector-set! v 0 $IMPORT)
        (vector-set! v 1 import-specs)
        v))

(define-macro
  ($import.import-specs iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($import.set-import-specs! iform import-specs)
  (quasiquote
    (vector-set!
      (unquote iform)
      1
      (unquote import-specs))))

(define $IMPORT-SPEC 19)

(define
  ($import-spec libname level)
  (let1 v
        (make-vector 3)
        (vector-set! v 0 $IMPORT-SPEC)
        (vector-set! v 1 libname)
        (vector-set! v 2 level)
        v))

(define-macro
  ($import-spec.libname iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($import-spec.level iform)
  (quasiquote (vector-ref (unquote iform) 2)))

(define-macro
  ($import-spec.set-libname! iform libname)
  (quasiquote
    (vector-set! (unquote iform) 1 (unquote libname))))

(define-macro
  ($import-spec.set-level! iform level)
  (quasiquote
    (vector-set! (unquote iform) 2 (unquote level))))

(define $IT 20)

(define ($it) (make-vector 1 $IT))

(define $RECEIVE 21)

(define
  ($receive lvars reqargs optarg vals body tail?)
  (let1 v
        (make-vector 7)
        (vector-set! v 0 $RECEIVE)
        (vector-set! v 1 lvars)
        (vector-set! v 2 reqargs)
        (vector-set! v 3 optarg)
        (vector-set! v 4 vals)
        (vector-set! v 5 body)
        (vector-set! v 6 tail?)
        v))

(define-macro
  ($receive.lvars iform)
  (quasiquote (vector-ref (unquote iform) 1)))

(define-macro
  ($receive.reqargs iform)
  (quasiquote (vector-ref (unquote iform) 2)))

(define-macro
  ($receive.optarg iform)
  (quasiquote (vector-ref (unquote iform) 3)))

(define-macro
  ($receive.vals iform)
  (quasiquote (vector-ref (unquote iform) 4)))

(define-macro
  ($receive.body iform)
  (quasiquote (vector-ref (unquote iform) 5)))

(define-macro
  ($receive.tail? iform)
  (quasiquote (vector-ref (unquote iform) 6)))

(define-macro
  ($receive.set-lvars! iform lvars)
  (quasiquote
    (vector-set! (unquote iform) 1 (unquote lvars))))

(define-macro
  ($receive.set-vals! iform body)
  (quasiquote
    (vector-set! (unquote iform) 4 (unquote body))))

(define-macro
  ($receive.set-body! iform body)
  (quasiquote
    (vector-set! (unquote iform) 5 (unquote body))))

(define-macro
  ($receive.set-tail?! iform tail?)
  (quasiquote
    (vector-set! (unquote iform) 6 (unquote tail?))))

(define $INSN-NUM 22)

(define-macro
  (tag iform)
  (quasiquote (vector-ref (unquote iform) 0)))

(define-macro
  (tag? iform t)
  (quasiquote
    (= (unquote t) (tag (unquote iform)))))

(define-macro
  (set-tag! iform t)
  (quasiquote
    (vector-set! (unquote iform) 0 (unquote t))))

(define-macro
  (make-lvar sym)
  (quasiquote ($lvar (unquote sym) (quote ()) 0 0)))

(define-macro
  ($lvar.ref-count++! lvar)
  (quasiquote
    ($lvar.set-ref-count!
      (unquote lvar)
      (+ ($lvar.ref-count (unquote lvar)) 1))))

(define-macro
  ($lvar.ref-count--! lvar)
  (quasiquote
    ($lvar.set-ref-count!
      (unquote lvar)
      (- ($lvar.ref-count (unquote lvar)) 1))))

(define-macro
  ($lvar.set-count++! lvar)
  (quasiquote
    ($lvar.set-set-count!
      (unquote lvar)
      (+ 1 ($lvar.set-count (unquote lvar))))))

(define-macro
  ($local-ref.copy dst src)
  (quasiquote
    ($local-ref.set-lvar!
      (unquote dst)
      ($local-ref.lvar (unquote src)))))

(define-macro
  ($library.add-import-syms! library import-syms)
  (quasiquote
    ($library.set-import-syms!
      (unquote library)
      (append
        ($library.import-syms (unquote library))
        (unquote import-syms)))))

(define-macro
  ($library.add-import! library import)
  (quasiquote
    ($library.set-import!
      (unquote library)
      (append
        ($library.import (unquote library))
        (list (unquote import))))))

(define
  (make-empty-library name)
  ($library
    name
    (quote ())
    (quote ())
    (quote ())
    (quote ())
    (quote ())
    #f))

(define
  top-level-library
  (make-empty-library (quote (top level))))

(define
  (parse-lambda-vars vars)
  (cond ((pair? vars)
         (let loop
              ((p vars) (ret (quote ())))
              (cond ((null? p) (list #f vars))
                    ((pair? p) (loop (cdr p) (cons (car p) ret)))
                    (else (list #t (reverse (cons p ret)))))))
        ((null? vars) (list #f (quote ())))
        (else (list #t (list vars)))))

(define
  (parse-lambda-args formals)
  (let loop
       ((formals formals) (args (quote ())))
       (cond ((null? formals)
              (values (reverse args) (length args) 0))
             ((pair? formals)
              (loop (cdr formals) (cons (car formals) args)))
             (else (values
                     (reverse (cons formals args))
                     (length args)
                     1)))))

(define-macro
  ($src x sexp)
  (quasiquote
    (set-source-info!
      (make-list-with-src-slot (unquote x))
      (source-info (unquote sexp)))))

(define
  (lambda-has-define? sexp)
  (and (not (null? (cddr sexp)))
       (pair? (third sexp))
       (eq? (car (third sexp)) (quote define))))

(define
  (let1->let sexp)
  (quasiquote
    (let (((unquote (second sexp)) (unquote (third sexp))))
         (unquote-splicing (cdddr sexp)))))

(define
  (expand-let vars body)
  (let1 expanded-vars
        (fold-right
          (lambda
            (x y)
            (cons (list (first x) (pass1/expand (second x)))
                  y))
          (quote ())
          vars)
        (quasiquote
          (let (unquote expanded-vars)
               (unquote-splicing (pass1/expand body))))))

(define
  (pass1/expand sexp)
  (cond ((pair? sexp)
         (case (first sexp)
               ((quote) sexp)
               ((define-macro) sexp)
               ((define)
                (if (define-is-lambda? sexp)
                    (pass1/expand (define->lambda sexp))
                    ($src ($map1 (lambda (s) (pass1/expand s)) sexp)
                          sexp)))
               ((let1)
                ($src (pass1/expand (let1->let sexp)) sexp))
               ((let)
                (if (let-is-named? sexp)
                    ($src (pass1/expand (named-let->letrec sexp))
                          sexp)
                    ($src (expand-let (second sexp) (cddr sexp))
                          sexp)))
               ((let*)
                ($src (pass1/expand (let*->let sexp)) sexp))
               ((cond)
                ($src (pass1/expand (cond->if sexp)) sexp))
               ((lambda)
                (cond ((lambda-has-define? sexp)
                       ($src (pass1/expand
                               ($src (internal-define->letrec sexp) sexp))
                             sexp))
                      (else ($src (append!
                                    (list (quote lambda) (cadr sexp))
                                    (pass1/expand (cddr sexp)))
                                  sexp))))
               ((when)
                (match sexp
                       (((quote when) pred body . more)
                        ($src (pass1/expand
                                (quasiquote
                                  (cond ((unquote pred)
                                         (unquote body)
                                         (unquote-splicing more)))))
                              sexp))
                       (else (syntax-error "malformed when"))))
               ((unless)
                (match sexp
                       (((quote unless) pred body . more)
                        ($src (pass1/expand
                                (quasiquote
                                  (cond ((not (unquote pred))
                                         (unquote body)
                                         (unquote-splicing more)))))
                              sexp))
                       (else (syntax-error "malformed unless"))))
               ((aif)
                ($src (pass1/expand (aif->let sexp)) sexp))
               ((case)
                ($src (pass1/expand (case->cond sexp)) sexp))
               ((quasiquote) (expand-quasiquote (cadr sexp) 0))
               (else sexp)))
        (else sexp)))

(define
  (define-is-lambda? sexp)
  (pair? (cadr sexp)))

(define
  (conditions->if conditions)
  (if (null? (cdr conditions))
      (car conditions)
      (list (quote if)
            (car conditions)
            (conditions->if (cdr conditions))
            #f)))

(define
  (find-serial-from-head pred lst)
  (let loop
       ((found (quote ())) (lst lst))
       (cond ((null? lst)
              (if (null? found)
                  (list (quote ()) lst)
                  (values found (quote ()))))
             ((pred (car lst))
              (loop (append found (list (car lst))) (cdr lst)))
             (else (if (null? found)
                       (list (quote ()) lst)
                       (list found lst))))))

(define
  (internal-define->letrec sexp)
  (let* ((body (cddr sexp))
         (args (second sexp))
         (ret (find-serial-from-head
                (lambda
                  (s)
                  (and (pair? s) (eq? (quote define) (car s))))
                body))
         (defines (first ret))
         (rest (second ret))
         (letrec-body
           ($src (quasiquote
                   (letrec
                     (unquote
                       (map (lambda (d) (list (second d) (third d)))
                            (map pass1/expand defines)))
                     (unquote-splicing rest)))
                 sexp)))
        ($src (quasiquote
                (lambda (unquote args) (unquote letrec-body)))
              sexp)))

(define
  (define->lambda sexp)
  (let ((args (cadr sexp)) (body (cddr sexp)))
       (quasiquote
         (define
           (unquote (car args))
           (unquote
             ($src (append! (list (quote lambda) (cdr args)) body)
                   sexp))))))

(define
  (unless->cond sexp)
  (quasiquote
    (cond ((not (unquote (cadr sexp)))
           (unquote-splicing (cddr sexp))))))

(define
  (let*->let sexp)
  (let ((args (cadr sexp)) (body (cddr sexp)))
       (car (let loop
                 ((args args))
                 (if (null? args)
                     body
                     ($src (quasiquote
                             ((let ((unquote (car args)))
                                   (unquote-splicing (loop (cdr args))))))
                           sexp))))))

(define
  (cond->if sexp)
  (define
    (make-if test then else)
    (let ((then (if (> (length then) 1)
                    (cons (quote begin) then)
                    (car then))))
         (quasiquote
           (if (unquote test) (unquote then) (unquote else)))))
  (let loop
       ((clauses (cdr sexp)))
       (if (null? clauses)
           (quote #f)
           (cond ((and (null? (cdr clauses))
                       (eq? (quote else) (caar clauses)))
                  (if (> (length (cdar clauses)) 1)
                      (cons (quote begin) (cdar clauses))
                      (cadar clauses)))
                 ((and (= 3 (length (car clauses)))
                       (eq? (quote =>) (cadar clauses)))
                  (let ((tmp (gensym)))
                       (quasiquote
                         (let (((unquote tmp) (unquote (caar clauses))))
                              (if (unquote tmp)
                                  ((unquote (caddar clauses)) (unquote tmp))
                                  (unquote (loop (cdr clauses))))))))
                 ((= 1 (length (car clauses)))
                  (let ((tmp (gensym)))
                       (quasiquote
                         (let (((unquote tmp) (unquote (caar clauses))))
                              (if (unquote tmp)
                                  (unquote tmp)
                                  (unquote (loop (cdr clauses))))))))
                 (else (make-if
                         (caar clauses)
                         (cdar clauses)
                         (loop (cdr clauses))))))))

(define
  (expand-clauses clauses tmpname)
  (let loop
       ((clauses clauses))
       (if (null? clauses)
           (quote ())
           (if (eq? (quote else) (caar clauses))
               clauses
               (if (= 1 (length (caar clauses)))
                   (cons (quasiquote
                           ((eqv? (quote (unquote (caaar clauses)))
                                  (unquote tmpname))
                            (unquote-splicing (cdar clauses))))
                         (loop (cdr clauses)))
                   (cons (quasiquote
                           ((memv (unquote tmpname)
                                  (quote (unquote (caar clauses))))
                            (unquote-splicing (cdar clauses))))
                         (loop (cdr clauses))))))))

(define
  (case->cond sexp)
  (let* ((pred (cadr sexp))
         (clauses (cddr sexp))
         (tmpname (gensym))
         (expanded-clauses
           (expand-clauses clauses tmpname)))
        (quasiquote
          (let (((unquote tmpname) (unquote pred)))
               (cond (unquote-splicing expanded-clauses))))))

(define
  (named-let->letrec sexp)
  (let* ((name (cadr sexp))
         (args (caddr sexp))
         (vars ($map1 car args))
         (vals ($map1 cadr args))
         (body (cdddr sexp))
         (lambda-body
           ($src (quasiquote
                   (lambda (unquote vars) (unquote-splicing body)))
                 sexp)))
        ($src (quasiquote
                (letrec
                  (((unquote name) (unquote lambda-body)))
                  ((unquote name) (unquote-splicing vals))))
              sexp)))

(define
  (aif->let sexp)
  (quasiquote
    (let ((it (unquote (cadr sexp))))
         (if it
             (unquote (caddr sexp))
             (unquote (cadddr sexp))))))

(define
  (let-is-named? sexp)
  (symbol? (cadr sexp)))

(define
  (finalize-quasiquote mode arg)
  (cond ((eq? mode (quote quote))
         (list (quote quote) arg))
        ((eq? mode (quote unquote)) arg)
        ((eq? mode (quote unquote-splicing))
         (error ",@ in invalid context" arg))
        (else (cons mode arg))))

(define
  (descend-quasiquote x level return)
  (cond ((vector? x)
         (descend-quasiquote-vector x level return))
        ((not (pair? x)) (return (quote quote) x))
        ((interesting-to-quasiquote? x (quote quasiquote))
         (descend-quasiquote-pair x (+ level 1) return))
        ((interesting-to-quasiquote? x (quote unquote))
         (cond ((= level 0) (return (quote unquote) (cadr x)))
               (else (descend-quasiquote-pair x (- level 1) return))))
        ((interesting-to-quasiquote?
           x
           (quote unquote-splicing))
         (cond ((= level 0)
                (return (quote unquote-splicing) (cadr x)))
               (else (descend-quasiquote-pair x (- level 1) return))))
        (else (descend-quasiquote-pair x level return))))

(define
  (descend-quasiquote-pair x level return)
  (descend-quasiquote
    (car x)
    level
    (lambda
      (car-mode car-arg)
      (descend-quasiquote
        (cdr x)
        level
        (lambda
          (cdr-mode cdr-arg)
          (cond ((and (eq? car-mode (quote quote))
                      (eq? cdr-mode (quote quote)))
                 (return (quote quote) x))
                ((eq? car-mode (quote unquote-splicing))
                 (cond ((and (eq? cdr-mode (quote quote))
                             (null? cdr-arg))
                        (return (quote unquote) car-arg))
                       (else (return
                               (quote append)
                               (list car-arg
                                     (finalize-quasiquote
                                       cdr-mode
                                       cdr-arg))))))
                (else (return
                        (quote cons)
                        (list (finalize-quasiquote car-mode car-arg)
                              (finalize-quasiquote cdr-mode cdr-arg))))))))))

(define
  (descend-quasiquote-vector x level return)
  (descend-quasiquote
    (vector->list x)
    level
    (lambda
      (mode arg)
      (if (equal? mode (quote quote))
          (return (quote quote) x)
          (return
            (quote list->vector)
            (list (finalize-quasiquote mode arg)))))))

(define
  (interesting-to-quasiquote? x marker)
  (and (pair? x) (eq? (car x) marker)))

(define
  (expand-quasiquote x level)
  (descend-quasiquote x level finalize-quasiquote))

(define
  (find-with-car object lst)
  (if (null? lst)
      #f
      (if (eq? object (caar lst))
          (car lst)
          (find-with-car object (cdr lst)))))

(define
  (pass1/lib-refer->iform symbol library)
  (let1 import-syms
        ($library.import-syms library)
        (aif (find-with-car symbol import-syms)
             ($global-ref (second it) (third it))
             ($global-ref ($library.name library) symbol))))

(define
  (pass1/lib-assign->iform symbol library val)
  (let1 import-syms
        ($library.import-syms library)
        (aif (find-with-car symbol import-syms)
             ($global-assign (second it) (third it) val)
             ($global-assign
               ($library.name library)
               symbol
               val))))

(define
  (pass1/find-symbol-in-lvars symbol lvars)
  (cond ((null? lvars) #f)
        ((eq? symbol ($lvar.sym (car lvars)))
         (car lvars))
        (else (pass1/find-symbol-in-lvars symbol (cdr lvars)))))

(define
  (pass1/refer->iform symbol library lvars)
  (acond ((pass1/find-symbol-in-lvars symbol lvars)
          ($lvar.ref-count++! it)
          ($local-ref it))
         ((pass1/lib-refer->iform symbol library) it)
         (#t ($global-ref (quote (top level)) symbol))))

(define
  (pass1/assign symbol val library lvars tail?)
  (let1 iform
        (pass1/sexp->iform val library lvars tail?)
        (acond ((pass1/find-symbol-in-lvars symbol lvars)
                ($lvar.set-count++! it)
                ($local-assign it iform))
               ((pass1/lib-assign->iform symbol library iform)
                it)
               (#t
                ($global-assign (quote (top level)) symbol iform)))))

(define
  (pass1/body->iform body library lvars tail?)
  (let1 iforms
        ($map1-with-tail
          (lambda
            (b t?)
            (pass1/sexp->iform
              (pass1/expand b)
              library
              lvars
              (and t? tail?)))
          body)
        (if (= 1 (length iforms))
            (car iforms)
            ($seq iforms tail?))))

(define
  (dotpair->list p)
  (let loop
       ((p p))
       (cond ((and (not (pair? p)) (not (null? p)))
              (cons p (quote ())))
             ((null? p) (quote ()))
             (else (cons (car p) (loop (cdr p)))))))

(define
  (pass1/lambda->iform name sexp library lvars)
  (let* ((vars (second sexp))
         (body (cddr sexp))
         (parsed-vars (parse-lambda-vars vars))
         (optional-arg? (first parsed-vars))
         (vars (second parsed-vars))
         (this-lvars
           ($map1 (lambda (sym) ($lvar sym #f 0 0)) vars))
         (vars-length (length vars)))
        ($lambda
          (cons (source-info sexp)
                (cons name (dotpair->list (second sexp))))
          name
          (if optional-arg? (- vars-length 1) vars-length)
          (if optional-arg? 1 0)
          this-lvars
          (pass1/body->iform
            body
            library
            (append this-lvars lvars)
            #t)
          (quote ())
          (quote ()))))

(define libraries (make-eq-hashtable))

(define-macro
  (make-identifier alias libname name)
  (quasiquote
    (list (unquote alias)
          (unquote libname)
          (unquote name))))

(define
  (copy-identifier i)
  (list (first i) (second i) (third i)))

(define
  (library-name form)
  (remove-tail (second form) pair?))

(define
  (pass1/and->iform sexp library lvars tail?)
  (define
    (rec s)
    (match s
           (() ($const #t))
           ((s)
            (pass1/sexp->iform
              (pass1/expand s)
              library
              lvars
              tail?))
           ((e . more)
            ($if (pass1/sexp->iform
                   (pass1/expand e)
                   library
                   lvars
                   tail?)
                 (rec more)
                 ($it)))
           (else (error "syntax-error: malformed and:" sexp))))
  (rec (cdr sexp)))

(define
  (pass1/or->iform sexp library lvars tail?)
  (define
    (rec s)
    (match s
           (() ($const #f))
           ((s)
            (pass1/sexp->iform
              (pass1/expand s)
              library
              lvars
              tail?))
           ((e . more)
            ($if (pass1/sexp->iform
                   (pass1/expand e)
                   library
                   lvars
                   tail?)
                 ($it)
                 (rec more)))
           (else (error "syntax-error: malformed or:" sexp))))
  (rec (cdr sexp)))

(define
  (pass1/library->iform sexp library lvars)
  (define
    (get-identifier symbol libname imports)
    (aif (find-with-car symbol imports)
         (copy-identifier it)
         (make-identifier symbol libname symbol)))
  (define
    (get-rename-identifier
      rename-set
      libname
      imports)
    (aif (find-with-car (car rename-set) imports)
         (let1 identifier
               (copy-identifier it)
               (set-car! identifier (second rename-set))
               identifier)
         (make-identifier
           (second rename-set)
           libname
           (first rename-set))))
  (define
    (extract-exports imports libname form)
    (let loop
         ((export (cdr form)) (ret (quote ())))
         (cond ((null? export) ret)
               ((and (pair? (car export))
                     (eq? (caar export) (quote rename)))
                (loop (cdr export)
                      (append
                        ret
                        ($map1 (lambda
                                 (p)
                                 (get-rename-identifier p libname imports))
                               (cdar export)))))
               (else (loop (cdr export)
                           (cons (get-identifier (car export) libname imports)
                                 ret))))))
  (let1 lib
        ($library
          (library-name sexp)
          (quote ())
          (quote ())
          (quote ())
          (quote ())
          (quote ())
          #f)
        ($library.set-import!
          lib
          (pass1/import->iform (fourth sexp) lib))
        ($library.set-export-syms!
          lib
          (extract-exports
            ($library.import-syms lib)
            ($library.name lib)
            (third sexp)))
        ($library.set-body! lib (cddddr sexp))
        (hashtable-set!
          libraries
          ($library.name lib)
          lib)
        lib))

(define
  (pass1/import->iform sexp library)
  (define
    (library-name form)
    (libname->symbol (remove-tail form pair?)))
  (define
    (parse-level form)
    (cond ((symbol? form)
           (case form
                 ((expand) 1)
                 ((run) 0)
                 (else (error "unknown for"))))
          ((and (pair? form)
                (= (length form) 2)
                (eq? (first form) (quote meta)))
           (second form))
          (else (error "unknown level on meta"))))
  (define
    (import-iter form level)
    (case (first form)
          ((for)
           (import-iter
             (second form)
             (parse-level (third form))))
          ((only)
           (let1 only-binds
                 (cddr form)
                 (acond ((hashtable-ref
                           libraries
                           (library-name (second form))
                           #f)
                         ($library.add-import-syms!
                           library
                           ($filter-map1
                             (lambda
                               (x)
                               (if (memq (car x) only-binds)
                                   (copy-identifier x)
                                   #f))
                             ($library.export-syms it)))
                         ($import-spec ($library.name it) level))
                        (#t
                         (error "library "
                                (library-name (second form))
                                " not found")))))
          ((except)
           (let1 except-binds
                 (cddr form)
                 (acond ((hashtable-ref
                           libraries
                           (library-name (second form))
                           #f)
                         ($library.add-import-syms!
                           library
                           ($filter-map1
                             (lambda
                               (x)
                               (if (memq (car x) except-binds)
                                   #f
                                   (copy-identifier x)))
                             ($library.export-syms it)))
                         ($import-spec ($library.name it) level))
                        (#t
                         (error "library "
                                (library-name (second form))
                                " not found")))))
          ((rename)
           (let1 renames
                 (cddr form)
                 (acond ((hashtable-ref
                           libraries
                           (library-name (second form))
                           #f)
                         ($library.add-import-syms!
                           library
                           ($filter-map1
                             (lambda
                               (x)
                               (aif (find-with-car (first x) renames)
                                    (make-identifier
                                      (second it)
                                      (second x)
                                      (third x))
                                    (copy-identifier x)))
                             ($library.export-syms it)))
                         ($import-spec ($library.name it) level))
                        (#t
                         (error "library "
                                (library-name (second form))
                                " not found")))))
          ((prefix)
           (let1 prefix
                 (symbol->string (third form))
                 (acond ((hashtable-ref
                           libraries
                           (library-name (second form))
                           #f)
                         ($library.add-import-syms!
                           library
                           ($filter-map1
                             (lambda
                               (x)
                               (make-identifier
                                 (string->symbol
                                   (string-append
                                     prefix
                                     (symbol->string (first x))))
                                 (second x)
                                 (third x)))
                             ($library.export-syms it)))
                         ($import-spec ($library.name it) level))
                        (#t
                         (error "library "
                                (library-name (second form))
                                " not found")))))
          (else (acond ((hashtable-ref libraries (library-name form) #f)
                        ($library.add-import-syms!
                          library
                          ($map1 copy-identifier ($library.export-syms it)))
                        ($import-spec ($library.name it) level))
                       (#t
                        (error "library "
                               (library-name form)
                               " not found"))))))
  ($import
    ($map1 (lambda (i) (import-iter i 0)) (cdr sexp))))

(define
  (pass1/macroexpand sexp)
  (let1 proc
        (first sexp)
        (acond ((and (symbol? proc)
                     (assoc proc ($library.macro top-level-library)))
                (pass1/expand (vm/apply (cdr it) (cdr sexp))))
               (#t sexp))))

(define-macro
  (case-with-time val . clauses)
  (quasiquote
    (case (unquote val)
          (unquote-splicing
            (map (lambda
                   (clause)
                   (match clause
                          ((p . more)
                           (let1 temp
                                 (gensym)
                                 (quasiquote
                                   ((unquote p)
                                    (let1 (unquote temp)
                                          (get-timeofday)
                                          (let1 v
                                                (begin (unquote-splicing more))
                                                (dd "(log ")
                                                (dd (quote (unquote p)))
                                                (dd (unquote temp))
                                                (dd (get-timeofday))
                                                (dd ")
")
                                                v))))))))
                 clauses)))))

(define-macro
  (case-with-lambda val . clauses)
  (quasiquote
    (case (unquote val)
          (unquote-splicing
            (map (lambda
                   (clause)
                   (match clause
                          (((quote else) . more)
                           (quasiquote
                             (else ((lambda
                                      (else)
                                      (set! else 3)
                                      (unquote-splicing more))
                                    4))))
                          ((p . more)
                           (if (and (pair? p) (symbol? (car p)))
                               (let1 sym
                                     (string->symbol
                                       (string-append
                                         "profile-"
                                         (symbol->string (car p))))
                                     (quasiquote
                                       ((unquote p)
                                        ((lambda
                                           ((unquote sym))
                                           (set! (unquote sym) 3)
                                           (unquote-splicing more))
                                         4))))
                               (quasiquote
                                 ((unquote p)
                                  ((lambda
                                     (anonymous)
                                     (set! anonymous 3)
                                     (unquote-splicing more))
                                   4)))))))
                 clauses)))))

(define-macro
  (pass1/s->i sexp)
  (quasiquote
    (pass1/sexp->iform
      (pass1/expand (unquote sexp))
      library
      lvars
      tail?)))

(define-macro
  (pass1/map-s->i sexp)
  (quasiquote
    ($map1 (lambda (s) (pass1/s->i s))
           (unquote sexp))))

(define
  (pass1/call proc args library lvars tail?)
  (acond ((and (symbol? proc)
               (assoc proc ($library.macro library)))
          (pass1/s->i (vm/apply (cdr it) args)))
         ((and (symbol? proc)
               (find-with-car
                 proc
                 ($library.import-syms library)))
          (let* ((lib (hashtable-ref libraries (second it) #f))
                 (macro (assoc (third it) ($library.macro lib))))
                (if macro
                    (pass1/s->i (vm/apply (cdr macro) args))
                    ($call (pass1/s->i proc)
                           (pass1/map-s->i args)
                           tail?
                           #f))))
         (#t
          ($call (pass1/s->i proc)
                 (pass1/map-s->i args)
                 tail?
                 #f))))

(define
  (pass1/define sexp library lvars tail?)
  (match sexp
         (((quote define) name ((quote lambda) . more))
          (let1 closure
                (make-list-with-src-slot
                  (cons (quote lambda) more))
                (set-source-info!
                  closure
                  (source-info (third sexp)))
                ($define
                  ($library.name library)
                  name
                  (pass1/lambda->iform name closure library lvars))))
         (else ($define
                 ($library.name library)
                 (second sexp)
                 (pass1/s->i (third sexp))))))

(define
  (pass1/receive sexp library lvars tail?)
  (match sexp
         (((quote receive) vars vals . body)
          (receive
            (vars reqargs optarg)
            (parse-lambda-args vars)
            (let1 this-lvars
                  ($map1 (lambda (sym) ($lvar sym #f 0 0)) vars)
                  ($receive
                    this-lvars
                    reqargs
                    optarg
                    (pass1/s->i vals)
                    (pass1/body->iform
                      (pass1/expand body)
                      library
                      (append this-lvars lvars)
                      tail?)
                    tail?))))
         (else (syntax-error "malformed receive"))))

(define
  (pass1/let
    vars
    vals
    body
    source-info
    library
    lvars
    tail?)
  (let* ((inits (pass1/map-s->i vals))
         (this-lvars
           (map (lambda (sym init) ($lvar sym init 0 0))
                vars
                inits)))
        ($let (quote let)
              this-lvars
              inits
              (pass1/body->iform
                (pass1/expand body)
                library
                (append this-lvars lvars)
                tail?)
              tail?
              source-info)))

(define
  (pass1/letrec
    vars
    vals
    body
    source-info
    library
    lvars
    tail?)
  (let* ((this-lvars
           ($map1 (lambda (sym) ($lvar sym ($undef) 0 0))
                  vars))
         (inits ($map1 (lambda
                         (x)
                         (pass1/sexp->iform
                           x
                           library
                           (append this-lvars lvars)
                           tail?))
                       vals)))
        (for-each
          (lambda
            (lvar init)
            ($lvar.set-init-val! lvar init))
          this-lvars
          inits)
        ($let (quote rec)
              this-lvars
              inits
              (pass1/body->iform
                (pass1/expand body)
                library
                (append this-lvars lvars)
                tail?)
              tail?
              source-info)))

(define
  (pass1/if test then more library lvars tail?)
  ($if (pass1/sexp->iform
         (pass1/expand test)
         library
         lvars
         #f)
       (pass1/s->i then)
       (if (null? more)
           ($undef)
           (pass1/s->i (car more)))))

(define
  (pass1/define-macro sexp library lvars tail?)
  (if (pair? (second sexp))
      ($library.set-macro!
        library
        (alist-cons
          (caadr sexp)
          (compile-partial
            (quasiquote
              (lambda
                (unquote (cdadr sexp))
                (unquote (third sexp))))
            library)
          ($library.macro library)))
      ($library.set-macro!
        library
        (alist-cons
          (second sexp)
          (compile-partial (third sexp))
          ($library.macro library))))
  ($undef))

(define
  (pass1/asm-numcmp
    tag
    operator
    args
    library
    lvars
    tail?)
  (let1 len
        (length args)
        (cond ((> 2 len)
               (error operator " got too few argument"))
              ((= 2 len)
               ($asm tag
                     (list (pass1/s->i (first args))
                           (pass1/s->i (second args)))))
              (else (pass1/s->i
                      (conditions->if (apply-each-pair operator args)))))))

(define
  (pass1/asm-1-arg tag arg1 library lvars tail?)
  ($asm tag (list (pass1/s->i arg1))))

(define
  (pass1/asm-2-arg
    tag
    arg1
    arg2
    library
    lvars
    tail?)
  ($asm tag
        (list (pass1/s->i arg1) (pass1/s->i arg2))))

(define
  (pass1/asm-3-arg
    tag
    arg1
    arg2
    arg3
    library
    lvars
    tail?)
  ($asm tag
        (list (pass1/s->i arg1)
              (pass1/s->i arg2)
              (pass1/s->i arg3))))

(define
  (pass1/asm-1-arg-optional
    tag
    args
    library
    lvars
    tail?)
  (let1 arg1
        (if (null? args) (quote ()) (car args))
        ($asm tag (list (pass1/s->i arg1)))))

(define
  (pass1/asm-2-arg-optional
    tag
    arg1
    rest
    library
    lvars
    tail?)
  (let1 arg2
        (if (null? rest) (quote ()) (car rest))
        ($asm tag
              (list (pass1/s->i arg1) (pass1/s->i arg2)))))

(define
  (pass1/asm-n-args
    tag
    operator
    args
    library
    lvars
    tail?)
  (let1 len
        (length args)
        (cond ((zero? len)
               (case operator
                     ((+) (pass1/s->i 0))
                     ((*) (pass1/s->i 1))
                     (else (error operator " got too few argment"))))
              ((= 1 len)
               (case operator
                     ((-) (pass1/s->i (* -1 (car args))))
                     ((/)
                      (pass1/s->i
                        (quasiquote (/ 1 (unquote (car args))))))
                     (else (pass1/s->i (car args)))))
              ((= 2 len)
               ($asm tag
                     (list (pass1/s->i (first args))
                           (pass1/s->i (second args)))))
              (else (let1 args-iform
                          (pass1/map-s->i args)
                          (fold (lambda (x y) ($asm tag (list y x)))
                                (car args-iform)
                                (cdr args-iform)))))))

(define
  (pass1/sexp->iform sexp library lvars tail?)
  (cond ((pair? sexp)
         (case (car sexp)
               ((lambda)
                (pass1/lambda->iform
                  (quote lambda)
                  sexp
                  library
                  lvars))
               ((cons)
                ($asm (quote CONS) (pass1/map-s->i (cdr sexp))))
               ((and)
                (pass1/and->iform sexp library lvars tail?))
               ((or) (pass1/or->iform sexp library lvars tail?))
               ((begin)
                (pass1/body->iform
                  (pass1/expand (cdr sexp))
                  library
                  lvars
                  tail?))
               ((values)
                ($asm (quote VALUES) (pass1/map-s->i (cdr sexp))))
               ((define)
                (pass1/define sexp library lvars tail?))
               ((define-macro)
                (pass1/define-macro sexp library lvars tail?))
               ((receive)
                (pass1/receive sexp library lvars tail?))
               ((let)
                (pass1/let
                  ($map1 car (second sexp))
                  ($map1 cadr (second sexp))
                  (cddr sexp)
                  (source-info sexp)
                  library
                  lvars
                  tail?))
               ((letrec)
                (pass1/letrec
                  ($map1 car (second sexp))
                  ($map1 cadr (second sexp))
                  (cddr sexp)
                  (source-info sexp)
                  library
                  lvars
                  tail?))
               ((library)
                (pass1/library->iform sexp library lvars))
               ((import) (pass1/import->iform sexp library))
               ((set!)
                (pass1/assign
                  (second sexp)
                  (pass1/expand (third sexp))
                  library
                  lvars
                  tail?))
               ((if)
                (pass1/if
                  (second sexp)
                  (third sexp)
                  (cdddr sexp)
                  library
                  lvars
                  tail?))
               ((call/cc)
                ($call-cc (pass1/s->i (second sexp)) tail?))
               ((call-with-current-continuation)
                ($call-cc (pass1/s->i (second sexp)) tail?))
               ((quote) ($const (second sexp)))
               ((append)
                (pass1/asm-n-args
                  (quote APPEND2)
                  (quote dummy)
                  (cdr sexp)
                  library
                  lvars
                  tail?))
               ((+)
                (pass1/asm-n-args
                  (quote NUMBER_ADD)
                  (quote +)
                  (cdr sexp)
                  library
                  lvars
                  tail?))
               ((-)
                (pass1/asm-n-args
                  (quote NUMBER_SUB)
                  (quote -)
                  (cdr sexp)
                  library
                  lvars
                  tail?))
               ((*)
                (pass1/asm-n-args
                  (quote NUMBER_MUL)
                  (quote *)
                  (cdr sexp)
                  library
                  lvars
                  tail?))
               ((/)
                (pass1/asm-n-args
                  (quote NUMBER_DIV)
                  (quote /)
                  (cdr sexp)
                  library
                  lvars
                  tail?))
               ((=)
                (pass1/asm-numcmp
                  (quote NUMBER_EQUAL)
                  (quote =)
                  (cdr sexp)
                  library
                  lvars
                  tail?))
               ((>=)
                (pass1/asm-numcmp
                  (quote NUMBER_GE)
                  (quote >=)
                  (cdr sexp)
                  library
                  lvars
                  tail?))
               ((>)
                (pass1/asm-numcmp
                  (quote NUMBER_GT)
                  (quote >)
                  (cdr sexp)
                  library
                  lvars
                  tail?))
               ((<)
                (pass1/asm-numcmp
                  (quote NUMBER_LT)
                  (quote <)
                  (cdr sexp)
                  library
                  lvars
                  tail?))
               ((<=)
                (pass1/asm-numcmp
                  (quote NUMBER_LE)
                  (quote <=)
                  (cdr sexp)
                  library
                  lvars
                  tail?))
               ((vector?)
                (pass1/asm-1-arg
                  (quote VECTOR_P)
                  (second sexp)
                  library
                  lvars
                  tail?))
               ((vector-length)
                (pass1/asm-1-arg
                  (quote VECTOR_LENGTH)
                  (second sexp)
                  library
                  lvars
                  tail?))
               ((vector-set!)
                (pass1/asm-3-arg
                  (quote VECTOR_SET)
                  (second sexp)
                  (third sexp)
                  (fourth sexp)
                  library
                  lvars
                  tail?))
               ((vector-ref)
                (pass1/asm-2-arg
                  (quote VECTOR_REF)
                  (second sexp)
                  (third sexp)
                  library
                  lvars
                  tail?))
               ((make-vector)
                (pass1/asm-2-arg-optional
                  (quote MAKE_VECTOR)
                  (second sexp)
                  (cddr sexp)
                  library
                  lvars
                  tail?))
               ((car)
                (pass1/asm-1-arg
                  (quote CAR)
                  (second sexp)
                  library
                  lvars
                  tail?))
               ((cdr)
                (pass1/asm-1-arg
                  (quote CDR)
                  (second sexp)
                  library
                  lvars
                  tail?))
               ((caar)
                (pass1/asm-1-arg
                  (quote CAAR)
                  (second sexp)
                  library
                  lvars
                  tail?))
               ((cadr)
                (pass1/asm-1-arg
                  (quote CADR)
                  (second sexp)
                  library
                  lvars
                  tail?))
               ((cdar)
                (pass1/asm-1-arg
                  (quote CDAR)
                  (second sexp)
                  library
                  lvars
                  tail?))
               ((cddr)
                (pass1/asm-1-arg
                  (quote CDDR)
                  (second sexp)
                  library
                  lvars
                  tail?))
               ((set-car!)
                (pass1/asm-2-arg
                  (quote SET_CAR)
                  (second sexp)
                  (third sexp)
                  library
                  lvars
                  tail?))
               ((set-cdr!)
                (pass1/asm-2-arg
                  (quote SET_CDR)
                  (second sexp)
                  (third sexp)
                  library
                  lvars
                  tail?))
               ((eq?)
                (pass1/asm-2-arg
                  (quote EQ)
                  (second sexp)
                  (third sexp)
                  library
                  lvars
                  tail?))
               ((eqv?)
                (pass1/asm-2-arg
                  (quote EQV)
                  (second sexp)
                  (third sexp)
                  library
                  lvars
                  tail?))
               ((equal?)
                (pass1/asm-2-arg
                  (quote EQUAL)
                  (second sexp)
                  (third sexp)
                  library
                  lvars
                  tail?))
               ((not)
                (pass1/asm-1-arg
                  (quote NOT)
                  (second sexp)
                  library
                  lvars
                  tail?))
               ((null?)
                (pass1/asm-1-arg
                  (quote NULL_P)
                  (second sexp)
                  library
                  lvars
                  tail?))
               ((pair?)
                (pass1/asm-1-arg
                  (quote PAIR_P)
                  (second sexp)
                  library
                  lvars
                  tail?))
               ((symbol?)
                (pass1/asm-1-arg
                  (quote SYMBOL_P)
                  (second sexp)
                  library
                  lvars
                  tail?))
               ((read)
                (pass1/asm-1-arg-optional
                  (quote READ)
                  (cdr sexp)
                  library
                  lvars
                  tail?))
               ((read-char)
                (pass1/asm-1-arg-optional
                  (quote READ_CHAR)
                  (cdr sexp)
                  library
                  lvars
                  tail?))
               (else (pass1/call
                       (car sexp)
                       (cdr sexp)
                       library
                       lvars
                       tail?))))
        ((symbol? sexp)
         (pass1/refer->iform sexp library lvars))
        (else ($const sexp))))

(define
  (pretty-iform iform)
  (define labels (quote ()))
  (define
    (indent count)
    (dotimes (i count) (write-char #\space)))
  (define (nl ind) (newline) (indent ind))
  (define
    (lvar->string lvar)
    (format
      "~a[~a ~a]"
      ($lvar.sym lvar)
      ($lvar.ref-count lvar)
      ($lvar.set-count lvar)))
  (define
    (rec ind iform)
    (cond ((tag? iform $CONST)
           (format #t "($CONST ~s)" ($const.val iform)))
          ((tag? iform $UNDEF) (display "($UNDEF)"))
          ((tag? iform $LAMBDA)
           (format
             #t
             "($LAMBDA[~a ~a ~a]"
             ($lambda.name iform)
             (map lvar->string ($lambda.lvars iform))
             ($lambda.flag iform))
           (nl (+ ind 2))
           (rec (+ ind 2) ($lambda.body iform))
           (display ")"))
          ((tag? iform $SEQ)
           (format #t "($SEQ")
           (for-each
             (lambda
               (node)
               (nl (+ ind 2))
               (rec (+ ind 2) node))
             ($seq.body iform))
           (display ")"))
          ((tag? iform $LIBRARY)
           (format
             #t
             "($LIBRARY ~a export [~a] import [~a]"
             ($library.name iform)
             ($library.export-syms iform)
             ($library.import-syms iform))
           (nl (+ ind 2))
           (display ")"))
          ((tag? iform $LOCAL-REF)
           (format
             #t
             "($LOCAL-REF ~a)"
             (lvar->string ($local-ref.lvar iform))))
          ((tag? iform $GLOBAL-REF)
           (format
             #t
             "($GLOBAL-REF ~a ~a)"
             ($global-ref.libname iform)
             ($global-ref.sym iform)))
          ((tag? iform $LOCAL-ASSIGN)
           (format
             #t
             "($LOCAL-ASSIGN ~a"
             (lvar->string ($local-assign.lvar iform)))
           (nl (+ ind 2))
           (rec (+ ind 2) ($local-assign.val iform))
           (display ")"))
          ((tag? iform $GLOBAL-ASSIGN)
           (format
             #t
             "($GLOBAL-ASSIGN ~a ~a)"
             ($global-assign.sym iform)
             ($global-assign.val iform)))
          ((tag? iform $LET)
           (let* ((hdr (format "($LET ("))
                  (xind (+ ind (string-length hdr))))
                 (display hdr)
                 (for-each
                   (lambda
                     (var init)
                     (let1 z
                           (format "(~a " (lvar->string var))
                           (display z)
                           (rec (+ xind (string-length z)) init)
                           (display ")")
                           (nl xind)))
                   ($let.lvars iform)
                   ($let.inits iform))
                 (display ")")
                 (nl (+ ind 2))
                 (rec (+ ind 2) ($let.body iform))
                 (display ")")))
          ((tag? iform $IF)
           (display "($IF ")
           (rec (+ ind 5) ($if.test iform))
           (nl (+ ind 2))
           (rec (+ ind 2) ($if.then iform))
           (nl (+ ind 2))
           (rec (+ ind 2) ($if.else iform))
           (display ")"))
          ((tag? iform $LABEL)
           (cond ((assq iform labels)
                  =>
                  (lambda (p) (format #t "label#~a" (cdr p))))
                 (else (let1 num
                             (length labels)
                             (push! labels (cons iform num))
                             (format #t "($label #~a" num)
                             (nl (+ ind 2))
                             (rec (+ ind 2) ($label.body iform))
                             (display ")")))))
          ((tag? iform $ASM)
           (let1 insn
                 ($asm.insn iform)
                 (format #t "($asm ~a" insn))
           (for-each
             (lambda
               (node)
               (nl (+ ind 2))
               (rec (+ ind 2) node))
             ($asm.args iform))
           (display ")"))
          ((tag? iform $DEFINE)
           (format
             #t
             "($DEFINE ~a:~a"
             ($define.libname iform)
             ($define.sym iform))
           (nl (+ ind 2))
           (rec (+ ind 2) ($define.val iform))
           (display ")"))
          ((tag? iform $CALL-CC)
           (display "($CALL-CC ")
           (rec 0 ($call-cc.proc iform))
           (display ")"))
          ((tag? iform $LABEL)
           (display "($LABEL ")
           (rec 0 ($label.body iform))
           (display ")"))
          ((tag? iform $CALL)
           (let1 pre
                 (cond (($call.tail? iform)
                        =>
                        (lambda (x) "($call[tail] "))
                       (else "($call "))
                 (format #t pre)
                 (format #t "[~a]" ($call.type iform))
                 (rec (+ ind (string-length pre))
                      ($call.proc iform))
                 (for-each
                   (lambda
                     (node)
                     (nl (+ ind 2))
                     (rec (+ ind 2) node))
                   ($call.args iform))
                 (display ")")))
          (else (error "pretty-iform: unknown tag:" (tag iform)))))
  (rec 0 iform)
  (newline))

(define SMALL_LAMBDA_SIZE 12)

(define
  pass2/dispatch-table
  (make-vector $INSN-NUM))

(define
  (pass2/$let iform closures)
  ($let.set-body!
    iform
    (pass2/optimize ($let.body iform) closures))
  ($let.set-inits!
    iform
    ($map1 (lambda (i) (pass2/optimize i closures))
           ($let.inits iform)))
  (let1 o
        (pass2/eliminate-let iform)
        (if (eq? o iform) o (pass2/optimize o closures))))

(define
  (pass2/$receive iform closures)
  ($receive.set-body!
    iform
    (pass2/optimize ($receive.body iform) closures))
  ($receive.set-vals!
    iform
    (pass2/optimize ($receive.vals iform) closures))
  iform)

(define
  (pass2/$local-ref iform closures)
  (pass2/optimize-local-ref iform)
  iform)

(define
  (pass2/$seq iform closures)
  ($seq.set-body!
    iform
    ($map1 (lambda (x) (pass2/optimize x closures))
           ($seq.body iform)))
  iform)

(define
  (pass2/const-inliner iform)
  (let ((insn ($asm.insn iform))
        (args ($asm.args iform)))
       (case insn
             ((NUMBER_ADD)
              (when (and (tag? (first args) $CONST)
                         (tag? (second args) $CONST))
                    (vector-set! iform 0 $CONST)
                    ($const.set-val!
                      iform
                      (+ ($const.val (first args))
                         ($const.val (second args))))))
             ((NUMBER_MUL)
              (when (and (tag? (first args) $CONST)
                         (tag? (second args) $CONST))
                    (vector-set! iform 0 $CONST)
                    ($const.set-val!
                      iform
                      (* ($const.val (first args))
                         ($const.val (second args))))))
             ((NUMBER_MINUS)
              (when (and (tag? (first args) $CONST)
                         (tag? (second args) $CONST))
                    (vector-set! iform 0 $CONST)
                    ($const.set-val!
                      iform
                      (- ($const.val (first args))
                         ($const.val (second args))))))
             (else #f))))

(define
  (pass2/$asm iform closures)
  ($asm.set-args!
    iform
    ($map1 (lambda (x) (pass2/optimize x closures))
           ($asm.args iform)))
  (pass2/const-inliner iform)
  iform)

(define
  (pass2/$lambda iform closures)
  ($lambda.set-body!
    iform
    (pass2/optimize
      ($lambda.body iform)
      (cons iform closures)))
  iform)

(define
  (pass2/$if iform closures)
  (let ((test-c
          (pass2/optimize ($if.test iform) closures))
        (then-c
          (pass2/optimize ($if.then iform) closures))
        (else-c
          (pass2/optimize ($if.else iform) closures)))
       ($if test-c then-c else-c)))

(define
  (pass2/$call iform closures)
  (pass2/collect-call iform closures))

(define (pass2/empty iform closures) iform)

(define
  (pass2/register insn proc)
  (vector-set! pass2/dispatch-table insn proc))

(pass2/register $CONST pass2/empty)

(pass2/register $LAMBDA pass2/$lambda)

(pass2/register $LOCAL-REF pass2/$local-ref)

(pass2/register $LOCAL-ASSIGN pass2/empty)

(pass2/register $GLOBAL-ASSIGN pass2/empty)

(pass2/register $GLOBAL-REF pass2/empty)

(pass2/register $SEQ pass2/$seq)

(pass2/register $UNDEF pass2/empty)

(pass2/register $IF pass2/$if)

(pass2/register $ASM pass2/$asm)

(pass2/register $DEFINE pass2/empty)

(pass2/register $CALL pass2/$call)

(pass2/register $CALL-CC pass2/empty)

(pass2/register $LET pass2/$let)

(pass2/register $LIST pass2/empty)

(pass2/register $LIBRARY pass2/empty)

(pass2/register $IMPORT pass2/empty)

(pass2/register $IT pass2/empty)

(pass2/register $RECEIVE pass2/$receive)

(define
  (pass2/optimize iform closures)
  ((vector-ref
     pass2/dispatch-table
     (vector-ref iform 0))
   iform
   closures))

(define
  (pass2/optimize-local-ref iform)
  (let* ((lvar ($local-ref.lvar iform))
         (init-val ($lvar.init-val lvar)))
        (cond ((and init-val
                    (zero? ($lvar.set-count lvar))
                    (tag? init-val $CONST))
               (set-tag! iform $CONST)
               ($lvar.ref-count--! lvar)
               ($const.set-val! iform ($const.val init-val)))
              ((and init-val
                    (tag? init-val $LOCAL-REF)
                    (zero? ($lvar.set-count ($local-ref.lvar init-val))))
               ($lvar.ref-count--! lvar)
               ($lvar.ref-count++! ($local-ref.lvar init-val))
               ($local-ref.copy iform init-val)
               (pass2/optimize-local-ref iform))
              (else iform))))

(define
  (pass2/eliminate-let iform)
  (let ((vars ($let.lvars iform))
        (inits ($let.inits iform))
        (body ($let.body iform)))
       (for-each pass2/optimize-closure vars inits)
       (let* ((v (pass2/remove-vars vars inits))
              (new-vars (vector-ref v 0))
              (new-inits (vector-ref v 1))
              (removed-inits (vector-ref v 2)))
             (cond ((null? new-vars)
                    (if (null? removed-inits)
                        body
                        ($seq (append removed-inits (list body))
                              ($let.tail? iform))))
                   (else ($let.set-lvars! iform new-vars)
                         ($let.set-inits! iform new-inits)
                         ($let.set-body! iform body)
                         (unless
                           (null? removed-inits)
                           (if (tag? body $SEQ)
                               ($seq.set-body!
                                 body
                                 (append removed-inits ($seq.body body)))
                               ($let.set-body!
                                 iform
                                 ($seq (append removed-inits (list body))
                                       ($let.tail? iform)))))
                         iform)))))

(define
  (iform-copy-zip-lvs orig-lvars lv-alist)
  (let1 new-lvars
        ($map1 (lambda (lv) (make-lvar ($lvar.sym lv)))
               orig-lvars)
        (cons new-lvars
              (foldr2 alist-cons lv-alist orig-lvars new-lvars))))

(define
  (iform-copy-lvar lvar lv-alist)
  (cond ((assq lvar lv-alist) => (lambda (p) (cdr p)))
        (else lvar)))

(define
  (iform-copy iform lv-alist)
  (let1 t
        (tag iform)
        (cond ((= $DEFINE t)
               ($define
                 ($define.libname iform)
                 ($define.sym iform)
                 (iform-copy ($define.val iform) lv-alist)))
              ((= $LOCAL-REF t)
               ($local-ref
                 (iform-copy-lvar
                   ($local-ref.lvar iform)
                   lv-alist)))
              ((= $LOCAL-ASSIGN t)
               ($local-assign
                 (iform-copy-lvar
                   ($local-assign.lvar iform)
                   lv-alist)
                 (iform-copy ($local-assign.val iform) lv-alist)))
              ((= $GLOBAL-REF t)
               ($global-ref
                 ($global-ref.libname iform)
                 ($global-ref.sym iform)))
              ((= $GLOBAL-ASSIGN t)
               ($global-assign
                 ($global-assign.libname iform)
                 ($global-assign.sym iform)
                 (iform-copy ($global-assign.val iform) lv-alist)))
              ((= $CONST t) ($const ($const.val iform)))
              ((= $IF t)
               ($if (iform-copy ($if.test iform) lv-alist)
                    (iform-copy ($if.then iform) lv-alist)
                    (iform-copy ($if.else iform) lv-alist)))
              ((= $LET t)
               (let* ((ret (iform-copy-zip-lvs ($let.lvars iform) lv-alist))
                      (newlvs (car ret))
                      (newalist (cdr ret)))
                     ($let ($let.type iform)
                           newlvs
                           (let1 al
                                 (case ($let.type iform)
                                       ((let) lv-alist)
                                       ((rec) newalist))
                                 ($map1 (lambda (x) (iform-copy x al))
                                        ($let.inits iform)))
                           (iform-copy ($let.body iform) newalist)
                           ($let.tail? iform)
                           ($let.src iform))))
              ((= $LAMBDA t)
               (let* ((ret (iform-copy-zip-lvs
                             ($lambda.lvars iform)
                             lv-alist))
                      (newlvs (car ret))
                      (newalist (cdr ret)))
                     ($lambda
                       ($lambda.src iform)
                       ($lambda.name iform)
                       ($lambda.reqargs iform)
                       ($lambda.optarg iform)
                       newlvs
                       (iform-copy ($lambda.body iform) newalist)
                       ($lambda.flag iform)
                       ($lambda.calls iform))))
              ((= $SEQ t)
               ($seq ($map1 (lambda (x) (iform-copy x lv-alist))
                            ($seq.body iform))
                     ($seq.tail? iform)))
              ((= $CALL t)
               ($call (iform-copy ($call.proc iform) lv-alist)
                      ($map1 (lambda (x) (iform-copy x lv-alist))
                             ($call.args iform))
                      #f
                      ($call.type iform)))
              ((= $ASM t)
               ($asm ($asm.insn iform)
                     ($map1 (lambda (x) (iform-copy x lv-alist))
                            ($asm.args iform))))
              (else iform))))

(define
  (pass2/optimize-closure lvar lambda-node)
  (when (and (zero? ($lvar.set-count lvar))
             (> ($lvar.ref-count lvar) 0)
             (tag? lambda-node $LAMBDA))
        (or (and (= ($lvar.ref-count lvar)
                    (length ($lambda.calls lambda-node)))
                 (let* ((ret (pass2/classify-calls
                               ($lambda.calls lambda-node)
                               lambda-node))
                        (locals (first ret))
                        (recs (second ret))
                        (tail-recs (third ret)))
                       (and (null? recs)
                            (pair? locals)
                            (or (and (null? (cdr locals))
                                     (pass2/local-call-embedder
                                       lvar
                                       lambda-node
                                       (car locals)
                                       tail-recs))
                                (and (null? tail-recs)
                                     (< (iform-count-size-upto
                                          lambda-node
                                          SMALL_LAMBDA_SIZE)
                                        SMALL_LAMBDA_SIZE)
                                     (pass2/local-call-inliner
                                       lvar
                                       lambda-node
                                       locals))))))
            (pass2/local-call-optimizer lvar lambda-node))))

(define-macro
  (sum-items cnt . items)
  (if (null? items)
      cnt
      (let1 target-list?
            (and (pair? (car items))
                 (eq? (caar items) (quote *)))
            (quasiquote
              (let1 s1
                    ((unquote
                       (if target-list? (quote rec-list) (quote rec)))
                     (unquote
                       (if target-list? (cadar items) (car items)))
                     (unquote cnt))
                    (if (>= s1 limit)
                        limit
                        (sum-items s1 (unquote-splicing (cdr items)))))))))

(define
  (iform-count-size-upto iform limit)
  (define
    (rec iform cnt)
    (let1 t
          (tag iform)
          (cond ((= $DEFINE t)
                 (sum-items (+ cnt 1) ($define.val iform)))
                ((= $LOCAL-REF t) (+ cnt 1))
                ((= $GLOBAL-REF t) (+ cnt 1))
                ((= $CONST t) (+ cnt 1))
                ((= $LOCAL-ASSIGN t)
                 (sum-items (+ cnt 1) ($local-assign.val iform)))
                ((= $GLOBAL-ASSIGN t)
                 (sum-items (+ cnt 1) ($global-assign.val iform)))
                ((= $IF t)
                 (sum-items
                   (+ cnt 1)
                   ($if.test iform)
                   ($if.then iform)
                   ($if.else iform)))
                ((= $LET t)
                 (sum-items
                   (+ cnt 1)
                   (* ($let.inits iform))
                   ($let.body iform)))
                ((= $LAMBDA t)
                 (sum-items (+ cnt 1) ($lambda.body iform)))
                ((= $LABEL t)
                 (sum-items cnt ($label.body iform)))
                ((= $SEQ t)
                 (sum-items cnt (* ($seq.body iform))))
                ((= $CALL t)
                 (sum-items
                   (+ cnt 1)
                   ($call.proc iform)
                   (* ($call.args iform))))
                ((= $ASM t)
                 (sum-items (+ cnt 1) (* ($asm.args iform))))
                (else (error "[internal error] iform-count-size-upto: unknown iform tag:"
                             (tag iform))))))
  (define
    (rec-list iform-list cnt)
    (cond ((null? iform-list) cnt)
          ((>= cnt limit) limit)
          (else (rec-list
                  (cdr iform-list)
                  (rec (car iform-list) cnt)))))
  (rec iform 0))

(define
  (adjust-arglist reqargs optarg iargs name)
  (unless
    (argcount-ok? iargs reqargs (> optarg 0))
    (errorf
      "wrong number of arguments: ~a requires ~a, but got ~a at ~a"
      name
      reqargs
      (length iargs)
      (source-info iargs)))
  (if (zero? optarg)
      iargs
      (receive
        (reqs opts)
        (split-at iargs reqargs)
        (append reqs (list ($list opts))))))

(define
  (argcount-ok? args reqargs optarg?)
  (let1 nargs
        (length args)
        (or (and (not optarg?) (= nargs reqargs))
            (and optarg? (>= nargs reqargs)))))

(define
  (pass2/local-call-inliner lvar lambda-node calls)
  (define
    (inline-it call-node lambda-node)
    (let1 inlined
          (pass2/expand-inlined-procedure
            lambda-node
            ($call.args call-node))
          (vector-set! call-node 0 $SEQ)
          (if (tag? inlined $SEQ)
              ($seq.set-body! call-node ($seq.body inlined))
              ($seq.set-body! call-node (list inlined)))))
  ($lvar.set-ref-count! lvar 0)
  ($lambda.set-flag! lambda-node (quote dissolved))
  (let loop
       ((calls calls))
       (cond ((null? (cdr calls))
              (inline-it (car calls) lambda-node))
             (else (inline-it
                     (car calls)
                     (iform-copy lambda-node (quote ())))
                   (loop (cdr calls))))))

(define
  (pass2/local-call-embedder
    lvar
    lambda-node
    call
    rec-calls)
  (let ((reqargs ($lambda.reqargs lambda-node))
        (optarg ($lambda.optarg lambda-node))
        (name ($lambda.name lambda-node)))
       ($call.set-args!
         call
         (adjust-arglist
           reqargs
           optarg
           ($call.args call)
           name))
       ($lvar.ref-count--! lvar)
       ($call.set-type! call (quote embed))
       ($call.set-proc! call lambda-node)
       ($lambda.set-flag! lambda-node (quote dissolved))
       (unless
         (null? rec-calls)
         (let1 body
               ($label ($lambda.body lambda-node))
               ($lambda.set-body! lambda-node body)
               (dolist
                 (jcall rec-calls)
                 ($lvar.ref-count--! lvar)
                 ($call.set-args!
                   jcall
                   (adjust-arglist
                     reqargs
                     optarg
                     ($call.args jcall)
                     name))
                 ($call.set-proc! jcall call)
                 ($call.set-type! jcall (quote jump)))))))

(define
  (pass2/local-call-optimizer lvar lambda-node)
  (let ((reqargs ($lambda.reqargs lambda-node))
        (optarg ($lambda.optarg lambda-node))
        (name ($lambda.name lambda-node))
        (calls ($lambda.calls lambda-node)))
       (dolist
         (call calls)
         ($call.set-args!
           (car call)
           (adjust-arglist
             reqargs
             optarg
             ($call.args (car call))
             name))
         ($call.set-type! (car call) (quote local)))
       ($lambda.set-calls! lambda-node (quote ()))))

(define
  (pass2/classify-calls call&envs lambda-node)
  (define
    (direct-call? env)
    (let loop
         ((env env))
         (cond ((null? env) #t)
               ((eq? (car env) lambda-node) #t)
               ((eq? ($lambda.flag (car env)) (quote dissolved))
                (loop (cdr env)))
               (else #f))))
  (let loop
       ((call&envs call&envs)
        (local (quote ()))
        (rec (quote ()))
        (trec (quote ())))
       (match call&envs
              (() (list local rec trec))
              (((call . env) . more)
               (case ($call.type call)
                     ((tail-rec)
                      (if (direct-call? env)
                          (loop more local rec (cons call trec))
                          (loop more local (cons call rec) trec)))
                     ((rec) (loop more local (cons call rec) trec))
                     (else (loop more (cons call local) rec trec)))))))

(define
  (pass2/remove-vars vars init-iforms)
  (let loop
       ((vars vars)
        (init-iforms init-iforms)
        (rl (quote ()))
        (ri (quote ()))
        (rr (quote ())))
       (cond ((null? vars)
              (quasiquote
                #((unquote (reverse rl))
                  (unquote (reverse ri))
                  (unquote (reverse rr)))))
             ((and (= 0 ($lvar.ref-count (car vars)))
                   (zero? ($lvar.set-count (car vars))))
              (cond ((tag? (car init-iforms) $LOCAL-REF)
                     ($lvar.ref-count--!
                       ($local-ref.lvar (car init-iforms)))))
              (loop (cdr vars)
                    (cdr init-iforms)
                    rl
                    ri
                    (if (memq (tag (car init-iforms))
                              (quasiquote
                                ((unquote $CONST)
                                 (unquote $LOCAL-REF)
                                 (unquote $LAMBDA))))
                        rr
                        (cons (car init-iforms) rr))))
             (else (loop (cdr vars)
                         (cdr init-iforms)
                         (cons (car vars) rl)
                         (cons (car init-iforms) ri)
                         rr)))))

(define
  (pass2/self-recursing? closure closures)
  (memq closure closures))

(define
  (pass2/classify-local-ref-call
    iform
    closures
    tail?)
  (let1 lvar
        ($local-ref.lvar iform)
        (if (> ($lvar.set-count lvar) 0) (quote local))
        (let1 init-val
              ($lvar.init-val lvar)
              (cond ((and init-val (tag? init-val $LAMBDA))
                     (cond ((pass2/self-recursing? init-val closures)
                            (if tail? (quote tail-rec) (quote rec)))
                           ((= ($lvar.ref-count lvar) 1)
                            ($lvar.ref-count--! lvar)
                            ($lvar.set-init-val! lvar (quote ()))
                            init-val)
                           (else (quote local))))
                    (else #f)))))

(define
  (pass2/expand-inlined-procedure iform iargs)
  (let ((lvars ($lambda.lvars iform))
        (args (pass2/adjust-arglist
                ($lambda.reqargs iform)
                ($lambda.optarg iform)
                iargs
                ($lambda.name iform))))
       (for-each
         (lambda (lv a) ($lvar.set-init-val! lv a))
         lvars
         args)
       ($let (quote let)
             lvars
             args
             ($lambda.body iform)
             #f
             #f)))

(define
  (pass2/argcount-ok? args reqargs optarg?)
  (let1 nargs
        (length args)
        (or (and (not optarg?) (= nargs reqargs))
            (and optarg? (>= nargs reqargs)))))

(define
  (pass2/adjust-arglist reqargs optarg iargs name)
  (unless
    (pass2/argcount-ok? iargs reqargs (> optarg 0))
    (errorf
      "wrong number of arguments: ~a requires ~a, but got ~a at ~a"
      name
      reqargs
      (length iargs)
      (source-info iargs)))
  (if (zero? optarg)
      iargs
      (let* ((ret-args (pass2/split-args iargs reqargs))
             (reqs (car ret-args))
             (opts (cdr ret-args)))
            (append reqs (list ($list opts))))))

(define
  (pass2/split-args args reqargs)
  (let loop
       ((i reqargs) (rest args) (r (quote ())))
       (cond ((= i 0) (cons (reverse r) rest))
             ((null? rest)
              (error "given list is too short:" args))
             (else (loop (- i 1) (cdr rest) (cons (car rest) r))))))

(define
  (pass2/collect-call iform closures)
  (cond (($call.type iform) iform)
        (else (let ((proc ($call.proc iform))
                    (args ($call.args iform)))
                   (cond ((tag? proc $LAMBDA)
                          (pass2/optimize
                            (pass2/expand-inlined-procedure proc args)
                            closures))
                         ((and (tag? proc $LOCAL-REF)
                               (pass2/classify-local-ref-call
                                 proc
                                 closures
                                 ($call.tail? iform)))
                          =>
                          (lambda
                            (type)
                            (cond ((vector? type)
                                   ($call.set-proc! iform type)
                                   (let1 o
                                         (pass2/expand-inlined-procedure
                                           type
                                           args)
                                         (pass2/optimize o closures)
                                         o))
                                  ((not type) iform)
                                  (else (let1 lambda-iform
                                              ($lvar.init-val
                                                ($local-ref.lvar proc))
                                              ($call.set-type! iform type)
                                              ($lambda.set-calls!
                                                lambda-iform
                                                (cons (cons iform closures)
                                                      ($lambda.calls
                                                        lambda-iform)))
                                              ($call.set-args!
                                                iform
                                                ($map1 (lambda
                                                         (x)
                                                         (pass2/optimize
                                                           x
                                                           closures))
                                                       args))
                                              iform)))))
                         (else ($call.set-args!
                                 iform
                                 ($map1 (lambda
                                          (x)
                                          (pass2/optimize x closures))
                                        args))
                               iform))))))

(define
  (pass3/exists-in-can-frees? sym can-frees)
  (if (null? can-frees)
      #f
      (if (memq sym (car can-frees))
          #t
          (pass3/exists-in-can-frees? sym (cdr can-frees)))))

(define
  (pass3/find-free iform locals can-frees)
  (define
    (rec i l labels-seen)
    (let1 t
          (tag i)
          (cond ((= $CONST t) (quote ()))
                ((= $LET t)
                 (append
                   ($append-map1
                     (lambda (fm) (rec fm l labels-seen))
                     ($let.inits i))
                   (rec ($let.body i) ($let.lvars i) labels-seen)))
                ((= $RECEIVE t)
                 (append
                   (rec ($receive.vals i) l labels-seen)
                   (rec ($receive.body i)
                        ($receive.lvars i)
                        labels-seen)))
                ((= $SEQ t)
                 ($append-map1
                   (lambda (fm) (rec fm l labels-seen))
                   ($seq.body i)))
                ((= $LAMBDA t)
                 (rec ($lambda.body i)
                      ($lambda.lvars i)
                      labels-seen))
                ((= $LOCAL-ASSIGN t)
                 (let1 sym
                       ($lvar.sym ($local-assign.lvar i))
                       (if (pass3/exists-in-can-frees? sym can-frees)
                           (cons sym
                                 (rec ($local-assign.val i) l labels-seen))
                           (rec ($local-assign.val i) l labels-seen))))
                ((= $LOCAL-REF t)
                 (let1 sym
                       ($lvar.sym ($local-ref.lvar i))
                       (cond ((memq sym l) (quote ()))
                             ((pass3/exists-in-can-frees? sym can-frees)
                              (list sym))
                             (else (quote ())))))
                ((= $GLOBAL-REF t)
                 (let* ((sym ($global-ref.sym i))
                        (found (pass3/exists-in-can-frees? sym can-frees)))
                       (if found (list sym) (quote ()))))
                ((= $UNDEF t) (quote ()))
                ((= $IF t)
                 (append
                   (rec ($if.test i) l labels-seen)
                   (append
                     (rec ($if.then i) l labels-seen)
                     (rec ($if.else i) l labels-seen))))
                ((= $ASM t)
                 ($append-map1
                   (lambda (fm) (rec fm l labels-seen))
                   ($asm.args i)))
                ((= $DEFINE t)
                 (rec ($define.val i) l labels-seen))
                ((= $CALL t)
                 (append
                   ($append-map1
                     (lambda (fm) (rec fm l labels-seen))
                     ($call.args i))
                   (rec ($call.proc i) l labels-seen)))
                ((= $CALL-CC t)
                 (rec ($call-cc.proc i) l labels-seen))
                ((= $GLOBAL-ASSIGN t)
                 (rec ($global-assign.val i) l labels-seen))
                ((= $LIST t)
                 ($append-map1
                   (lambda (fm) (rec fm l labels-seen))
                   ($list.args i)))
                ((= $LABEL t)
                 (if (memq i labels-seen)
                     (quote ())
                     (rec ($label.body i) l (cons i labels-seen))))
                ((= $IMPORT t) (quote ()))
                ((= $LIBRARY t) (quote ()))
                ((= $IT t) (quote ()))
                (else (error "pass3/find-free unknown iform:" (tag i))))))
  (uniq (rec iform locals (quote ()))))

(define
  (pass3/find-sets iform lvars)
  (define
    (rec i)
    (let1 t
          (tag i)
          (cond ((= $CONST t) (quote ()))
                ((= $LET t)
                 (append
                   ($append-map1 rec ($let.inits i))
                   (rec ($let.body i))))
                ((= $RECEIVE t)
                 (append
                   (rec ($receive.vals i))
                   (rec ($receive.body i))))
                ((= $SEQ t) ($append-map1 rec ($seq.body i)))
                ((= $LAMBDA t) (rec ($lambda.body i)))
                ((= $LOCAL-ASSIGN t)
                 (let1 lvar
                       ($local-assign.lvar i)
                       (append
                         (if (memq lvar lvars) (list lvar) (quote ()))
                         (rec ($local-assign.val i)))))
                ((= $LOCAL-REF t) (quote ()))
                ((= $GLOBAL-REF t) (quote ()))
                ((= $UNDEF t) (quote ()))
                ((= $IF t)
                 (append
                   (rec ($if.test i))
                   (rec ($if.then i))
                   (rec ($if.else i))))
                ((= $ASM t) ($append-map1 rec ($asm.args i)))
                ((= $DEFINE t) (rec ($define.val i)))
                ((= $CALL t)
                 (append
                   ($append-map1 rec ($call.args i))
                   (rec ($call.proc i))))
                ((= $CALL-CC t) (rec ($call-cc.proc i)))
                ((= $GLOBAL-ASSIGN t)
                 (rec ($global-assign.val i)))
                ((= $LIST t) ($append-map1 rec ($list.args i)))
                ((= $LABEL t) (quote ()))
                ((= $IMPORT t) (quote ()))
                ((= $LIBRARY t) (quote ()))
                ((= $IT t) (quote ()))
                (else (error "pass3/find-sets unknown iform:" i)))))
  (uniq (rec iform)))

(define-macro
  (cput! cb . more)
  (match more
         (() (quote ()))
         ((a b c d e . f)
          (quasiquote
            (begin (code-builder-put-extra5!
                     (unquote cb)
                     (unquote a)
                     (unquote b)
                     (unquote c)
                     (unquote d)
                     (unquote e))
                   (cput! (unquote cb) (unquote-splicing f)))))
         ((a b c d . e)
          (quasiquote
            (begin (code-builder-put-extra4!
                     (unquote cb)
                     (unquote a)
                     (unquote b)
                     (unquote c)
                     (unquote d))
                   (cput! (unquote cb) (unquote-splicing e)))))
         ((a b c . d)
          (quasiquote
            (begin (code-builder-put-extra3!
                     (unquote cb)
                     (unquote a)
                     (unquote b)
                     (unquote c))
                   (cput! (unquote cb) (unquote-splicing d)))))
         ((a b . c)
          (quasiquote
            (begin (code-builder-put-extra2!
                     (unquote cb)
                     (unquote a)
                     (unquote b))
                   (cput! (unquote cb) (unquote-splicing c)))))
         ((a . b)
          (quasiquote
            (begin (code-builder-put-extra1!
                     (unquote cb)
                     (unquote a))
                   (cput! (unquote cb) (unquote-splicing b)))))))

(define-macro
  (pass3/add-sets! sets new-sets)
  (quasiquote
    (if (null? (unquote new-sets))
        (unquote sets)
        (hashtable-set-true!
          (eq-hashtable-copy (unquote sets))
          (unquote new-sets)))))

(define
  (pass3/collect-free cb frees-here locals frees)
  (let loop
       ((size 0) (reversed-frees (reverse frees-here)))
       (cond ((null? reversed-frees) size)
             (else (let1 stack-size
                         (pass3/compile-refer
                           cb
                           (car reversed-frees)
                           locals
                           frees)
                         (code-builder-put-insn-arg0! cb (quote PUSH))
                         (loop (+ size stack-size) (cdr reversed-frees)))))))

(define
  (pass3/symbol-lookup
    cb
    lvar
    locals
    frees
    return-local
    return-free)
  (let next-local
       ((locals locals) (n 0))
       (if (null? locals)
           (let next-free
                ((free frees) (n 0))
                (cond ((null? free)
                       (error "pass3/symbol-lookup bug? Unknown lvar:"
                              lvar))
                      ((eq? (car free) lvar) (return-free cb n))
                      (else (next-free (cdr free) (+ n 1)))))
           (if (eq? (car locals) lvar)
               (return-local cb n)
               (next-local (cdr locals) (+ n 1))))))

(define
  (pass3/return-refer-local cb n)
  (code-builder-put-insn-arg1!
    cb
    (quote REFER_LOCAL)
    n)
  0)

(define
  (pass3/return-refer-free cb n)
  (code-builder-put-insn-arg1!
    cb
    (quote REFER_FREE)
    n)
  0)

(define
  (pass3/compile-refer cb lvar locals frees)
  (pass3/symbol-lookup
    cb
    lvar
    locals
    frees
    pass3/return-refer-local
    pass3/return-refer-free))

(define
  (pass3/return-assign-local cb n)
  (code-builder-put-insn-arg1!
    cb
    (quote ASSIGN_LOCAL)
    n)
  0)

(define
  (pass3/return-assign-free cb n)
  (code-builder-put-insn-arg1!
    cb
    (quote ASSIGN_FREE)
    n)
  0)

(define
  (pass3/compile-assign cb lvar locals frees)
  (pass3/symbol-lookup
    cb
    lvar
    locals
    frees
    pass3/return-assign-local
    pass3/return-assign-free))

(define
  (pass3/make-boxes cb sets vars)
  ($for-each1-with-rindex
    (lambda
      (index var)
      (if (memq var sets)
          (code-builder-put-insn-arg1!
            cb
            (quote BOX)
            index)))
    vars))

(define
  pass3/dispatch-table
  (make-vector $INSN-NUM))

(define
  (pass3/register insn proc)
  (vector-set! pass3/dispatch-table insn proc))

(define
  (pass3/$const
    cb
    iform
    locals
    frees
    can-frees
    sets
    tail)
  (code-builder-put-insn-arg1!
    cb
    (quote CONSTANT)
    ($const.val iform))
  0)

(define
  (pass3/$it
    cb
    iform
    locals
    frees
    can-frees
    sets
    tail)
  0)

(define
  (pass3/$list
    cb
    iform
    locals
    frees
    can-frees
    sets
    tail)
  (let1 args
        ($list.args iform)
        (begin0
          (fold (lambda
                  (i accum)
                  (let1 size
                        (pass3/rec cb i locals frees can-frees sets tail)
                        (code-builder-put-insn-arg0! cb (quote PUSH))
                        (+ size accum)))
                0
                args)
          (code-builder-put-insn-arg1!
            cb
            (quote LIST)
            (length args)))))

(define
  (pass3/$local-ref
    cb
    iform
    locals
    frees
    can-frees
    sets
    tail)
  (pass3/compile-refer
    cb
    ($lvar.sym ($local-ref.lvar iform))
    locals
    frees)
  (when (hashtable-ref sets ($local-ref.lvar iform) #f)
        (code-builder-put-insn-arg0! cb (quote INDIRECT)))
  0)

(define
  (pass3/$local-assign
    cb
    iform
    locals
    frees
    can-frees
    sets
    tail)
  (let ((val-stack-size
          (pass3/rec
            cb
            ($local-assign.val iform)
            locals
            frees
            can-frees
            sets
            #f))
        (var-stack-size
          (pass3/compile-assign
            cb
            ($lvar.sym ($local-assign.lvar iform))
            locals
            frees)))
       (+ val-stack-size var-stack-size)))

(define
  top-level-sym
  (string->symbol "top level "))

(define
  (merge-libname-sym libname sym)
  (string->symbol
    (string-append
      (symbol->string libname)
      ":$:"
      (symbol->string sym))))

(define
  (pass3/$global-ref
    cb
    iform
    locals
    frees
    can-frees
    sets
    tail)
  (let1 sym
        ($global-ref.sym iform)
        (let next-free
             ((free frees) (n 0))
             (cond ((null? free)
                    (code-builder-put-insn-arg1!
                      cb
                      (quote REFER_GLOBAL)
                      (merge-libname-sym
                        ($global-ref.libname iform)
                        sym))
                    0)
                   ((eq? (car free) sym)
                    (code-builder-put-insn-arg1!
                      cb
                      (quote REFER_FREE)
                      n)
                    0)
                   (else (next-free (cdr free) (+ n 1)))))))

(define
  (pass3/$global-assign
    cb
    iform
    locals
    frees
    can-frees
    sets
    tail)
  (let1 sym
        ($global-assign.sym iform)
        (let next-free
             ((free frees) (n 0))
             (cond ((null? free)
                    (begin0
                      (pass3/rec
                        cb
                        ($global-assign.val iform)
                        locals
                        frees
                        can-frees
                        sets
                        #f)
                      (code-builder-put-insn-arg1!
                        cb
                        (quote ASSIGN_GLOBAL)
                        (merge-libname-sym
                          ($global-assign.libname iform)
                          sym))))
                   ((eq? (car free) sym)
                    (begin0
                      (pass3/rec
                        cb
                        ($global-assign.val iform)
                        locals
                        frees
                        can-frees
                        sets
                        #f)
                      (code-builder-put-insn-arg1!
                        cb
                        (quote ASSIGN_FREE)
                        n)))
                   (else (next-free (cdr free) (+ n 1)))))))

(define
  (pass3/$seq
    cb
    iform
    locals
    frees
    can-frees
    sets
    tail)
  (let loop
       ((form ($seq.body iform)) (size 0))
       (cond ((null? form) size)
             (else (let1 tail?
                         (if (null? (cdr form)) tail #f)
                         (loop (cdr form)
                               (+ size
                                  (pass3/rec
                                    cb
                                    (car form)
                                    locals
                                    frees
                                    can-frees
                                    sets
                                    tail?))))))))

(define
  (pass3/$undef
    cb
    iform
    locals
    frees
    can-frees
    sets
    tail)
  (code-builder-put-insn-arg0! cb (quote UNDEF))
  0)

(define
  (pass3/$asm-1-arg
    cb
    insn
    arg1
    locals
    frees
    can-frees
    sets)
  (begin0
    (pass3/rec
      cb
      arg1
      locals
      frees
      can-frees
      sets
      #f)
    (code-builder-put-insn-arg0! cb insn)))

(define
  (pass3/$asm-2-arg
    cb
    insn
    arg1
    arg2
    locals
    frees
    can-frees
    sets)
  (let ((x (pass3/compile-arg
             cb
             arg1
             locals
             frees
             can-frees
             sets
             #f))
        (y (pass3/rec
             cb
             arg2
             locals
             frees
             can-frees
             sets
             #f)))
       (code-builder-put-insn-arg0! cb insn)
       (+ x y)))

(define
  (pass3/$asm-3-arg
    cb
    insn
    arg1
    arg2
    arg3
    locals
    frees
    can-frees
    sets)
  (let ((x (pass3/compile-arg
             cb
             arg1
             locals
             frees
             can-frees
             sets
             #f))
        (y (pass3/compile-arg
             cb
             arg2
             locals
             frees
             can-frees
             sets
             #f))
        (z (pass3/rec
             cb
             arg3
             locals
             frees
             can-frees
             sets
             #f)))
       (code-builder-put-insn-arg0! cb insn)
       (+ x y z)))

(define
  (pass3/$asm-n-args
    cb
    args
    locals
    frees
    can-frees
    sets)
  (let loop
       ((args args) (stack-size 0))
       (cond ((null? args) stack-size)
             ((null? (cdr args))
              (+ stack-size
                 (pass3/rec
                   cb
                   (car args)
                   locals
                   frees
                   can-frees
                   sets
                   #f)))
             (else (loop (cdr args)
                         (+ stack-size
                            (pass3/compile-arg
                              cb
                              (car args)
                              locals
                              frees
                              can-frees
                              sets
                              #f)))))))

(define
  (pass3/$asm
    cb
    iform
    locals
    frees
    can-frees
    sets
    tail)
  (let1 args
        ($asm.args iform)
        (case ($asm.insn iform)
              ((APPEND2)
               (pass3/$asm-2-arg
                 cb
                 (quote APPEND2)
                 (first args)
                 (second args)
                 locals
                 frees
                 can-frees
                 sets))
              ((NUMBER_ADD)
               (pass3/$asm-2-arg
                 cb
                 (quote NUMBER_ADD)
                 (first args)
                 (second args)
                 locals
                 frees
                 can-frees
                 sets))
              ((NUMBER_SUB)
               (pass3/$asm-2-arg
                 cb
                 (quote NUMBER_SUB)
                 (first args)
                 (second args)
                 locals
                 frees
                 can-frees
                 sets))
              ((NUMBER_MUL)
               (pass3/$asm-2-arg
                 cb
                 (quote NUMBER_MUL)
                 (first args)
                 (second args)
                 locals
                 frees
                 can-frees
                 sets))
              ((NUMBER_DIV)
               (pass3/$asm-2-arg
                 cb
                 (quote NUMBER_DIV)
                 (first args)
                 (second args)
                 locals
                 frees
                 can-frees
                 sets))
              ((NUMBER_EQUAL)
               (pass3/$asm-2-arg
                 cb
                 (quote NUMBER_EQUAL)
                 (first args)
                 (second args)
                 locals
                 frees
                 can-frees
                 sets))
              ((NUMBER_GE)
               (pass3/$asm-2-arg
                 cb
                 (quote NUMBER_GE)
                 (first args)
                 (second args)
                 locals
                 frees
                 can-frees
                 sets))
              ((NUMBER_GT)
               (pass3/$asm-2-arg
                 cb
                 (quote NUMBER_GT)
                 (first args)
                 (second args)
                 locals
                 frees
                 can-frees
                 sets))
              ((NUMBER_LT)
               (pass3/$asm-2-arg
                 cb
                 (quote NUMBER_LT)
                 (first args)
                 (second args)
                 locals
                 frees
                 can-frees
                 sets))
              ((NUMBER_LE)
               (pass3/$asm-2-arg
                 cb
                 (quote NUMBER_LE)
                 (first args)
                 (second args)
                 locals
                 frees
                 can-frees
                 sets))
              ((CONS)
               (pass3/$asm-2-arg
                 cb
                 (quote CONS)
                 (first args)
                 (second args)
                 locals
                 frees
                 can-frees
                 sets))
              ((CAR)
               (pass3/$asm-1-arg
                 cb
                 (quote CAR)
                 (first args)
                 locals
                 frees
                 can-frees
                 sets))
              ((CDR)
               (pass3/$asm-1-arg
                 cb
                 (quote CDR)
                 (first args)
                 locals
                 frees
                 can-frees
                 sets))
              ((CAAR)
               (pass3/$asm-1-arg
                 cb
                 (quote CAAR)
                 (first args)
                 locals
                 frees
                 can-frees
                 sets))
              ((CADR)
               (pass3/$asm-1-arg
                 cb
                 (quote CADR)
                 (first args)
                 locals
                 frees
                 can-frees
                 sets))
              ((CDAR)
               (pass3/$asm-1-arg
                 cb
                 (quote CDAR)
                 (first args)
                 locals
                 frees
                 can-frees
                 sets))
              ((CDDR)
               (pass3/$asm-1-arg
                 cb
                 (quote CDDR)
                 (first args)
                 locals
                 frees
                 can-frees
                 sets))
              ((SET_CDR)
               (pass3/$asm-2-arg
                 cb
                 (quote SET_CDR)
                 (first args)
                 (second args)
                 locals
                 frees
                 can-frees
                 sets))
              ((SET_CAR)
               (pass3/$asm-2-arg
                 cb
                 (quote SET_CAR)
                 (first args)
                 (second args)
                 locals
                 frees
                 can-frees
                 sets))
              ((MAKE_VECTOR)
               (pass3/$asm-2-arg
                 cb
                 (quote MAKE_VECTOR)
                 (first args)
                 (second args)
                 locals
                 frees
                 can-frees
                 sets))
              ((VECTOR_LENGTH)
               (pass3/$asm-1-arg
                 cb
                 (quote VECTOR_LENGTH)
                 (first args)
                 locals
                 frees
                 can-frees
                 sets))
              ((VECTOR_SET)
               (pass3/$asm-3-arg
                 cb
                 (quote VECTOR_SET)
                 (first args)
                 (second args)
                 (third args)
                 locals
                 frees
                 can-frees
                 sets))
              ((VECTOR_REF)
               (pass3/$asm-2-arg
                 cb
                 (quote VECTOR_REF)
                 (first args)
                 (second args)
                 locals
                 frees
                 can-frees
                 sets))
              ((EQ)
               (pass3/$asm-2-arg
                 cb
                 (quote EQ)
                 (first args)
                 (second args)
                 locals
                 frees
                 can-frees
                 sets))
              ((EQV)
               (pass3/$asm-2-arg
                 cb
                 (quote EQV)
                 (first args)
                 (second args)
                 locals
                 frees
                 can-frees
                 sets))
              ((EQUAL)
               (pass3/$asm-2-arg
                 cb
                 (quote EQUAL)
                 (first args)
                 (second args)
                 locals
                 frees
                 can-frees
                 sets))
              ((PAIR_P)
               (pass3/$asm-1-arg
                 cb
                 (quote PAIR_P)
                 (first args)
                 locals
                 frees
                 can-frees
                 sets))
              ((NULL_P)
               (pass3/$asm-1-arg
                 cb
                 (quote NULL_P)
                 (first args)
                 locals
                 frees
                 can-frees
                 sets))
              ((SYMBOL_P)
               (pass3/$asm-1-arg
                 cb
                 (quote SYMBOL_P)
                 (first args)
                 locals
                 frees
                 can-frees
                 sets))
              ((VECTOR_P)
               (pass3/$asm-1-arg
                 cb
                 (quote VECTOR_P)
                 (first args)
                 locals
                 frees
                 can-frees
                 sets))
              ((NOT)
               (pass3/$asm-1-arg
                 cb
                 (quote NOT)
                 (first args)
                 locals
                 frees
                 can-frees
                 sets))
              ((OPEN_INPUT_FILE)
               (pass3/$asm-1-arg
                 cb
                 (quote OPEN_INPUT_FILE)
                 (first args)
                 locals
                 frees
                 can-frees
                 sets))
              ((READ)
               (pass3/$asm-1-arg
                 cb
                 (quote READ)
                 (first args)
                 locals
                 frees
                 can-frees
                 sets))
              ((READ_CHAR)
               (pass3/$asm-1-arg
                 cb
                 (quote READ_CHAR)
                 (first args)
                 locals
                 frees
                 can-frees
                 sets))
              ((VALUES)
               (begin0
                 (pass3/$asm-n-args
                   cb
                   args
                   locals
                   frees
                   can-frees
                   sets)
                 (code-builder-put-insn-arg1!
                   cb
                   (quote VALUES)
                   (length args))))
              ((APPLY)
               (let1 end-of-frame
                     (make-label)
                     (code-builder-put-insn-arg1!
                       cb
                       (quote FRAME)
                       (ref-label end-of-frame))
                     (let1 arg2-size
                           (pass3/rec
                             cb
                             (second args)
                             locals
                             frees
                             can-frees
                             sets
                             #f)
                           (code-builder-put-insn-arg0! cb (quote PUSH))
                           (let1 arg1-size
                                 (pass3/rec
                                   cb
                                   (first args)
                                   locals
                                   frees
                                   can-frees
                                   sets
                                   #f)
                                 (cput! cb (quote APPLY) end-of-frame)
                                 (+ arg1-size arg2-size)))))
              (else (print "unknown insn on pass3/$asm")))))

(define
  (pass3/$if
    cb
    iform
    locals
    frees
    can-frees
    sets
    tail)
  (let ((end-of-else (make-label))
        (begin-of-else (make-label)))
       (let1 test-size
             (pass3/rec
               cb
               ($if.test iform)
               locals
               frees
               can-frees
               sets
               #f)
             (code-builder-put-insn-arg1!
               cb
               (quote TEST)
               (ref-label begin-of-else))
             (let1 then-size
                   (pass3/rec
                     cb
                     ($if.then iform)
                     locals
                     frees
                     can-frees
                     sets
                     tail)
                   (cput! cb
                          (quote UNFIXED_JUMP)
                          (ref-label end-of-else)
                          begin-of-else)
                   (let1 else-size
                         (pass3/rec
                           cb
                           ($if.else iform)
                           locals
                           frees
                           can-frees
                           sets
                           tail)
                         (cput! cb end-of-else)
                         (+ test-size then-size else-size))))))

(define
  (pass3/$define
    cb
    iform
    locals
    frees
    can-frees
    sets
    tail)
  (begin0
    (pass3/rec
      cb
      ($define.val iform)
      locals
      frees
      can-frees
      sets
      #f)
    (cput! cb
           (quote DEFINE_GLOBAL)
           (merge-libname-sym
             ($define.libname iform)
             ($define.sym iform)))))

(define
  (pass3/compile-arg
    cb
    arg
    locals
    frees
    can-frees
    sets
    tail)
  (let1 size
        (pass3/rec cb arg locals frees can-frees sets #f)
        (code-builder-put-insn-arg0! cb (quote PUSH))
        (+ size 1)))

(define
  (pass3/compile-args
    cb
    args
    locals
    frees
    can-frees
    sets
    tail)
  (let loop
       ((size 0) (iform args))
       (cond ((null? iform) size)
             (else (loop (+ size
                            (pass3/compile-arg
                              cb
                              (car iform)
                              locals
                              frees
                              can-frees
                              sets
                              tail))
                         (cdr iform))))))

(define-macro
  (pass3/add-can-frees1 can-frees vars)
  (quasiquote
    (append
      (unquote can-frees)
      (list (unquote vars)))))

(define-macro
  (pass3/add-can-frees2 can-frees vars1 vars2)
  (quasiquote
    (append
      (append
        (unquote can-frees)
        (list (unquote vars1)))
      (list (unquote vars2)))))

(define
  (pass3/$call
    cb
    iform
    locals
    frees
    can-frees
    sets
    tail)
  (case ($call.type iform)
        ((jump)
         (let ((label ($lambda.body ($call.proc ($call.proc iform))))
               (args-length (length ($call.args iform))))
              (cput! cb (quote REDUCE) args-length)
              (begin0
                (pass3/compile-args
                  cb
                  ($call.args iform)
                  locals
                  frees
                  can-frees
                  sets
                  #f)
                (cput! cb
                       (quote SHIFT)
                       args-length
                       args-length
                       (quote UNFIXED_JUMP)
                       label))))
        ((embed)
         (let* ((label ($lambda.body ($call.proc iform)))
                (body ($label.body label))
                (vars ($lambda.lvars ($call.proc iform)))
                (vars-sym ($map1 $lvar.sym-proc vars))
                (frees-here
                  (pass3/find-free
                    body
                    vars-sym
                    (pass3/add-can-frees2 can-frees locals frees)))
                (sets-for-this-lvars (pass3/find-sets body vars)))
               (cput! cb (quote LET_FRAME))
               (let* ((frees-here-length (length frees-here))
                      (free-size
                        (if (> frees-here-length 0)
                            (pass3/collect-free cb frees-here locals frees)
                            0)))
                     (when (> frees-here-length 0)
                           (cput! cb (quote DISPLAY) frees-here-length))
                     (let ((args-size
                             (pass3/compile-args
                               cb
                               ($call.args iform)
                               locals
                               frees-here
                               can-frees
                               sets
                               #f))
                           (args-length (length ($call.args iform))))
                          (pass3/make-boxes cb sets-for-this-lvars vars)
                          (code-builder-put-insn-arg1!
                            cb
                            (quote ENTER)
                            args-length)
                          (cput! cb label)
                          (let1 body-size
                                (pass3/rec
                                  cb
                                  body
                                  vars-sym
                                  frees-here
                                  (pass3/add-can-frees1 can-frees vars-sym)
                                  (pass3/add-sets! sets sets-for-this-lvars)
                                  (if tail (+ tail (length vars) 2) #f))
                                (code-builder-put-insn-arg1!
                                  cb
                                  (quote LEAVE)
                                  args-length)
                                (+ args-size body-size free-size))))))
        (else (let1 end-of-frame
                    (make-label)
                    (unless
                      tail
                      (code-builder-put-insn-arg1!
                        cb
                        (quote FRAME)
                        (ref-label end-of-frame)))
                    (let* ((args-size
                             (pass3/compile-args
                               cb
                               ($call.args iform)
                               locals
                               frees
                               can-frees
                               sets
                               #f))
                           (proc-size
                             (pass3/rec
                               cb
                               ($call.proc iform)
                               locals
                               frees
                               can-frees
                               sets
                               #f))
                           (args-length (length ($call.args iform))))
                          (when tail
                                (cput! cb (quote SHIFT) args-length tail))
                          (code-builder-put-insn-arg1!
                            cb
                            (quote CALL)
                            args-length)
                          (unless tail (cput! cb end-of-frame))
                          (+ args-size proc-size))))))

(define
  (pass3/$call-cc
    cb
    iform
    locals
    frees
    can-frees
    sets
    tail)
  (let1 end-of-frame
        (make-label)
        (unless
          tail
          (code-builder-put-insn-arg1!
            cb
            (quote FRAME)
            (ref-label end-of-frame)))
        (cput! cb
               (quote MAKE_CONTINUATION)
               (if tail 1 0))
        (code-builder-put-insn-arg0! cb (quote PUSH))
        (begin0
          (pass3/rec
            cb
            ($call-cc.proc iform)
            locals
            frees
            can-frees
            sets
            #f)
          (when tail (cput! cb (quote SHIFT) 1 tail))
          (code-builder-put-insn-arg1! cb (quote CALL) 1)
          (unless tail (cput! cb end-of-frame)))))

(define
  (pass3/$lambda
    cb
    iform
    locals
    frees
    can-frees
    sets
    tail)
  (let* ((vars ($lambda.lvars iform))
         (vars-sym ($map1 $lvar.sym-proc vars))
         (body ($lambda.body iform))
         (frees-here
           (pass3/find-free
             body
             vars
             (pass3/add-can-frees2 can-frees locals frees)))
         (sets-for-this-lvars (pass3/find-sets body vars))
         (end-of-closure (make-label))
         (lambda-cb (make-code-builder))
         (frees-here-length (length frees-here))
         (free-size
           (if (> frees-here-length 0)
               (pass3/collect-free cb frees-here locals frees)
               0))
         (vars-length (length vars)))
        (cput! cb
               (quote CLOSURE)
               (ref-label end-of-closure)
               vars-length
               (> ($lambda.optarg iform) 0)
               frees-here-length)
        (let1 body-size
              (pass3/rec
                lambda-cb
                body
                vars-sym
                frees-here
                (pass3/add-can-frees1 can-frees vars-sym)
                (pass3/add-sets! sets sets-for-this-lvars)
                vars-length)
              (cput! cb
                     (+ body-size free-size vars-length 4)
                     ($lambda.src iform))
              (pass3/make-boxes cb sets-for-this-lvars vars)
              (code-builder-append! cb lambda-cb)
              (code-builder-put-insn-arg1!
                cb
                (quote RETURN)
                vars-length)
              (cput! cb end-of-closure)
              0)))

(define
  (pass3/$receive
    cb
    iform
    locals
    frees
    can-frees
    sets
    tail)
  (let* ((vars ($receive.lvars iform))
         (vars-sym ($map1 $lvar.sym-proc vars))
         (body ($receive.body iform))
         (frees-here
           (append
             (pass3/find-free
               ($receive.vals iform)
               locals
               (pass3/add-can-frees2 can-frees locals frees))
             (pass3/find-free
               body
               vars-sym
               (pass3/add-can-frees2 can-frees locals frees))))
         (sets-for-this-lvars (pass3/find-sets body vars)))
        (cput! cb (quote LET_FRAME))
        (let* ((frees-here-length (length frees-here))
               (free-size
                 (if (> frees-here-length 0)
                     (pass3/collect-free cb frees-here locals frees)
                     0)))
              (when (> frees-here-length 0)
                    (cput! cb (quote DISPLAY) frees-here-length))
              (let ((vals-size
                      (pass3/rec
                        cb
                        ($receive.vals iform)
                        locals
                        frees-here
                        can-frees
                        sets
                        #f))
                    (vars-length (length vars)))
                   (cput! cb
                          (quote RECEIVE)
                          ($receive.reqargs iform)
                          ($receive.optarg iform))
                   (pass3/make-boxes cb sets-for-this-lvars vars)
                   (code-builder-put-insn-arg1!
                     cb
                     (quote ENTER)
                     vars-length)
                   (let1 body-size
                         (pass3/rec
                           cb
                           body
                           vars-sym
                           frees-here
                           (pass3/add-can-frees1 can-frees vars-sym)
                           (pass3/add-sets! sets sets-for-this-lvars)
                           (if tail (+ tail vars-length 2) #f))
                         (code-builder-put-insn-arg1!
                           cb
                           (quote LEAVE)
                           vars-length)
                         (+ body-size vals-size free-size))))))

(define
  (pass3/$let
    cb
    iform
    locals
    frees
    can-frees
    sets
    tail)
  (if (eq? ($let.type iform) (quote rec))
      (pass3/letrec
        cb
        iform
        locals
        frees
        can-frees
        sets
        tail)
      (let* ((vars ($let.lvars iform))
             (vars-sym ($map1 $lvar.sym-proc vars))
             (body ($let.body iform))
             (frees-here
               (append
                 ($append-map1
                   (lambda
                     (i)
                     (pass3/find-free
                       i
                       locals
                       (pass3/add-can-frees2 can-frees frees locals)))
                   ($let.inits iform))
                 (pass3/find-free
                   body
                   vars-sym
                   (pass3/add-can-frees2 can-frees frees locals))))
             (sets-for-this-lvars (pass3/find-sets body vars))
             (frees-here-length (length frees-here))
             (vars-length (length vars)))
            (cput! cb (quote LET_FRAME))
            (let1 free-size
                  (if (> frees-here-length 0)
                      (pass3/collect-free cb frees-here locals frees)
                      0)
                  (when (> frees-here-length 0)
                        (cput! cb (quote DISPLAY) frees-here-length))
                  (let1 args-size
                        (pass3/compile-args
                          cb
                          ($let.inits iform)
                          locals
                          frees-here
                          can-frees
                          sets
                          tail)
                        (pass3/make-boxes cb sets-for-this-lvars vars)
                        (code-builder-put-insn-arg1!
                          cb
                          (quote ENTER)
                          vars-length)
                        (let1 body-size
                              (pass3/rec
                                cb
                                body
                                vars-sym
                                frees-here
                                (pass3/add-can-frees1 can-frees vars-sym)
                                (pass3/add-sets! sets sets-for-this-lvars)
                                (if tail (+ tail vars-length 2) #f))
                              (code-builder-put-insn-arg1!
                                cb
                                (quote LEAVE)
                                vars-length)
                              (+ body-size args-size free-size)))))))

(define
  (pass3/letrec
    cb
    iform
    locals
    frees
    can-frees
    sets
    tail)
  (let* ((vars ($let.lvars iform))
         (vars-sym ($map1 $lvar.sym-proc vars))
         (body ($let.body iform))
         (frees-here
           (append
             ($append-map1
               (lambda
                 (i)
                 (pass3/find-free
                   i
                   vars
                   (pass3/add-can-frees2 can-frees locals frees)))
               ($let.inits iform))
             (pass3/find-free
               body
               vars-sym
               (pass3/add-can-frees2 can-frees locals frees))))
         (sets-for-this-lvars
           (append
             vars
             (pass3/find-sets body vars)
             ($append-map1
               (lambda (i) (pass3/find-sets i vars))
               ($let.inits iform))))
         (args ($let.inits iform))
         (frees-here-length (length frees-here))
         (vars-length (length vars)))
        (cput! cb (quote LET_FRAME))
        (let1 free-size
              (if (> frees-here-length 0)
                  (pass3/collect-free cb frees-here locals frees)
                  0)
              (when (> frees-here-length 0)
                    (cput! cb (quote DISPLAY) frees-here-length))
              (let loop
                   ((args args))
                   (cond ((null? args) (quote ()))
                         (else (cput! cb (quote UNDEF))
                               (code-builder-put-insn-arg0! cb (quote PUSH))
                               (loop (cdr args)))))
              (pass3/make-boxes cb sets-for-this-lvars vars)
              (code-builder-put-insn-arg1!
                cb
                (quote ENTER)
                vars-length)
              (let* ((new-can-frees
                       (pass3/add-can-frees1 can-frees vars-sym))
                     (assign-size
                       (let loop
                            ((args args) (size 0) (index 0))
                            (cond ((null? args) size)
                                  (else (let1 stack-size
                                              (pass3/rec
                                                cb
                                                (car args)
                                                vars-sym
                                                frees-here
                                                new-can-frees
                                                (pass3/add-sets!
                                                  sets
                                                  sets-for-this-lvars)
                                                #f)
                                              (code-builder-put-insn-arg1!
                                                cb
                                                (quote ASSIGN_LOCAL)
                                                index)
                                              (loop (cdr args)
                                                    (+ stack-size size)
                                                    (+ index 1))))))))
                    (let1 body-size
                          (pass3/rec
                            cb
                            body
                            vars-sym
                            frees-here
                            new-can-frees
                            (pass3/add-sets! sets sets-for-this-lvars)
                            (if tail (+ tail vars-length 2) #f))
                          (code-builder-put-insn-arg1!
                            cb
                            (quote LEAVE)
                            vars-length)
                          (+ free-size assign-size body-size))))))

(define
  (pass3/$import
    cb
    iform
    locals
    frees
    can-frees
    sets
    tail)
  (define
    (rec form)
    (for-each
      (lambda
        (s)
        (let* ((libname ($import-spec.libname s))
               (lib (hashtable-ref libraries libname))
               (end-of-frame (make-label)))
              (rec ($library.import lib))
              (code-builder-put-insn-arg1!
                cb
                (quote FRAME)
                (ref-label end-of-frame))
              (cput! cb (quote IMPORT) libname end-of-frame)))
      ($import.import-specs form))
    0)
  (rec iform))

(define
  (pass3/$library
    cb
    iform
    locals
    frees
    can-frees
    sets
    tail)
  (cput! cb
         (quote LIBRARY)
         ($library.name iform)
         iform)
  0)

(pass3/register $CONST pass3/$const)

(pass3/register $LAMBDA pass3/$lambda)

(pass3/register $LOCAL-REF pass3/$local-ref)

(pass3/register
  $LOCAL-ASSIGN
  pass3/$local-assign)

(pass3/register
  $GLOBAL-ASSIGN
  pass3/$global-assign)

(pass3/register $GLOBAL-REF pass3/$global-ref)

(pass3/register $SEQ pass3/$seq)

(pass3/register $UNDEF pass3/$undef)

(pass3/register $IF pass3/$if)

(pass3/register $ASM pass3/$asm)

(pass3/register $DEFINE pass3/$define)

(pass3/register $CALL pass3/$call)

(pass3/register $CALL-CC pass3/$call-cc)

(pass3/register $LET pass3/$let)

(pass3/register $LIST pass3/$list)

(pass3/register $LIBRARY pass3/$library)

(pass3/register $IMPORT pass3/$import)

(pass3/register $IT pass3/$it)

(pass3/register $RECEIVE pass3/$receive)

(define
  (pass3/rec
    cb
    iform
    locals
    frees
    can-frees
    sets
    tail)
  ((vector-ref
     pass3/dispatch-table
     (vector-ref iform 0))
   cb
   iform
   locals
   frees
   can-frees
   sets
   tail))

(define
  (pass3 iform)
  (let1 cb
        (make-code-builder)
        (pass3/rec
          cb
          iform
          (quote ())
          *free-vars-decl*
          (quote ())
          (make-eq-hashtable)
          #f)
        (code-builder-emit cb)))

(define
  (pass4 lst)
  (pass4/fixup-labels
    (list->vector (append lst (quote (HALT))))))

(define
  (compile-library-body! lib)
  (let1 body
        ($append-map1
          (lambda
            (sexp)
            (pass3 (pass2/optimize
                     (pass1/sexp->iform
                       (pass1/expand sexp)
                       lib
                       (quote ())
                       #f)
                     (quote ()))))
          ($library.body lib))
        ($library.set-compiled-body!
          lib
          (pass4 (quasiquote ((unquote-splicing body) RETURN 0))))))

(define-macro (merge-insn sexp) sexp)(define
  (compile-partial sexp . lib)
  (let1 ss
        (pass1/expand sexp)
        (vector->list
          (pass4/fixup-labels
            (list->vector
              (merge-insn
                (pass3 (pass2/optimize
                         (pass1/sexp->iform
                           ss
                           (if (null? lib) top-level-library (car lib))
                           (quote ())
                           #f)
                         (quote ())))))))))

(define-macro
  (pass4/fixup-labels-clollect insn)
  (quasiquote
    (begin (vector-set! ret j (unquote insn))
           (vector-set! ret (+ j 1) (vector-ref v (+ i 1)))
           (loop (+ i 2) (+ j 2)))))

(define-macro
  (pass4/fixup-labels-insn insn)
  (quasiquote
    (let1 label
          (hashtable-ref
            labels
            (vector-ref code (+ i 1))
            #f)
          (cond (label (vector-set! code i (unquote insn))
                       (vector-set! code (+ i 1) (- label i 1))
                       (loop (+ i 2)))
                (else (loop (+ i 1)))))))

(define
  (pass4/fixup-labels v)
  (define
    (collect-labels)
    (let* ((len (vector-length v))
           (ret (make-vector len (quote NOP)))
           (labels (make-eq-hashtable)))
          (let loop
               ((i 0) (j 0))
               (cond ((= i len) (values ret labels))
                     (else (let1 insn
                                 (vector-ref v i)
                                 (cond ((eq? insn (quote UNFIXED_JUMP))
                                        (pass4/fixup-labels-clollect
                                          (quote UNFIXED_JUMP)))
                                       ((eq? insn (quote TEST))
                                        (pass4/fixup-labels-clollect
                                          (quote TEST)))
                                       ((eq? insn (quote NUMBER_LE_TEST))
                                        (pass4/fixup-labels-clollect
                                          (quote NUMBER_LE_TEST)))
                                       ((eq? insn (quote NOT_TEST))
                                        (pass4/fixup-labels-clollect
                                          (quote NOT_TEST)))
                                       ((eq? insn
                                             (quote REFER_LOCAL0_EQV_TEST))
                                        (pass4/fixup-labels-clollect
                                          (quote REFER_LOCAL0_EQV_TEST)))
                                       ((eq? insn (quote FRAME))
                                        (pass4/fixup-labels-clollect
                                          (quote FRAME)))
                                       ((eq? insn (quote PUSH_FRAME))
                                        (pass4/fixup-labels-clollect
                                          (quote PUSH_FRAME)))
                                       ((eq? insn (quote CLOSURE))
                                        (pass4/fixup-labels-clollect
                                          (quote CLOSURE)))
                                       ((and (vector? insn)
                                             (> (vector-length insn) 0)
                                             (tag? insn $LABEL))
                                        (hashtable-set! labels insn j)
                                        (loop (+ i 1) j))
                                       (else (vector-set! ret j insn)
                                             (loop (+ i 1) (+ j 1))))))))))
  (receive
    (code labels)
    (collect-labels)
    (let1 len
          (vector-length code)
          (let loop
               ((i 0))
               (cond ((= i len) code)
                     (else (let1 insn
                                 (vector-ref code i)
                                 (cond ((eq? insn (quote UNFIXED_JUMP))
                                        (pass4/fixup-labels-insn
                                          (quote LOCAL_JMP)))
                                       ((eq? insn (quote CLOSURE))
                                        (pass4/fixup-labels-insn
                                          (quote CLOSURE)))
                                       ((eq? insn (quote TEST))
                                        (pass4/fixup-labels-insn (quote TEST)))
                                       ((eq? insn (quote NUMBER_LE_TEST))
                                        (pass4/fixup-labels-insn
                                          (quote NUMBER_LE_TEST)))
                                       ((eq? insn (quote NOT_TEST))
                                        (pass4/fixup-labels-insn
                                          (quote NOT_TEST)))
                                       ((eq? insn
                                             (quote REFER_LOCAL0_EQV_TEST))
                                        (pass4/fixup-labels-insn
                                          (quote REFER_LOCAL0_EQV_TEST)))
                                       ((eq? insn (quote FRAME))
                                        (pass4/fixup-labels-insn
                                          (quote FRAME)))
                                       ((eq? insn (quote PUSH_FRAME))
                                        (pass4/fixup-labels-insn
                                          (quote PUSH_FRAME)))
                                       (else (loop (+ i 1)))))))))))

(define
  (compile sexp)
  (pass4 (merge-insn
           (pass3 (let1 x
                        (pass2/optimize
                          (pass1/sexp->iform
                            (pass1/expand sexp)
                            top-level-library
                            (quote ())
                            #f)
                          (quote ()))
                        x)))))

(define
  (compile-no-optimize sexp)
  (pass4 (pass3 (pass1/sexp->iform
                  (pass1/expand sexp)
                  top-level-library
                  (quote ())
                  #f))))

#f